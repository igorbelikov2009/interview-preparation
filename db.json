{
  "posts": [{ "id": 1, "title": "json-server", "author": "typicode" }],
  "comments": [{ "id": 1, "body": "some comment", "postId": 1 }],
  "profile": { "name": " HTTP - заголовки. " },
  "linksCSS": [
    {
      "href": "https://www.npmjs.com/package/node-sass",
      "title": "npm i node-sass"
    },
    {
      "href": " ",
      "title": " "
    },
    {
      "href": "https://meyerweb.com/eric/tools/css/reset/",
      "title": "Сброс - reset CSS."
    },
    {
      "href": "https://bobbyhadz.com/",
      "title": "Блог боббихадз, статьи о веб-разработке и облачных вычислениях."
    },
    {
      "href": "https://active-vision.ru/icon/box-shadow/",
      "title": "CSS BOX-SHADOW ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/icon/gradient/",
      "title": "CSS GRADIENT ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/blog/youtube-video-na-sayt/",
      "title": "Добавляем YouTube видео на сайт"
    },
    {
      "href": "https://ru.savefrom.net/1-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1-%D1%81%D0%BA%D0%B0%D1%87%D0%B0%D1%82%D1%8C-%D1%81-youtube-80/",
      "title": "Скачать видео и музыку с Ютуба"
    },
    {
      "href": "https://webstool.ru/jquery.maskedinput.html",
      "title": "jQuery.Maskedinput js - маска для телефона"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors",
      "title": "Селекторы CSS"
    },
    {
      "href": "https://htmlacademy.ru/blog/css/selectors",
      "title": "Селекторы CSS по htmlacademy"
    },
    {
      "href": "https://habr.com/ru/company/ruvds/blog/485640/",
      "title": "Какими способами можно визуально скрыть элемент?"
    },
    {
      "href": "http://htmlbook.ru/samlayout/blochnaya-verstka/strochnye-elementy",
      "title": "Строчные элементы в HTML (Языке Гипертекстовой Разметки),"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/HTML/Inline_elements",
      "title": "Строчные элементы по 'developer.mozilla'"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements",
      "title": "Блочные элементы по 'developer.mozilla'"
    },
    {
      "href": "http://htmlbook.ru/css/display",
      "title": "Свойство display."
    },
    {
      "href": "http://htmlbook.ru/samlayout/blochnaya-verstka/pozitsionirovanie-elementov",
      "title": "Позиционирование элементов"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements",
      "title": "Псевдоэлемент в CSS"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-classes",
      "title": "Псевдокласс в CSS"
    },
    {
      "href": "https://learn.javascript.ru/size-and-scroll-window#zapretit-prokrutku",
      "title": "Запретить прокрутку"
    },
    {
      "href": "https://active-vision.ru/blog/polosa-prokrutki-css/",
      "title": "Как стилизовать или убрать полосу прокрутки — CSS скроллбар"
    },
    {
      "href": "https://ru.stackoverflow.com/questions/431590/%D0%A3%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-input-type-number",
      "title": "Убрать стрелочки с input type='number'"
    },
    {
      "href": "https://html5book.ru/css3-ten-bloka/",
      "title": "Как сделать тень блока с помощью свойства box-shadow"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/transform",
      "title": "transform Интерактивный пример"
    },
    {
      "href": "https://habr.com/ru/company/ruvds/blog/493660/",
      "title": "CSS: полное руководство по функции calc()"
    },
    {
      "href": "https://active-vision.ru/blog/css-psevdoklass-is/",
      "title": "CSS псевдокласс :is() — как и где его использовать"
    },
    {
      "href": "https://active-vision.ru/blog/kak-sdelat-stupenchatuyu-animatsiyu-pri-navedenii-na-chistom-css/",
      "title": "Как сделать ступенчатую анимацию при наведении курсора на чистом CSS"
    },

    {
      "href": "https://materializecss.com/",
      "title": "Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design."
    },
    {
      "href": "https://vk.com/@result.school-17-klassnyh-css-bibliotek",
      "title": "17 классных CSS-библиотек. Подборка полезных CSS библиотек, которые помогут вам при разработке веб-сайтов"
    },
    {
      "href": "https://animate.style/",
      "title": "Библиотека 'Animate.css'"
    },
    {
      "href": " ",
      "title": " "
    }
  ],
  "linksCSSFishki": [
    {
      "href": "https://active-vision.ru/icon/box-shadow/",
      "title": "BOX-SHADOW ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/icon/gradient/",
      "title": "GRADIENT ГЕНЕРАТОР"
    },
    {
      "href": "",
      "title": ""
    }
  ],
  "linksFrameworksCSS": [
    {
      "href": "https://www.npmjs.com/package/node-sass",
      "title": "npm i node-sass"
    },
    {
      "href": "https://storybook.js.org/",
      "title": "Storybook — это мастер-класс по внешнему интерфейсу для изолированного создания компонентов и страниц пользовательского интерфейса. Тысячи команд используют его для разработки пользовательского интерфейса, тестирования и документации. Это с открытым исходным кодом и бесплатно."
    },
    {
      "href": "https://habr.com/ru/post/340384/",
      "title": "Создание библиотеки компонентов с использованием Storybook"
    },
    {
      "href": "https://ant.design/docs/react/introduce",
      "title": "Ant Design of React - библиотека пользовательского интерфейса React antd, которая содержит набор высококачественных компонентов и демонстраций для создания многофункциональных интерактивных пользовательских интерфейсов."
    },
    {
      "href": "https://loading.io/css",
      "title": "Pure CSS Loaders"
    },
    {
      "href": "https://tailwindcss.com/docs/guides/create-react-app",
      "title": "Tailwind CSS - Утилитарный CSS-фреймворк для создания любого дизайна в вашей разметке."
    },
    {
      "href": "https://www.youtube.com/watch?v=_KWNWBhR6Vc",
      "title": "Tailwind CSS + React - Проект с нуля. Max Roslow."
    },
    {
      "href": "https://react-bootstrap.netlify.app/components/alerts/",
      "title": "bootstrap components (компоненты)"
    },
    {
      "href": "https://bootstrap-5.ru/",
      "title": "Bootstrap"
    },
    {
      "href": "https://react-bootstrap.github.io/getting-started/introduction/",
      "title": "React-Bootstrap. npm install react-bootstrap bootstrap"
    },
    {
      "href": "https://react-bootstrap-v4.netlify.app/getting-started/introduction/",
      "title": "React-Bootstrap. npm install react-bootstrap bootstrap@4.6.0"
    },
    {
      "href": "https://react.school/material-ui",
      "title": "Material UI — библиотека пользовательского интерфейса React. Честно говоря, нет второй библиотеки пользовательского интерфейса для React, которую мы могли бы порекомендовать."
    },
    {
      "href": "https://v4.mui.com/ru/getting-started/installation/",
      "title": "Инструкция по установке Material-UI, самый популярный в мире фреймворк для пользовательского интерфейса React."
    },
    {
      "href": "https://mui.com/material-ui/getting-started/overview/",
      "title": "Material UI — это библиотека компонентов пользовательского интерфейса React, реализующая Material Design от Google."
    },
    {
      "href": "https://mui.com/material-ui/about-the-lab/",
      "title": "О лаборатории. В этом пакете размещаются компоненты инкубатора, которые еще не готовы к перемещению в ядро."
    },
    {
      "href": "https://mui.com/",
      "title": "Material UI. React. Typescript. CSS "
    },
    {
      "href": "https://github.com/mui/material-ui",
      "title": "mui/material-ui"
    },
    {
      "href": "https://mui.com/material-ui/react-rating/#main-content",
      "title": "material-ui components (компоненты)"
    },
    {
      "href": "https://www.youtube.com/watch?v=OZ_FUaV_xbg&t=6s",
      "title": "Библиотека компонентов Material UI. Быстрый старт. Михаил Непомнящий."
    },
    {
      "href": "",
      "title": ""
    },
    {
      "href": "",
      "title": ""
    }
  ],
  "arrayCSS": [
    {
      "heading": "CSS, фреймворки CSS.",
      "answer": [
        "Каскадная таблица стилей (CSS) формально является набором команд и инструментов для работы с внешним видом веб-страницы. Она делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. Как и в случае с языками программирования, существует множество готовых библиотек CSS, созданных профессионалами для удобства работы со стилями.",
        "CSS-фреймворк — фреймворк, созданный для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки (проблемы совместимости различных версий браузеров и т. д.). Готовые к использованию классы являются их основными строительными блоками. Они позволяют применять к элементам HTML заранее определенные правила, а также включают в себя готовые компоненты (меню, кнопки, карточки). Данные фреймворки подразумевают использование различных подходов для корректного отображения сайтов на устройствах любого размера. Многие разработчики предпочитают использование CSS-фреймворков, вместо прописывания всех стилей вручную. Это обусловлено следующими причинами:",
        " - Более быстрая разработка ",
        " - Поддержка кроссбраузерности",
        " - Поддержка различных устройств и размеров экранов",
        " - Единообразие кода при работе в команде позволяет снизить число разногласий при разработке. ",
        " - Как и библиотеки скриптовых языков программирования, CSS-библиотеки, обычно имеющие вид внешнего CSS-файла, добавляются в заголовок веб-страницы."
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим самые популярные CSS-фреймворки.",
      "answer": [
        "Bootstrap",
        "https://getbootstrap.com/",
        "Material Design for Bootstrap",
        "https://mdbootstrap.com/docs/standard/",
        "Materialize",
        "https://materializecss.com/",
        "Bulma",
        "https://bulma.io/",
        "Pure",
        "https://purecss.io/",
        "Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design.",
        "https://materializecss.com/",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Какими CSS-фреймворками вы пользовались? Что бы вы хотели в них изменить/улучшить?",
      "answer": [
        "Использовал Bootstrap, Materialize и др. CSS-фреймворки накладывают ограничения и добавляют работы по переопределению дефолтных свойств элементов. Если нет чётких требования использования фреймворков, стараюсь их избегать."
      ],
      "isParagraph": true
    },
    {
      "heading": "Какая разница между селекторами идентификаторов и классов в CSS?",
      "answer": [
        "Идентификаторы (id) уникальны. У элемента может быть только один идентификатор. На странице может присутствовать лишь один элемент с конкретным идентификатором.",
        "Имена классов (class) не являются уникальными. Один и тот же класс можно назначать множеству элементов. Элементу может быть назначено несколько классов.",
        "Если некий стиль нужно применить к нескольким элементам страницы — эту задачу нужно решать с использованием классов."
      ],
      "isParagraph": true
    },
    {
      "heading": "Псевдоэлементы ::after, ::before и другие",
      "answer": [
        "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент ::first-line может быть использован для изменения шрифта первой строки абзаца."
      ],
      "isParagraph": true
    },
    {
      "heading": "Псевдоклассы :hover, :visited, :checked и другие",
      "answer": [
        "Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое позволяет стилизовать элемент: ",
        " - на основе отношений в DOM-дереве,",
        " - истории посещений (например, :visited),",
        " - состоянии содержимого (вроде :checked у некоторых элементов формы)",
        " - или позиции курсора мыши (например, :hover определяет, находится ли курсор мыши над элементом)... ",
        " - Например, :hover может быть использован для изменения цвета кнопки при наведении курсора на неё."
      ],
      "isParagraph": true
    },
    {
      "heading": "Как задать элементу определенные стили при наведении, при нажатии, при фокусе?",
      "answer": [
        "при наведении - с помощью псевдокласса hover ",
        "при нажатии - с помощью псевдокласса active ",
        "при фокусе - с помощью псевдокласса focus "
      ],
      "isParagraph": true
    },
    {
      "heading": "У вас есть список покупок. Каждому второму элементу списка необходимо задать синий фон. Как это можно сделать используя псевдоселекторы ",
      "answer": ["С помощью псевдокласса tr:nth-child(even) или tr:nth-child(2n) (чётные строки HTML)", " "],
      "isParagraph": true
    },
    {
      "heading": "Как пользоваться медиазапросами @media в CSS?",
      "answer": [
        "В медиазапросах используется правило @media, с помощью которого можно применять CSS-стили к различным типам содержимого. Медиазапросы могут использоваться и для настройки элементов страниц с учётом характеристик среды, в которой просматривают страницы.",
        "/* Изменить фоновый цвет любого элемента div на ''red'' в том случае, если ширина окна браузера составляет 600px или меньше */ ",
        "@media only screen and ( max-width: 600px ) {div { background-color: red }} ",
        "Медиа-запросы @media позволяют задавать различные стили элементам, компонентам вэб-приложения для определенного размера экрана, типа устройства, где данное вэб-приложение просматривается или используется. Все медиа-запросы начинаются с @media, а далее следует условие. ",
        "С помощью медиа-запросов можно задать стили для следующих типов устройств: ",
        " - all — все типы (значение используется по умолчанию)",
        " - braille — устройства, основанные на системе Брайля, которые предназначены для чтения слепыми людьми",
        " - embossed — принтеры, использующие для печати систему Брайля ",
        " - handheld — смартфоны и аналогичные им аппараты",
        " - print — принтеры и другие печатающие устройства",
        " - projection — проекторы",
        " - screen — экран монитора",
        " - speech — речевые синтезаторы, а также программы для воспроизведения текста вслух",
        " - tty — устройства с фиксированным размером символов",
        " - tv — телевизоры."
      ],
      "isParagraph": true
    },
    {
      "heading": "Специфичность CSS-селекторов и как она работает?",
      "answer": [
        "Если одному и тому же элементу определенно сразу несколько CSS-правил с разными селекторами, то браузер применит тот стиль, который определён по специфичности CSS-селекторов.",
        "Специфичность CSS-селекторов - это алгоритм, основанный на правилах соответствия селекторов CSS, который определяет, какие стили будут примены к данному элементу.",
        "Специфичность селекторов по возрастанию:",
        " - тег и псевдоэлемент имеют специфичность 0001 ",
        " - класс, псевдокласс, атрибут - 0010 ",
        " - id имеет специфичность 0100 ",
        " - инлайновый стиль (style=''...'') указанный в HTML-коде имеет приоритет 1000 ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "reset - «сброс», Normalize - «нормализация». В чем разница между ними?",
      "answer": [
        "Сброс (reset) сбрасывает все дефолтно-браузерные стили HTML-элементов.",
        "Normalize приводит стили к единому виду во всех браузерах.",
        "Цели normalize.css: ",
        " - сохранять полезные настройки браузера, а не стирать их;",
        " - нормализовать стили для широкого круга HTML-элементов;",
        " - корректировать ошибки и несоответствия браузера;",
        " - совершенствовать юзабилити незаметными улучшениями;",
        " - объяснять код, используя комментарии и детальную документацию.",
        " Из-за кроссбраузерности следует выбирать Normalize, но я пользуюсь reset"
      ],
      "isParagraph": true
    },
    {
      "heading": "Как вы решаете стилевые проблемы, связанные с особенностями браузеров?",
      "answer": [" - Использую normalize или reset CSS", " - Использую автопрефиксы (autoprefixer)"],
      "isParagraph": true
    },
    {
      "heading": "floats, как они работают",
      "answer": [
        "При применении этого свойства происходит следующее:",
        " 1. Элемент позиционируется как обычно, а затем вынимается из потока документа и сдвигается влево (для left) или вправо (для right) до того как коснётся либо границы родителя, либо другого элемента с float. ",
        " 2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться. ",
        " 3. Другие непозиционированные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из потока.  ",
        " 4. Строки (inline-элементы), напротив, «знают» о float и обтекают элемент по сторонам."
      ],
      "isParagraph": true
    },
    {
      "heading": "свойство z-index",
      "answer": [
        "Позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы. Их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative (абсолютное, фиксированное или относительное).",
        " - Элементы с большим z-index перекрывают элементы с меньшим. ",
        " - При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML написан ниже.",
        " - Если свойства z-index и позиционирование не заданы явно, то порядок наложения равен порядку следования элементов в HTML."
      ],
      "isParagraph": true
    },
    {
      "heading": "Эффективый CSS, на что обратить внимание?",
      "answer": [
        "Для написания эффективного CSS должна быть система. Я использую модификацию БЭМ и препроцессор SASS. Код можно переиспользовать."
      ],
      "isParagraph": true
    },
    {
      "heading": "Какими способами можно визуально скрыть элемент?",
      "answer": [
        "Элементы, невидимые на странице, могут пребывать в различных состояниях:",
        " - Некий элемент совершенно невидим и, более того, удалён из потока документа.",
        " - Глазами элемент не увидеть, но он присутствует в документе и доступен для ассистивных технологий наподобие средств для чтения с экрана.",
        " - Элемент видим, но скрыт от средств для чтения с экрана."
      ],
      "isParagraph": true
    },
    {
      "heading": "1. HTML5-атрибут hidden ",
      "answer": [
        "Hidden — это логический HTML-атрибут, скрывающий элементы, которым он назначен. Когда браузер загружает страницу, он не выведет элементы с атрибутом hidden, за исключением тех случаев, когда видимость элементов будет включена вручную средствами CSS.",
        "<img hidden src=''landscape.jpg'' /> ",
        "Вот CSS-код, который здесь использован:  ",
        " - 1. img[ hidden ] { display: none }",
        " - 2. @media ( min-width: 400px ) { img[ hidden ] { display: block }}",
        "Если рассмотреть 'атрибут hidden' с точки зрения доступности контента, то окажется, что этот атрибут полностью скрывает элемент. В результате с этим элементом не смогут работать средства для чтения с экрана. Не используйте этот атрибут в тех случаях, когда некие элементы страниц нужно делать невидимыми для человека, но не для программ для чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. CSS-свойство display",
      "answer": [
        " - 1. img { display: none } ",
        " - 2.  @media ( min-width: 400px ) {img { display: block }} ",
        "При использовании свойства 'display: none' элемент становится невидимым и, кроме того, недоступным для средств чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "3. CSS-свойство opacity",
      "answer": [
        " - 1. img { opacity: 0 }  ",
        "Элемент, скрытый с помощью opacity: 0, остаётся доступным для средств чтения с экрана. Такой элемент может получить фокус при работе со страницей с помощью клавиатуры. "
      ],
      "isParagraph": true
    },
    {
      "heading": "4. CSS-свойство visibility",
      "answer": [
        " - 1. article { visibility: hidden }",
        " - 2. img {  visibility: visible } ",
        "При применении свойства visibility: hidden элемент оказывается скрытым. Он, кроме того, удаляется из дерева доступности и, в результате, его не замечают средства для чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "5.Скрытие элементов и позиционирование",
      "answer": [
        " - .container { position: absolute; top: -100%; (left: -100%); (right: -100%); }",
        " - .container:focus { position: absolute; top: 0; (left: 0); (right: 0); }",
        "Элемент, выведенный за пределы области просмотра, доступен для средств чтения с экрана, добраться до него можно и с помощью клавиатуры. Он лишь оказывается невидимым при обычной работе со страницей."
      ],
      "isParagraph": true
    },
    {
      "heading": "6. Размеры компонента",
      "answer": ["width: 0px; height: 0px;"],
      "isParagraph": true
    },
    {
      "heading": "7. CSS-свойство clip-path",
      "answer": [
        "Если к элементу применяется CSS-свойство clip-path — оно позволяет описать область, определяющую то, какая часть элемента должна быть скрытой, а какая — видимой.",
        " -  img { clip-path: circle(0 at 50% 50%) }",
        "Элемент, к которому применено свойство clip-path, скрыт лишь визуально. До него можно добраться с помощью клавиатуры, он доступен для программ чтения с экрана."
      ],
      "isParagraph": true
    },
    {
      "heading": "8. Манипуляции с цветом текста и с размером шрифта",
      "answer": [
        "Хотя скрытие текста путём изменения его цвета или размеров шрифта распространено не так широко, как ранее рассмотренные методики скрытия элементов, в некоторых случаях это может пригодиться."
      ],
      "isParagraph": true
    },
    {
      "heading": "9. Настройка прозрачности цвета",
      "answer": [
        "Если использовать для текста прозрачный цвет, то этот текст окажется невидимым. Это может оказаться полезным при создании кнопок, на которых используются только значки."
      ],
      "isParagraph": true
    },
    {
      "heading": "10. Настройка размера шрифта",
      "answer": ["Кроме того, если установить размер шрифта в значение 0, это тоже позволит скрыть текст."],
      "isParagraph": true
    },
    {
      "heading": "Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?",
      "answer": ["Использовал сетку Bootstrap, CSS grid, флекс. Предпочитаю флекс."],
      "isParagraph": true
    },
    {
      "heading": "Что такое блочный контекст форматирования?",
      "answer": [
        "Блочный контекст форматирования — это отображение и взаимодействие компонентов веб-страницы в привычном для блоков порядке.",
        "Блочный контекст форматирования могут создать: ",
        " - блочные HTML-элементы",
        " - float-элементы, флекс-элементы, грид-элементы",
        " - позиционированные элементы",
        " - «строчные блоки» (элементы с display: inline-block)",
        " - ячейки, анонимные ячейки, заголовки таблицы "
      ],
      "isParagraph": true
    },
    {
      "heading": "Строчная модель. Строчные элементы в HTML (Языке Гипертекстовой Разметки)",
      "answer": [
        "Строчные элементы, это те, которые занимают только то пространство, которое ограничено тегами, определяющими строчный элемент (необходимое для отображения их содержимого) и не нарушая потока содержимого (не требующее новой строки после каждого элемента).",
        "Строчный элемент не начинается с новой строки, в ширину занимает столько места, сколько это необходимо для его отображения."
      ],
      "isParagraph": true
    },
    {
      "heading": "В чём разница между строчным, блочным и блочно-строчным элементом?",
      "answer": [
        "Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства display установлено как inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. Он занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство display задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов.",
        "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
        "div { display: inline-block } "
      ],
      "isParagraph": true
    },
    {
      "heading": "Строчный элемент - 'inline' ",
      "answer": [
        " - Размер зависит от контента.",
        " - Ширину и высоту задавать нельзя.",
        " - Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит - от line-height.",
        " - Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.",
        " ------------------------------------",
        "Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено.",
        "Эффект схлопывания отступов не действует. ",
        "Свойства, связанные с размерами (width, height) не применимы.",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько строчных элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.",
        "Можно выравнивать по вертикали с помощью свойства vertical-align."
      ],
      "isParagraph": true
    },
    {
      "heading": "Блочный элемент - 'block' ",
      "answer": [
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. ",
        "Такой элемент занимает всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.",
        "К блочным элементам относятся контейнеры div, h1, form и др ",
        "Блочная модель отвечает за определение того, сколько места займет блочный элемент, схлопнутся или нет border или margin, размеры блока. ",
        "Размеры блочного элемента складываются из width, height, padding, border, and margin. ",
        "Если высота (height) блока не задана, то высота блока равна: высота контента этого блока + padding'и.",
        "Если ширина блока не задана, то блоки, для которых не задано float, будут иметь ширину: ширина родителя - padding'и родителя.",
        " ------------------------------------",
        " - Начинается с новой строки родительского элемента и занимает всю строку. ",
        " - Можно задавать ширину и высоту. ",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон.",
        " ------------------------------------",
        "Блоки располагаются по вертикали друг под другом.",
        "На прилегающих сторонах элементов действует эффект схлопывания отступов. ",
        "Запрещено вставлять блочный элемент внутрь строчного. Например, <a><h1>Заголовок</h1></a> не пройдёт валидацию, правильно вложить теги наоборот — <h1><a>Заголовок</a></h1>. ",
        "По ширине блочные элементы занимают всё допустимое пространство. ",
        "Если задана ширина контента (свойство width), то ширина блока складывается из значений width, полей, границ, отступов слева и справа.",
        "Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.",
        "Если задана высота контента (свойство height), то высота блока складывается из значения height, полей, границ, отступов сверху и снизу. При превышении указанной высоты контент отображается поверх блока. ",
        "На блочные элементы не действуют свойства, предназначенные для строчных элементов, вроде vertical-align. ",
        "Текст по умолчанию выравнивается по левому краю."
      ],
      "isParagraph": true
    },
    {
      "heading": "Блочно-строчный элемент - 'inline-block' ",
      "answer": [
        " - Размер зависит от контента.",
        " - Можно задавать ширину и высоту.",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон. ",
        " ------------------------------------",
        "Внутрь строчно-блочных элементов допустимо помещать текст, строчные или блочные элементы. ",
        "Высота элемента вычисляется браузером автоматически, исходя из содержимого блока. ",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости. ",
        "Можно выравнивать по вертикали с помощью свойства vertical-align. ",
        "Разрешено задавать ширину и высоту. ",
        "Эффект схлопывания отступов не действует. ",
        " ------------------------------------",
        "Пример использования:",
        "http://htmlbook.ru/samlayout/blochnaya-verstka/strochno-blochnye-elementy"
      ],
      "isParagraph": true
    },
    {
      "heading": "Что делает * { box-sizing: border-box; }? В чём его преимущества?",
      "answer": [
        "Свойство box-sizing определяет как вычисляется общая ширина и высота элемента. По умолчанию все элементы имеют box-sizing: content-box. - `content-box`. Если мы задаём элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а финальная ширина элемента, в этом случае, увеличится на сумму отступов и толщину бордера. ",
        "Значение свойства `border-box` говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Свойство display определяет тип отображения элемента, как элемент должен быть показан в документе.",
      "answer": [
        "1. none - элемент не показывается. ",
        "2. block - блочные элементы располагаются вертикально один над другим. Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно. Это значение`display`многие элементы имеют по умолчанию:`div` , заголовок`h1,`параграф`p.` ",
        "3. Inline-элементы располагаются на одной строке, последовательно. Ширина и высота элемента определяются по содержимому. Поменять их нельзя.",
        "4. Inline-block - элемент продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока, ему можно указать ширину и высоту явно. ",
        "5. Flex - это свойство, при котором элемент растягивается или сжимается для заполнения собой свободного пространства. ",
        "6. Inline-flex - похоже на флекс, только элементы будут растягиваться или сжиматься инлайново (в строку) для заполнения собой свободного пространства. ",
        "7. Table - Для таблицы целиком`table`, для строки –`table-row`, для ячейки –`table-cell`и т.д. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Пользовались ли вы Flexbox или Grid?",
      "answer": ["Да. Использую flexbox. У grid всё ещё не такая широкая поддержка браузеров."],
      "isParagraph": true
    },
    {
      "heading": "Позиционирование элементов, типы позиционирования.",
      "answer": [
        "Позиционированием называется положение элемента в системе координат. Различают четыре типа позиционирования: нормальное, абсолютное, фиксированное и относительное. В зависимости от типа, который устанавливается через свойство position, изменяется и система координат.",
        "Благодаря комбинации свойств position, left, top, right и bottom элемент можно накладывать один на другой, выводить в точке с определёнными координатами, фиксировать в указанном месте, определить положение одного элемента относительно другого и др. Подобно другим свойствам CSS управление позиционированием доступно через скрипты. Таким образом, можно динамически изменять положение элементов без перезагрузки страницы, создавая анимацию и различные эффекты.",
        "1. Нормальное позиционирование.",
        "Если для элемента свойство position не задано или его значение static, элемент выводится в потоке документа как обычно. Иными словами, элементы отображаются на странице в том порядке, как они идут в исходном коде HTML. Свойства left, top, right, bottom если определены, игнорируются.",
        "2. Абсолютное позиционирование",
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью» ",
        "3. Фиксированное положение",
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю",
        "4. Относительное позиционирование",
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Абсолютное позиционирование",
      "answer": [
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью»",
        "Для режима характерны следующие особенности. ",
        " - Ширина слоя, если она не задана явно, равна ширине контента плюс значения полей, границ и отступов.",
        " - Слой не меняет своё исходное положение, если у него нет свойств right, left, top и bottom.",
        " - Свойства left и top имеют более высокий приоритет по сравнению с right и bottom. Если left и right противоречат друг другу, то значение right игнорируется. То же самое касается и bottom",
        " - Если left задать отрицательное значение, то слой уйдёт за левый край браузера, полосы прокрутки при этом не возникнет. Это один из способов спрятать элемент от просмотра. То же относится и к свойству top, только слой уйдёт за верхний край.",
        " - Если left задать значение больше ширины видимой области или указать right с отрицательным значением, появится горизонтальная полоса прокрутки. Подобное правило работает и с top, только речь пойдёт о вертикальной полосе прокрутки.",
        " - Одновременно указанные свойства left и right формируют ширину слоя, но только если width не указано. Стоит добавить свойство width и значение right будет проигнорировано. Аналогично произойдёт и с высотой слоя, только уже участвуют свойства top, bottom и height.",
        " - Элемент с абсолютным позиционированием перемещается вместе с документом при его прокрутке.",
        "Свойство position со значением absolute можно использовать для создания эффекта фреймов. Кроме абсолютного позиционирования для элементов необходимо назначить свойство overflow со значением auto. Тогда при превышении контентом высоты видимой области появится полоса прокрутки. Высота и ширина «фреймов» формируется автоматически путём одновременного использования свойств left, right для ширины и top, bottom для высоты ",
        " - В браузере IE6 для абсолютно позиционированных элементов нельзя одновременно задать свойства left, right и top, bottom.",
        "Абсолютное позиционирование также применяется для создания различных эффектов, например, всплывающей подсказки к фотографиям. В отличие от атрибута title тега <img> который также выводит текст подсказки, через стили можно управлять видом текста выводимого с помощью скрипта. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Фиксированное положение",
      "answer": [
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю"
      ],
      "isParagraph": true
    },
    {
      "heading": "Относительное позиционирование",
      "answer": [
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. ",
        "Свойства bottom и right производят обратный эффект. При положительном значении right сдвигает элемент влево от его правого края, при отрицательном — сдвигает вправо (рис. 3.47). При положительном значении bottom элемент поднимается вверх, при отрицательном опускается вниз.",
        "Для относительного позиционирования характерны следующие особенности ",
        " - Этот тип позиционирования не применим к элементам таблицы вроде ячеек, строк, колонок и др.",
        " - При смещении элемента относительно исходного положения, место, которое занимал элемент, остаётся пустым и не заполняется ниже или вышележащими элементами."
      ],
      "isParagraph": true
    },
    {
      "heading": "sticky - смесь relative и fixed.",
      "answer": [
        "Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент.",
        "Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow) "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вложенные слои",
      "answer": [
        "Обычно относительное позиционирование само по себе применяется не часто, поскольку есть ряд свойств выполняющих фактически ту же роль, к примеру, тот же margin. Но сочетание разных типов позиционирования для вложенных слоёв является одним из удобных и практичных приёмов вёрстки. Если для родительского элемента задать relative, а для дочернего absolute, то произойдёт смена системы координат и положение дочернего элемента при этом указывается относительно его родителя ",
        "Отсчёт координат ведётся от внутреннего края границы, значения полей не учитываются",
        "Благодаря использованию четырёх свойств left, right, top, bottom для управления положением внутреннего слоя, размеры родительского слоя знать не обязательно. Это расширяет сферу применения позиционирования, поэтому position довольно активно применяется при вёрстке различных элементов.  "
      ],
      "isParagraph": true
    },
    {
      "heading": "В чём разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?",
      "answer": [
        " - static - значение по умолчанию, позволяет элементу находиться в обычном его состоянии. Свойства top, right, bottom, left и z-index не применяются.",
        " - relative - элемент позиционируется в соответствии с потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов.",
        " - absolute - элемент выдёргивается из потока и выстраивается относительно ближайшего элемента-предка с position: relative. Если его нет, то относительно body (страницы). Абсолютно спозиционированные элементы могут иметь margin и padding и не схлопываются с margin и padding других элементов. Никак не влияют на другие элементы.",
        " - fixed - элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. С помощью top, bottom и т.д. его можно прибить соответственно сверху, снизу и т.п.. Остаётся на позиции относительно окна документа и не меняет положение при скроле.",
        " - sticky - смесь relative и fixed. Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент. Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow)"
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование CSS препроцессоров? Опишите, что вам нравится и не нравится в CSS препроцессорах, которыми вы пользовались. ",
      "answer": [" Преимущества: ", " - Вложенность. Удобно писать по БЭМу. ", " - Переменные."],
      "isParagraph": true
    },
    {
      "heading": "1. Центрирование блочного элемента ",
      "answer": [
        "Задать родителю (display: flex) ",
        "  .container { display: flex }",
        "Задать дочернему флекс-элементу (margin: auto).",
        "  .child { margin: auto }  "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. Центрирование блочного элемента",
      "answer": [
        "Задать контейнеру-родителю: .container { display: flex;  align-items: center;  justify-content: center; }"
      ],
      "isParagraph": true
    },
    {
      "heading": "3. Центрирование блочного элемента по горизонтали",
      "answer": [".child { width: 123px; margin: 12px auto }"],
      "isParagraph": true
    },
    {
      "heading": "Центрирования инлайновых элементов ",
      "answer": [
        "По горизонтали: h1 {text-align: center}",
        "По вертикали: h1 {vertical-align: middle} ",
        " ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание инлайновых элементов с помощью line-height ",
      "answer": [
        "Если известно, что внутренний блок должен занимать не более одной строки текста, то можно воспользоваться свойством line-height и задать его равным высоте внешнего блока. Поскольку контент внутреннего блока не должен переноситься на вторую строку, рекомендуется также добавить правила white-space: nowrap и overflow: hidden. ",
        " - .container { height: 200px; line-height: 200px }",
        " - .child { white-space: nowrap; overflow: hidden }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание многострочного текста",
      "answer": [
        " .container { height: 200px; line-height: 200px }",
        " .child { line-height: normal; display: inline-block; vertical-align: middle } "
      ],
      "isParagraph": true
    },
    {
      "heading": "1. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью ''растягивания'' ",
      "answer": [
        "Данный способ можно применять, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
        "Для этого нужно: ",
        " - 1. задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное;",
        " - 2. добавить внутреннему блоку правила top: 0 и bottom: 0, в результате чего он растянется на всю высоту внешнего блока;",
        " - 3. установить значение auto для вертикальных отступов внутреннего блока.",
        " .container { position: relative }",
        " .child { height: 100px; position: absolute( или fixed); top: 0; bottom: 0; margin: auto 0 }",
        "Минус данного способа — должна быть известна высота внутреннего блока. "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью отрицательного margin-top",
      "answer": [
        "Этот способ получил широкую известность и применяется очень часто. Как и предыдущий, он применяется, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
        " - 1. Нужно задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное.",
        " - 2. Затем необходимо сдвинуть внутренний блок вниз на половину высоты внешнего блока top: 50% и поднять вверх на половину собственной высоты margin-top: (H .child / 2).",
        "  .container { position: relative } ",
        "  .child { height: 100px; position: absolute; top: 50%; margin-top: -50px }"
      ],
      "isParagraph": true
    },
    {
      "heading": "3. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью transform",
      "answer": [
        "Данный способ похож на предыдущий, но он может быть применен, когда высота внутреннего блока неизвестна.",
        "Можно использовать top: 50%, left: 50% в сочетании с translateX(-50%) translateY(-50%) для динамического горизонтального/вертикального центрирования элемента: ",
        " .container { position:relative }",
        " .child { position: absolute( или fixed);  top: 50%; left: 50%; transform: translateX(-50%) translateY(-50%) }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание с помощью псевдоэлемента",
      "answer": [
        "Это наиболее универсальный способ, который может применяться, когда неизвестны высоты обоих блоков. ",
        "Суть способа в добавлении внутри внешнего блока строчного блока inline-block высотой в 100% и задания ему вертикального выравнивания. В этом случае высота добавленного блока будет равна высоте внешнего блока. Внутренний блок выровняется по вертикали относительно добавленного, а значит, и внешнего блока. ",
        "Чтобы не нарушать семантику, строчный блок рекомендуется добавить с помощью псевдоэлемента before или after. ",
        "  .container:before { display: inline-block; height: 100%; vertical-align: middle }",
        " .child { display: inline-block; vertical-align: middle }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Запретить прокрутку страницы: document.body.style.overflow = 'hidden';",
      "answer": ["document.body.style.overflow = 'hidden';"],
      "isParagraph": true
    },
    {
      "heading": "Разрешить прокрутку страницы: document.body.style.overflow = '' ;",
      "answer": ["document.body.style.overflow = '' ; "],
      "isParagraph": true
    },
    {
      "heading": "Как стилизовать или убрать полосу прокрутки — CSS скроллбар",
      "answer": [
        "Убрать полосу прокрутки у элемента: .element::-webkit-scrollbar { width: 0; }",
        "Убрать полосу прокрутки для всей страницы: ::-webkit-scrollbar { width: 0; }",
        ".element { width: 1280px; display: flex; overflow-x: scroll; ",
        "  @media screen and (min-width: 1280px) { ",
        " overflow-x: hidden; .element::-webkit-scrollbar { width: 0; }}}"
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    }
  ],
  "linksArrayMethods": [
    {
      "href": "https://habr.com/ru/company/ruvds/blog/430380/",
      "title": "Руководство по JavaScript, часть 5: массивы и циклы"
    },
    {
      "href": "https://learn.javascript.ru/array",
      "title": "Массивы"
    },
    {
      "href": "https://learn.javascript.ru/array-methods",
      "title": "Методы массивов"
    },
    {
      "href": "https://habr.com/ru/company/plarium/blog/483958/",
      "title": "15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году"
    },
    {
      "href": "https://digitrain.ru/articles/272353/",
      "title": "Мутировать или не мутировать? Шпаргалка по методам массивов JavaScript"
    },
    {
      "href": "https://itchief.ru/javascript/arrays",
      "title": "Массивы в JavaScript"
    },
    {
      "href": "https://only-to-top.ru/blog/coding/2020-12-30-js-array-cheatsheet.html",
      "title": "Методы массивов"
    },
    {
      "href": "https://habr.com/ru/post/247857/",
      "title": "Все способы перебора массива в JavaScript"
    },
    {
      "href": "https://wm-school.ru/js/index.php",
      "title": "Шикарный учебник по JavaScript на русском языке"
    },
    {
      "href": "https://www.techonthenet.com/js/array_entries.php",
      "title": "Шикарный учебник по JavaScript на русском языке"
    }
  ],
  "linksDestructuring": [
    {
      "href": "https://habr.com/ru/company/otus/blog/594541/",
      "title": "Деструктуризация массивов и объектов в JavaScript — в чем разница?"
    },
    {
      "href": "https://learn.javascript.ru/destructuring-assignment",
      "title": "Деструктурирующее присваивание"
    },
    {
      "href": "https://tproger.ru/translations/delaem-kod-chishhe-s-pomoshhju-destrukturizacii-obektov-v-javascript/",
      "title": "Делаем код чище с помощью деструктуризации объектов в JavaScript"
    }
  ],
  "arrayDestructuringArrays": [
    {
      "heading": "Деструктурирующее присваивание",
      "answer": [
        "В JavaScript есть две, чаще всего используемые, структуры данных – это Object и Array.",
        " - Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.",
        " - Массивы позволяют нам собирать элементы данных в упорядоченный список.",
        "Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности. ",
        "Деструктурирующее присваивание в JavaScript — это изящный способ извлечения значений из массивов и объектов, при котором в полной мере реализуется принцип DRY (англ. Don’t repeat yourself — «Не повторяйся») ",
        "Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны. ",
        "Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. Скоро мы увидим это."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массива",
      "answer": [
        "Деструктуризация массива (англ. array destructuring) — это особый синтаксис, позволяющий извлекать значения из массива и записывать их в новые переменные с минимумом кода.",
        "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
        "Значения элементов массива копируем в новые переменные:",
        " - const [firstName, lastName, website] = profile;",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'",
        "Это и есть деструктуризация массива. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массива напрямую",
      "answer": [
        "const [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Синтаксис деструктуризации массива при необходимости объявления переменных без инициализации",
      "answer": [
        "При использовании деструктуризации массива JavaScript позволяет отдельно объявлять переменные, а уже затем присваивать им значения.",
        " - let firstName, lastName, website;",
        " - [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации массива с использованием переменной 'оператора остатка' остальной части литерала массива ",
      "answer": [
        "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
        "Если понадобится присвоить 'Oluwatobi' переменной firstName, а остальные элементы массива — другой переменной? Как это сделать?",
        "JavaScript позволяет использовать оператор остатка внутри деструктурирующего массива для присваивания переменной значений остальных элементов обычного массива.",
        " - const [firstName, ...otherInfo] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(otherInfo); // ['Sofela', 'codesweetly.com' ]",
        "Примечание: оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего массива, иначе возникнет синтаксическая ошибка (SyntaxError)"
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для извлечения значений по любому, произвольному индексу",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "А теперь представим, что нам нужно извлечь только значение 'codesweetly.com'",
        " - const [, , website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(website); // 'codesweetly.com'",
        "В коде выше мы использовали запятые для пропуска переменных в первой и второй позициях деструктурирующего массива. ",
        "Таким образом нам удалось связать переменную website с третьим значением из обычного массива, указанного справа от оператора присваивания (то есть 'codesweetly.com') "
      ],
      "isParagraph": true
    },
    {
      "heading": "Как работают значения по умолчанию при использовании деструктурирующего присваивания массива",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "Иногда значение, которое требуется извлечь из массива, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем массиве значения по умолчанию. ",
        "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из массива, не существует (или имеет значение undefined). ",
        "В деструктурирующем массиве задаём значения по умолчанию: ",
        " - const [ firstName = 'Tobi', website = 'CodeSweetly' ] = [ 'Oluwatobi' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(website); // 'CodeSweetly'",
        "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
        "Поэтому при попытке извлечь значение с индексом 1 из массива, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в массиве [ 'Oluwatobi' ] существует значение только с нулевым индексом. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для обмена значений переменных",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "А что если нужно поменять значение переменной firstName на значение переменной website?",
        "При помощи деструктурирующего присваивания массива можно поменять местами значения двух или нескольких переменных.",
        "Рассмотрим пример: ",
        " - let firstName = 'Oluwatobi';",
        " - let website = 'CodeSweetly';",
        " - [firstName, website] = [website, firstName]; поменяли местами значения двух переменных.",
        " - console.log(firstName); // 'CodeSweetly'",
        " - console.log(website); // 'Oluwatobi'",
        "В коде выше мы использовали прямую деструктуризацию массива для повторного присваивания переменным firstName и website значений литерала массива, указанного справа от оператора присваивания. ",
        "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi' "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для извлечения значений из массива в параметры функции",
      "answer": [
        "Отметим, что деструктуризацию массива также можно использовать для извлечения значений из обычного массива в параметры функции ",
        "Ниже приводится пример использования деструктуризации массива для извлечения значения из массива в параметр функции:",
        " // Определяем массив с двумя элементами:",
        " - const profile = [ 'Oluwatobi', 'Sofela' ];",
        " // Определяем функцию с одним деструктурирующим массивом, содержащим два параметра:",
        " - function getUserBio([firstName, lastName]) {",
        " - return `My name is ${firstName} ${lastName}",
        "}",
        " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
        " - getUserBio(profile);",
        " // Приведенный выше вызов вернет:",
        " - 'My name is Oluwatobi Sofela.'",
        "В коде выше мы использовали параметр, который деструктурирует массив для извлечения значений из массива profile в параметры firstName и lastName функции getUserBio ",
        "Примечание: параметр, деструктурирующий массив, обычно называют деструктурирующим параметром. ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим еще один пример использования деструктуризации массива для извлечения значений из массива в параметры функции",
      "answer": [
        " // Определяем массив с двумя строковыми значениями и одним вложенным массивом:",
        " - const profile = [ 'codesweetly.com', 'Male', [ 'Oluwatobi', 'Sofela']];",
        " // Определяем функцию с двумя деструктурирующими массивами, каждый из которых содержит параметр:",
        " - function getUserBio([website, , [userName]]) {",
        " - return `${userName} runs ${website}` ",
        "}",
        " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
        " - getUserBio(profile);",
        " // Приведенный выше вызов вернет:",
        " 'Oluwatobi runs codesweetly.com'",
        "В коде выше мы использовали два параметра, деструктурирующих массив, для извлечения значений из массива profile в параметры website и userName функции getUserBio. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вызов функции, содержащей параметры, деструктурирующие массив, без передачи ей аргументов",
      "answer": [
        "Время от времени может понадобиться вызвать функцию, содержащую деструктурирующий параметр, не передавая ей никакого аргумента. В этом случае необходимо использовать подход, при котором браузер не выдаст ошибку TypeError. ",
        " - function getUserBio([firstName]) {",
        " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
        " - return `My name is ${firstName}.`",
        "}",
        "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
        "getUserBio(); ",
        "После вызова вышеуказанной функции getUserBio браузер выдаст ошибку TypeError: (Ошибка типа: undefined невозможно итерировать). ",
        "Сообщение TypeError возникает потому, что функции, содержащие деструктурирующий параметр, ожидают, что им будет передан хотя бы один аргумент. ",
        "Однако подобных сообщений об ошибках можно избежать, назначив деструктурирующему параметру аргумент по умолчанию. ",
        " - function getUserBio([firstName] = []) {",
        " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
        " - return `My name is ${firstName}.`",
        "}",
        "Обратите внимание, что в приведенном выше коде мы присвоили пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. ",
        "Теперь снова вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр:",
        "getUserBio(); ",
        "Результат: ",
        " 'Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования' ",
        " 'My name is undefined.'",
        "Отметим, что необязательно использовать пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. Можно использовать любое другое значение, кроме null и undefined"
      ],
      "isParagraph": true
    }
  ],
  "arrayDestructuringObjects": [
    {
      "heading": "Деструктуризация объекта",
      "answer": [
        "Деструктуризация объекта (англ. object destructuring) — это особый синтаксис, позволяющий извлекать значения из объекта и записывать их в новые переменные с минимумом кода.",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }  ",
        "Делаем деструктуризацию: ",
        " const { firstName: firstName, lastName: lastName, website: website } = profile; ",
        "Получаем: ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'",
        "-------------------------- ",
        "Мы поместили три новые переменные в объект свойств ({...}) и присвоили им значения из объекта profile. ",
        "Другими словами, мы сказали компьютеру, чтобы тот извлек значения из объекта profile и записал их в переменные, указанные слева от оператора присваивания. ",
        "В результате JavaScript парсит объект profile и копирует его первое значение ('Oluwatobi') в первую переменную деструктурирующего объекта (firstName). ",
        "Аналогичным образом компьютер извлекает второе значение ('Sofela') из объекта profile и записывает его во вторую переменную (lastName) деструктурирующего объекта. ",
        "Наконец JavaScript копирует третье значение из объекта profile (codesweetly.com') в третью переменную (website) деструктурирующего объекта. ",
        "Отметим, что в { firstName: firstName, lastName: lastName, website: website } ключи являются ссылками на свойства объекта profile, при этом значения ключей представляют собой новые переменные. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация объекта, сокращенный синтаксис.",
      "answer": [
        "Также можно использовать сокращенный синтаксис, чтобы сделать код более читабельным.",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
        "Делаем деструктуризацию:",
        " const { firstName, lastName, website } = profile;",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта. Случай, когда имя свойства отличается от имени переменной ",
      "answer": [
        "Обратите внимание, что в приведенном выше коде было показано, как присвоить значение из объекта переменной в случае, когда свойство объекта и переменная имеют одинаковые имена.",
        "Однако можно присвоить значение свойства и переменной с другим именем. Давайте посмотрим как. ",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
        "Делаем деструктуризацию:",
        " const { firstName: forename, lastName: surname, website: onlineSite } = profile; ",
        " - console.log(forename); // 'Oluwatobi'",
        " - console.log(surname); // 'Sofela'",
        " - console.log(onlineSite); // 'codesweetly.com'",
        " - console.log(website); // 'ReferenceError: website не определен'",
        "В приведенном выше коде компьютер успешно извлек значения из объекта profile и определил их в переменные с именами forename, surname и onlineSite, несмотря на то что свойства и переменные имеют разные имена. ",
        "-------------------------- ",
        "const profile = { lastName: { familyName: 'Sofela' } }; ",
        "const { lastName: { familyName: surname } } = profile; ",
        "console.log(surname); // 'Sofela' ",
        "В приведенном выше коде компьютер успешно извлек значения из объекта profile в переменную с именем surname, несмотря на то что свойство и переменная имеют разные имена. ",
        "-------------------------- ",
        "Примечание: const { lastName: { familyName: surname } } = profile — это эквивалент const surname = profile.lastName.familyName "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация объекта напрямую",
      "answer": [
        "Обратите внимание, что мы деструктурировали объект profile путем ссылки на него. Однако деструктуризацию объекта можно делать и напрямую. ",
        "Прямая деструктуризация объекта:",
        "-------------------------- ",
        "const { firstName, lastName, website } = {",
        " firstName: 'Oluwatobi',",
        " lastName: 'Sofela',",
        " website: 'codesweetly.com' }",
        "-------------------------- ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта, объявление переменных без инициализации",
      "answer": [
        "Предположим, необходимо объявлять переменные в одном месте, а присваивать им значения — в другом. При использовании деструктуризации объекта JavaScript позволяет отделять объявление переменных от присваивания им значений.",
        "// Объявляем три переменные: ",
        " - let firstName, lastName, website;",
        "// Извлекаем значения для трех переменных выше: ",
        "({ firstName, lastName, website } = {",
        " - firstName: 'Oluwatobi',",
        " - lastName: 'Sofela',",
        " - website: 'codesweetly.com'",
        " });",
        "-------------------------- ",
        "Примечание: ",
        "1. Деструктурирующее присваивание объекта нужно обязательно заключать в круглые скобки, чтобы компьютер понимал, что деструктуризация объекта — это литерал объекта, а не блок",
        "2. После круглых скобок деструктурирующего присваивания объекта необходимо ставить точку с запятой (;). Тогда компьютер не будет интерпретировать круглые скобки как вызов функции, которая могла находиться на предыдущей строке."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта с использованием переменной 'оператора остатка' остальной части объекта",
      "answer": [
        "А что если понадобится присвоить значение 'Oluwatobi' переменной firstName, а остальные значения из объекта — другой переменной? ",
        "JavaScript позволяет использовать оператор остатка внутри деструктурирующего объекта для присваивания переменной значений из остальной части литерала объекта.",
        "-------------------------- ",
        "const { firstName, ...otherInfo } = {",
        " - firstName: 'Oluwatobi',",
        " - lastName: 'Sofela',",
        " - website: 'codesweetly.com'",
        " }; ",
        " console.log(firstName); // 'Oluwatobi'",
        " console.log(otherInfo); // {lastName: 'Sofela', website: 'codesweetly.com'}",
        "-------------------------- ",
        "Примечание: ",
        " оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего объекта, иначе возникнет синтаксическая ошибка (SyntaxError). "
      ],
      "isParagraph": true
    },
    {
      "heading": "Как работают значения по умолчанию при использовании деструктурирующего присваивания объекта",
      "answer": [
        "Однако иногда значение, которое требуется извлечь из объекта со свойствами, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем объекте значения по умолчанию. Рассмотрим этот случай подробнее",
        "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из объекта, не существует (или имеет значение undefined). ",
        "Ниже показано, как в деструктурирующем объекте со свойствами задаются значения по умолчанию: ",
        "-------------------------- ",
        "const { firstName = 'Tobi', website = 'CodeSweetly' } = { ",
        " firstName: 'Oluwatobi' ",
        "}; ",
        "console.log(firstName); // 'Oluwatobi' ",
        "console.log(website); // 'CodeSweetly' ",
        "-------------------------- ",
        "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
        "Поэтому при попытке извлечь значение второго свойства объекта, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в {firstName: 'Oluwatobi'} присутствует только одно свойство. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации объекта для обмена значений переменных",
      "answer": [
        "А что если нужно поменять значение переменной firstName на значение переменной website?",
        "При помощи деструктурирующего присваивания объекта можно поменять местами значения двух или нескольких переменны ",
        "-------------------------- ",
        "let firstName = 'Oluwatobi'; ",
        "let website = 'CodeSweetly'; ",
        "({ firstName, website } = {firstName: website, website: firstName}); ",
        "console.log(firstName); // 'CodeSweetly' ",
        "console.log(website); // 'Oluwatobi' ",
        "-------------------------- ",
        "В коде выше мы использовали прямую деструктуризацию объекта для повторного присваивания переменным firstName и website значений литерала объекта, указанного справа от оператора присваивания. ",
        "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi'. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации объекта для извлечения значений из свойств в параметры функции",
      "answer": [
        "Отметим, что деструктуризацию объекта также можно использовать для извлечения значений из свойств в параметры функции.",
        "Ниже приводится пример использования деструктуризации объекта для копирования значения свойства в параметр функции: ",
        "// Определяем объект с двумя свойствами: ",
        "const profile = {",
        " - firstName: 'Oluwatobi', ",
        " - lastName: 'Sofela',",
        "};",
        "// Определяем функцию с одним объектом деструктурирования, содержащим два параметра: ",
        "function getUserBio({ firstName, lastName }) {",
        " - return `My name is ${firstName} ${lastName}.`; ",
        "} ",
        "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
        "getUserBio(profile); ",
        "// Приведенный выше вызов вернет: ",
        "'My name is Oluwatobi Sofela.' ",
        "В коде выше мы использовали параметр, который деструктурирует объект для копирования значений из объекта profile в параметры firstName и lastName функции getUserBio. ",
        "Примечание: параметр, деструктурирующий объект, обычно называют деструктурирующим параметром."
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим еще один пример: ",
      "answer": [
        "// Определяем объект с тремя родительскими свойствами: ",
        "const profile = { website: 'codesweetly.com', gender: 'Male', fullName: { firstName: 'Oluwatobi', lastName: 'Sofela' }}; ",
        "// Определяем функцию с двумя деструктурирующими объектами, каждый из которых содержит параметр: ",
        "function getUserBio({ website, fullName: { firstName: userName } }) { ",
        "return `${userName} runs ${website}`;",
        "} ",
        "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
        "getUserBio(profile); ",
        "// Приведенный выше вызов вернет: ",
        " 'Oluwatobi runs codesweetly.com'",
        "В коде выше мы использовали два деструктурирующих параметра для копирования значений из объекта profile в параметры website и userName функции getUserBio "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вызов функции, содержащей деструктурированные параметры, без передачи ей аргументов",
      "answer": [
        "function getUserBio({ firstName } = {}) { ",
        " console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования'); ",
        " return `My name is ${firstName}.`;",
        "}",
        "Обратите внимание, что в приведенном выше коде мы присвоили пустой объект в качестве аргумента по умолчанию для деструктурирующего параметра. ",
        "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
        "getUserBio(); ",
        "'Do something else that does not need the destructuring parameter.'",
        "My name is undefined."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массивов и объектов. Резюме",
      "answer": [
        "Деструктуризация массивов и объектов выполняется схожим образом. Основное различие между двумя деструктурирующими присваиваниями заключается, собственно, в том, что при деструктуризации массива значения извлекаются из массива, а при деструктуризации объекта — из объекта JavaScript. "
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " "],
      "isParagraph": true
    }
  ],
  "linksDOM": [
    {
      "href": "https://learn.javascript.ru/modifying-document#metody-vstavki",
      "title": "Методы вставки и удаления node"
    },
    {
      "href": "https://tokmakov.msk.ru/blog/item/620",
      "title": "DOM, часть 1 из 3. Навигация по элементам"
    },
    {
      "href": "https://tokmakov.msk.ru/blog/item/696",
      "title": "DOM, часть 2 из 3. Изменение документа"
    },
    {
      "href": "https://tokmakov.msk.ru/blog/item/697",
      "title": "DOM, часть 3 из 3. Поиск элементов"
    },
    {
      "href": "https://tokmakov.msk.ru/blog/item/698",
      "title": "DOM, часть 4 из 4. Атрибуты и свойства"
    },
    {
      "href": " ",
      "title": " "
    }
  ],
  "arrayDOM": [
    {
      "heading": "Что такое DOM?",
      "answer": [
        "DOM (Document Object Model, объектная модель документа) — это программный интерфейс к HTML-документам. Этот интерфейс позволяет воздействовать на документ из скриптов, меняя его оформление, стили, содержимое. В DOM документ представлен в виде дерева узлов.",
        "Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице. ",
        " - заменим цвет фона на красный, document.body.style.background = ''red''",
        " - а через секунду вернём как было  setTimeout(() => document.body.style.background = '' '', 1000);"
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Основой HTML-документа являются теги.",
      "answer": [
        "В соответствии с DOM, каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.",
        "Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: html – это корневой узел, head и body его дочерние узлы и т.д.",
        "Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.",
        " "
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Автоисправление",
      "answer": [
        "Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.",
        "Например, в начале документа всегда должен быть тег html. Даже если его нет в документе – он будет в дереве DOM, браузер его создаст. То же самое касается и тега body.",
        "Например, если HTML-файл состоит из единственного слова ''Привет'', браузер обернёт его в теги html и body, добавит необходимый тег head. ",
        "При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее. "
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Навигация по DOM-элементам",
      "answer": [
        "Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.",
        "Самые верхние элементы дерева доступны как свойства объекта document. Самый верхний узел документа (html):",
        " - document.documentElement. Далее:",
        " - document.body.",
        " - document.head.",
        "Дочерние узлы (или дети) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, head и body являются детьми элемента html. ",
        "Потомки – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.",
        "Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.",
        "Есть два основных набора ссылок: ",
        " 1. Для всех узлов: ",
        " - parentNode,",
        " - childNodes,",
        " - firstChild,",
        " - lastChild,",
        " - previousSibling,",
        " - nextSibling.",
        " - elem.childNodes",
        " 2. Только для узлов-элементов:",
        " - parentElement,",
        " - children,",
        " - firstElementChild,",
        " - lastElementChild,",
        " - previousElementSibling,",
        " - nextElementSibling.",
        " - elem.children ",
        " Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM по id: document.getElementById ",
      "answer": [
        "Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился.",
        " - получить элемент: let elem = document.getElementById('elem'); ",
        " - сделать его фон красным: elem.style.background = 'red'; ",
        "Значение id должно быть уникальным. В документе может быть только один элемент с данным id. "
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск в DOM всех элементов по CSS-селектору: document.querySelectorAll(css)",
      "answer": [
        "Метод возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.",
        " let elements = document.querySelectorAll('ul > li:last-child'); ",
        " Псевдоклассы тоже работают. Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например, document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши. "
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод elem.querySelector(css)",
      "answer": [
        "Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору.",
        "Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все элементы, а потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. Это быстрее, кроме того, его короче писать."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод closest(css) ",
      "answer": [
        "closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.",
        "Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден. ",
        " let chapter = document.querySelector('.chapter');  ",
        " alert(chapter.closest('.book'));"
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод elem.getElementsByTagName(tag)",
      "answer": [
        "elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав ''*'' вместо тега, можно получить всех потомков.",
        " - получить все элементы div в документе: let divs = document.getElementsByTagName('div');"
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод elem.getElementsByClassName(className)",
      "answer": ["Метод elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс."],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод document.getElementsByName(name)",
      "answer": [
        "Метод document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Поиск элементов в DOM. Метод elemA.contains(elemB)",
      "answer": [
        "Метод elemA.contains(elemB) метод, который проверяет наличие отношений между предком и потомком. Вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Не забываем про букву ''s''! в document.getElementsBy",
      "answer": [" ", " ", " ", " ", " ", " ", " "],
      "isParagraphBefore": true
    },
    {
      "heading": "HTML-атрибуты",
      "answer": [
        "В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.",
        "Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный. ",
        " - elem.hasAttribute(name) – проверяет наличие атрибута.",
        " - elem.getAttribute(name) – получает значение атрибута.",
        " - elem.setAttribute(name, value) – устанавливает значение атрибута.",
        " - elem.removeAttribute(name) – удаляет атрибут.",
        " - elem.attributes – это коллекция всех атрибутов."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Создание элемента",
      "answer": [
        " DOM-узел можно создать двумя методами:",
        "1. document.createElement(tag), cоздаёт новый элемент с заданным тегом: let div = document.createElement('div');",
        "2. document.createTextNode(text), cоздаёт новый текстовый узел с заданным текстом: let textNode = document.createTextNode('А вот и я');"
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Методы вставки и удаления node",
      "answer": [
        "Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body.",
        "Для этого есть метод append, в нашем случае: document.body.append(div).",
        " let div = document.createElement('div');",
        " div.className = ''alert''",
        " div.innerHTML = ''Всем привет! Вы прочитали важное сообщение.'' ",
        " document.body.append(div);",
        "Вот методы для различных вариантов вставки:",
        " node.append(...nodes or strings) – добавляет узлы или строки в конец node,",
        " node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,",
        " node.before(...nodes or strings) –- вставляет узлы или строки до node,",
        " node.after(...nodes or strings) –- вставляет узлы или строки после node,",
        " node.replaceWith(...nodes or strings) -- заменяет node заданными узлами или строками.",
        " -- node.remove() – удаляет node."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "className, classList, Element style",
      "answer": [
        " elem.className заменяет всю строку с классами.",
        " elem.classList – это специальный объект с методами для добавления/удаления одного класса.",
        " Методы classList:elem.classList.add(''class'') – добавить класс.",
        " elem.classList.remove(''class'') – удалить класс.",
        " elem.classList.toggle(''class'') – добавить класс, если его нет, иначе удалить (переключатель)",
        " elem.classList.contains(''class'') – проверка наличия класса, возвращает true/false. ",
        " Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of",
        " for (let name of document.body.classList) { alert(name); // main, затем page }",
        " Свойство elem.style – это объект, который соответствует тому, что написано в атрибуте ''style''",
        " Установка стиля elem.style.width=''100px''  работает так же, как наличие в атрибуте style строки width:100px."
      ],
      "isParagraphBefore": true
    },
    {
      "heading": "Сброс стилей",
      "answer": [
        "Иногда нам нужно добавить свойство стиля, а потом, позже, убрать его.",
        "Например, чтобы скрыть элемент, мы можем задать elem.style.display = ''none''",
        "Затем мы можем удалить свойство style.display, чтобы вернуться к первоначальному состоянию. Вместо delete elem.style.display мы должны присвоить ему пустую строку: elem.style.display = '''' "
      ],
      "isParagraphBefore": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " "],
      "isParagraphBefore": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " "],
      "isParagraphBefore": true
    }
  ],
  "linksErrorProcessing": [
    {
      "href": "https://habr.com/ru/company/ruvds/blog/431078/",
      "title": "Рекомендованно к изучению: 'Руководство по обработке ошибок в JavaScript в Хабре'"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch",
      "title": "Конструкция try...catch"
    },
    {
      "href": "https://itchief.ru/javascript/try-catch",
      "title": "Обработка ошибок, try...catch в JavaScript"
    }
  ],
  "arrayErrorProcessing": [
    {
      "heading": "Непойманные ошибки",
      "answer": [
        "Когда возникает ошибка, выполнение кода прекращается, и эта ошибка выводится в консоль.",
        "В консоль будет выведена непойманная ошибка (uncaught error). Она так называется, потому что мы её не поймали (не обработали). Дальше код выполняться не будет и сообщение, которые мы выводим с помощью console.log() не отобразится."
      ],
      "isParagraph": true
    },
    {
      "heading": "Конструкция try ... catch (try...catch).",
      "answer": [
        "Обработка ошибок в JavaScript осуществляется с помощью try...catch.",
        "try...catch – это специальный синтаксис, состоящий из двух основных блоков: try, и затем catch:",
        " --------------------------",
        "try { ",
        " - // блок кода, в котором имеется вероятность возникновения ошибки",
        "} catch(error) { ",
        " // этот блок выполняется только в случае возникновения ошибки в блоке try ",
        "}",
        " --------------------------",
        "Первый блок идёт сразу после ключевого слова try. В этот блок мы помещаем часть кода, в котором есть вероятность возникновения ошибки. ",
        "Второй блок располагается за ключевым словом catch. В него помещаем код, который будет выполнен только в том случае, если в первом блоке возникнет ошибка. В круглых скобках после catch указываем параметр error. В этот параметр будет помещена ошибка, которая возникла в блоке try."
      ],
      "isParagraph": true
    },
    {
      "heading": "Пример try...catch, пойманная ошибка.",
      "answer": [
        "const text = '{ name: ''Александр'' }'; ",
        "try { ",
        " -  const person = JSON.parse( text );",
        "} catch( error ) { ",
        " - console.error( error );",
        " - console.log( error.message );",
        " }",
        "console.log( 'Это сообщение мы увидим!' ); ",
        " --------------------------",
        "Здесь в блоке try произойдет ошибка, так как в данном примере мы специально присвоили переменной text некорректную строку JSON: name без кавычек.",
        "В catch эта ошибка будет присвоена параметру error, и в нём мы будем просто выводить эту ошибку в консоль с помощью console.error(). Таким образом она будет выведена также красным цветом, но без слова Uncaught, т.к. эта ошибка была поймана."
      ],
      "isParagraph": true
    },
    {
      "heading": "Ошибка (error) – это объект и у него имеются следующие свойства:",
      "answer": [
        "1. message – описание ошибки. Именно сюда попадает та строка, которую можно передать конструктору ошибки в качестве аргумента.;",
        "Например, ниже показано создание экземпляра объекта Error и вывод в консоль переданной конструктором строки через обращение к его свойству message: ",
        "const error = new Error('пожалуйста, улучшите свой код')",
        "console.log(error.message) // пожалуйста, улучшите свой код",
        "2. name – тип ошибки, например: RangeError, ReferenceError, SyntaxError, TypeError, URIError или другой.",
        "3. stack – представляет собой трассировку стека ошибки, которая используется в целях отладки. Stack позволяет узнать о том, что происходило в скрипте на момент возникновения ошибки. Обратившись к нему можно просмотреть стек вызовов (историю ошибки), который показывает последовательность операций, приведшую к неправильной работе программы. В частности, это позволяет понять — в каком именно файле содержится сбойный код, и увидеть, какая последовательность вызовов функций привела к ошибке.",
        "В верхней части стека находится сообщение об ошибке, затем следует указание на тот участок кода, выполнение которого вызвало ошибку, потом описывается то место, откуда был вызван этот сбойный участок. Это продолжается до самого «дальнего» по отношению к ошибке фрагмента кода."
      ],
      "isParagraph": true
    },
    {
      "heading": "Инструкция throw. Генерирование ошибок.",
      "answer": [
        "Создание экземпляра объекта Error, то есть, выполнение команды вида new Error(), ни к каким особым последствиям не приводит. Интересные вещи начинают происходить после применения оператора throw (бросать), который генерирует ошибку. Как уже было сказано, если такую ошибку не обработать, выполнение скрипта остановится. При этом нет никакой разницы — был ли оператор throw использован самим программистом, произошла ли ошибка в некоей библиотеке или в среде выполнения языка (в браузере или в Node.js) ",
        "В JavaScript имеется инструкция throw, которая позволяет генерировать ошибку.",
        "// Синтаксис инструкции throw: ",
        " - throw expression; (expression - выражение)",
        "Как правило, в качестве выражения обычно используют встроенный основной класс для ошибок Error или более конкретный, например: RangeError, ReferenceError, SyntaxError, TypeError, URIError или другой. ",
        " // Создаём новый объект Error и выбрасываем его в случае ошибки: ",
        "throw new Error('Какое-то описание ошибки'); ",
        " // Пример генерирования синтаксической ошибки:",
        "throw new SyntaxError('Описание ошибки'); ",
        "// В качестве выражения можно использовать не только объект ошибки, но и строки, числа, логические значения и другие величины.",
        "Например throw 'Значение не является числом', но делать это не рекомендуется. ",
        "При обнаружении оператора throw выполнение кода прекращается, и ошибка выбрасывается в консоль."
      ],
      "isParagraph": true
    },
    {
      "heading": "Генерирование ошибок, обработка ошибок при помощи конструкции try...catch.",
      "answer": [
        "При обнаружении оператора throw выполнение кода прекращается, и ошибка выбрасывается в консоль.",
        "Например, создадим функцию, которая будет просто выбрасывать новую ошибку: ",
        "// создаём стрелочную функцию и присваиваем её переменной myFn ",
        "const myFn = () => { ",
        " - throw new Error('Описание ошибки');",
        "} ",
        "// вызываем функцию ",
        "myFn(); ",
        "console.log('Это сообщение мы не увидим в консоли!'); ",
        "Код остановится, console.log() не сработает и Это сообщение мы не увидим в консоли!",
        " --------------------------",

        "Обработаем ошибки!!! Обернём вызов функции в конструкцию try...catch: ",
        "try { ",
        " - myFn();",
        "} catch(error) { ",
        " - console.error(error);",
        "} ",
        "console.log('Это сообщение мы увидим в консоли!'); ",
        "Код не остановится, продолжит работу, так как мы применили конструкцию try...catch. ",
        " console.log() сработает и Это сообщение мы увидим в консоли.",
        " --------------------------"
      ],
      "isParagraph": true
    },
    {
      "heading": "Запись catch без указания круглых скобок и параметра внутри них",
      "answer": ["Эта возможность была добавлена в язык, начиная с версии ECMAScript 2019."],
      "isParagraph": true
    },
    {
      "heading": "Блок finally",
      "answer": [
        "Иногда случается так, что некий код нужно выполнить независимо от того, произошла ошибка или нет. Для этого можно, в конструкции try...catch, использовать третий, необязательный, блок — finally. Часто его использование эквивалентно некоему коду, который идёт сразу после try...catch, но в некоторых ситуациях он может пригодиться. Вот пример его использования.",
        "const a = 5 ",
        "try { ",
        " -- console.log(b) // переменная b не объявлена - возникает ошибка",
        "} catch (err) { ",
        " -- console.error(err) // в консоль попадает сообщение об ошибке и стек ошибки",
        "} finally { ",
        " -- console.log(a) // этот код будет выполнен в любом случае",
        "} "
      ],
      "isParagraph": true
    },
    {
      "heading": "Описание try...catch",
      "answer": [
        "Конструкция try содержит блок try, в котором находится одна или несколько инструкций (Блок ({} ) обязательно должен присутствовать, даже если выполняется всего одна инструкция), и хотя бы один блок catch или finally. Таким образом, есть три основные формы конструкции try: ",
        "1. try {...} catch {...} ",
        "2. try {...} finally {...} ",
        "3. try {...} catch {...} finally {...} ",
        "Блок catch содержит инструкции, которые будут выполнены, если в блоке try произошла ошибка. Если любая инструкция в блоке try выбрасывает исключение (ошибку), то управление сразу же переходит в блок catch. Если в блок try не было выброшено исключение (ошибки), то блок catch не выполняется ",
        "Блок finally выполняется всегда, независимо от того возникли ошибки в try или нет. Он выполняется после try, если ошибок не было, и после catch, если ошибки были. Секция finally не имеет параметров. "
      ],
      "isParagraph": true
    },
    {
      "heading": "В асинхронных механизмах — не рекомендуется использовать коллбэки.",
      "answer": [
        "Программируя на JavaScript всегда стоит обращать внимание на участки кода, выполняющиеся асинхронно. Если у вас имеется асинхронная функция и в ней возникает ошибка, скрипт продолжит выполняться. ",
        "В асинхронных механизмах — не рекомендуется использовать коллбэки."
      ],
      "isParagraph": true
    },
    {
      "heading": "Асинхронные механизмы — промисы. Рекомендуется всегда использовать блок catch.",
      "answer": [
        "Для выполнения асинхронных операций в JavaScript лучше использовать не коллбэки а промисы. Тут, в дополнение к улучшенной читабельности кода, имеются и более совершенные механизмы обработки ошибок. А именно, возиться с объектом ошибки, который может попасть в функцию обратного вызова, при использовании промисов не нужно. Здесь для этой цели предусмотрен специальный блок catch. Он перехватывает все ошибки, произошедшие в промисах, которые находятся до него, или все ошибки, которые произошли в коде после предыдущего блока catch. Обратите внимание на то, что если в промисе произошла ошибка, для обработки которой нет блока catch, это не остановит выполнение скрипта, но сообщение об ошибке будет не особенно удобочитаемым. ",
        "В результате можно порекомендовать всегда, при работе с промисами, использовать блок catch."
      ],
      "isParagraph": true
    },
    {
      "heading": "Асинхронные механизмы и try...catch",
      "answer": [
        "После того, как в JavaScript появилась конструкция async/await, мы вернулись к классическому способу обработки ошибок — к try...catch...finally. Обрабатывать ошибки при таком подходе оказывается очень легко и удобно. Рассмотрим пример ",
        " const fetchTodos = async function() { ",
        " try { const response = await fetch(''https://jsonplaceholder.typicode.com/todos?_limit=20'');",
        " // console.log(response)",
        " //",
        " if (!response.ok) {",
        " // Если у меня будет ошибка, то я её поймаю",
        " throw new Error(''Ошибка на сервере.'')",
        "  }",
        " //",
        " // Если ошибки нет,то....",
        " const date = await response.json()",
        " return date",
        " } catch (error: any) {",
        " return (error.message)",
        " }",
        " })",
        "При таком подходе ошибки в асинхронном коде обрабатываются так же, как в синхронном. В результате теперь, при необходимости, в одном блоке catch можно обрабатывать более широкий диапазон ошибок. "
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " ", " ", " "],
      "isParagraph": true
    }
  ],
  "linksFireBase": [
    {
      "href": "https://firebase.google.com/",
      "title": "FireBase"
    },
    {
      "href": "https://firebase.google.com/docs?authuser=0&hl=ru",
      "title": "Основы Firebase"
    },
    {
      "href": "https://firebaseopensource.com/projects/csfrequency/react-firebase-hooks/",
      "title": "React Firebase Hooks"
    },
    {
      "href": "https://www.npmjs.com/package/react-firebase-hooks/v/5.1.1",
      "title": "npm install --save react-firebase-hooks  npm i react-firebase-hooks"
    },
    {
      "href": "https://www.npmjs.com/package/react-firebase-hooks/v/1.0.0?activeTab=versions",
      "title": "npm i react-firebase-hooks@1.0.0"
    },
    {
      "href": "https://console.firebase.google.com/project/chat-react-6c14c/settings/general/web:NDExN2E4YzEtMmQ1Mi00OTI4LTk2MTgtNmNjYzY0NGZkMmM1",
      "title": "Настройки проекта"
    },
    {
      "href": "https://github.com/joeythelantern/React-Firebase-9",
      "title": "React-Firebase-9"
    },
    {
      "href": "https://firebase.google.com/docs/auth/web/start?hl=ru",
      "title": "Начните с аутентификации Firebase на веб-сайтах"
    },
    {
      "href": "https://github.com/CSFrequency/react-firebase-hooks/blob/master/auth/README.md",
      "title": "React Firebase Hooks - Auth"
    },
    {
      "href": "https://github.com/CSFrequency/react-firebase-hooks/blob/master/auth/useAuthState.ts",
      "title": "react-firebase-hooks/auth/useAuthState.ts"
    },
    {
      "href": "https://github.com/CSFrequency/react-firebase-hooks",
      "title": "CSFrequency/react-firebase-hooksPublic"
    },
    {
      "href": "https://stackoverflow.com/questions/68946446/how-do-i-fix-a-firebase-9-0-import-error-attempted-import-error-firebase-app",
      "title": "Как исправить ошибку импорта Firebase 9.0?"
    },

    {
      "href": "https://github.com/firebase/firebaseui-web-react",
      "title": "firebase/firebaseui-web-react"
    },
    {
      "href": "",
      "title": ""
    }
  ],
  "linksGitHub": [
    {
      "href": "https://github.com/igorbelikov2009?tab=repositories",
      "title": "Мой репозиторий на гитхабе."
    },
    {
      "href": "https://htmlacademy.ru/blog/html_old",
      "title": "Бесплатный учебник по Git и GitHub"
    },
    {
      "href": "https://www.youtube.com/watch?v=9e5OSBCCvvU",
      "title": "Основы командной разработки git в Visual Studio Code"
    },
    {
      "href": "https://github.com/Shkulipa/online-store",
      "title": "Shkulipa/online-storePublic. Онлайн-магазин, который я делал"
    },
    {
      "href": "https://github.com/utimur/online-store-full-course",
      "title": "utimur/online-store-full-coursePublic. Онлайн-магазин, который я делал"
    },
    {
      "href": " ",
      "title": " "
    }
  ],
  "linksHTTP": [
    {
      "href": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers",
      "title": "Заголовки HTTP"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods",
      "title": "Методы запроса"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP",
      "title": "Безопасный метод HTTP"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Glossary/Idempotent",
      "title": "Идемпотентный метод HTTP"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Glossary/cacheable",
      "title": "Кэшируемый ответ HTTP"
    }
  ],
  "arrayHTTP": [
    {
      "heading": "Как работает WWW (всемирная паутина, веб) в двух словах.",
      "answer": [
        "Браузер пользователя (клиент) отправляет на сервер запрос с адресом сайта (URL), сервер получает этот запрос и отдаёт клиенту требуемый тому контент. Иными словами, весь современный веб построен на модели клиент-серверного взаимодействия. И чтобы весь этот процесс оказался возможным, необходим универсальный язык-протокол, который будет понимать и сервер, и браузер. Такой протокол есть, а называется он HTTP."
      ],
      "isParagraph": true
    },
    {
      "heading": "Что в вебе называют ресурсами.",
      "answer": [
        "Ресурсы — это любые данные: текст, изображение, видео, аудио, целая программа. Например, HTML веб-страницы, на которой вы сейчас находитесь, — тоже ресурс."
      ],
      "isParagraph": true
    },
    {
      "heading": "Клиент",
      "answer": [
        "Клиент — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API. Когда ваш браузер запрашивает у сервера Skillbox эту веб-страницу, он выступает в роли клиента. ",
        "Клиентом может быть любое устройство, через которое пользователь запрашивает данные. Часто в роли клиента выступает веб-браузер, программы для отладки приложений или даже командная строка. Главная особенность клиента — он всегда инициирует запрос. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Сервер",
      "answer": [
        "Сервер — программа, в которой хранятся и обрабатываются ресурсы. Сервер может располагаться на одном или нескольких компьютерах; но даже в одном компьютере может быть несколько виртуальных серверов. Допустим, изначально HTML-код этой статьи хранился где-то на серверах Skillbox. ",
        "Сервер — это устройство, которое обрабатывает запросы клиента. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Прокси-серверы",
      "answer": [
        "Прокси-серверы — это второстепенные серверы, которые располагаются между клиентом и главным сервером. Они обрабатывают HTTP-запросы, а также ответы на них. Чаще всего прокси-серверы используют для кэширования и сжатия данных, обхода ограничений и анонимных запросов. И ещё — обычно между клиентом и основным сервером находится один или несколько таких прокси-серверов. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое HTTP? (HyperText Transfer Protocol)  - протокол передачи гипертекста.",
      "answer": [
        "HTTP означает «протокол передачи гипертекста» (или HyperText Transfer Protocol). Он представляет собой список правил, по которым компьютеры обмениваются данными в интернете. HTTP умеет передавать все возможные форматы файлов — например, видео, аудио, текст. Но при этом состоит только из текста. Его инициирует клиент (в данном случае — человек, заходящий в интернет с любого устройства), а обрабатывает сервер и возвращает обратно клиенту. Между ними могут находиться прокси-серверы, которые занимаются дополнительными задачами — шифрованием данных, перераспределением нагрузки или кэшированием.",
        "HTTP — универсальный язык-протокол, который понимает и сервер и браузер. HTTP позволяет обмениваться данными в Интернете, например HTML-документами. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). ",
        "--",
        "Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса, а затем ждет ответа. HTTP - это протокол без сохранения состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами 'запрос-ответ'. Несмотря на то, что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной доставкой. ",
        "Ниже перечислены общие функции, управляемые с HTTP: ",
        "1. Кэш. Сервер может инструктировать прокси и клиенты: что и как долго кэшировать. Клиент может инструктировать прокси промежуточных кэшей игнорировать хранимые документы.",
        "2. Ослабление ограничений источника. Для предотвращения шпионских и других, нарушающих приватность, вторжений, веб-браузер обчеспечивает строгое разделеление между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).",
        "3. Аутентификация. Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate и подобных ему, либо с помощью настройки спецсессии, используя куки.",
        "4. Прокси и тунелирование. Серверы и/или клиенты часто располагаются в интернете и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси -- HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.",
        "5. Сессии. Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создает сессию, хотя ядро HTTP -- протокол без состояния. Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP и клиент серверная архитектура.",
      "answer": [
        "В клиент-серверной архитектуре клиентом может быть всё, что угодно, что имеет доступ в сеть и может отсылать сформированные HTTP- запросы, либо XML- запросы на сервер и получать от него ответы: браузер (сайт, например, фейсбук, инстаграмм), мобильное приложение, умная бытовая техника, имеющая доступ к сети, серверное приложение, настольное приложение (например, клиент компьютерной игры).",
        "Вся информация хранится на сервере, и читается - меняется клиентом по запросу. Клиентское приложение формирует запросы и отправляет на сервер. После чего програмное обеспечение сервера формирует ответ и отправляет его клиенту. После этого клиентское приложение может отправлять другие запросы, которые будут обработаны аналогичным образом."
      ],
      "isParagraph": true
    },
    {
      "heading": "Для чего нужен HTTP.",
      "answer": [
        "HTTP (HyperText Transfer Protocol) - протокол передачи гипертекста. Он разработан для передачи HTML- документов, для связи между браузерами и серверами, но может использоваться и для других целей. HTTP следует модели клиент-сервер, когда клиент делает запрос на сервер и ждёт от него ответа. HTTP — это протокол без сохранения состояния, что означает, что сервер не сохраняет никаких данных (состояния) между двумя запросами. Есть версии HTTP/1.1 и HTTP/2.",
        "Данные передаются в открытом виде. HTTP сам по себе не предоставляет никаких средств шифрования."
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое HTTPs? (HyperText Transfer Protocol, secure) является расширением HTTP-протокола.",
      "answer": [
        "Фактически, это тот же самый протокол HTTP, только с дополнительным уровнем шифрования. HTTPS расшифровывается как «защита протокола передачи гипертекста». Таким образом, HTTP — самостоятельный протокол, а HTTPS — расширение для его защиты. По HTTP информация передается незащищенной, а HTTPS обеспечивает криптографическую защиту. Особенно актуально это для ресурсов с ответственной авторизацией. Это могут быть социальные сети или сайты платежных систем.",
        "Данные передаются в едином зашифрованном потоке, что делает невозможным получение учетных данных пользователей и прочей критической информации средствами обычного перехвата. ",
        "Таким образом, HTTP применяется для передачи данных, а HTTPS позволяет осуществлять защищенную передачу данных с помощью шифрования и выполнять авторизацию на ресурсах с высоким уровнем безопасности."
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP - сообщения.",
      "answer": [
        "HTTP - сообщения подразделяются на 2 типа: HTTP - запросы, которые отправляет клиент, например браузер на сервер. HTTP - ответы, сообщения, которые отправляет сервер.",
        "Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек. ",
        "У каждого HTTP - сообщения есть: строка состояния, заголовки и, по возможности, тело."
      ],
      "isParagraph": true
    },
    {
      "heading": "Структура HTTP- сообщений.",
      "answer": [
        "Каждое HTTP-сообщение, как запрос, так и ответ состоит из трёх частей, которые передаются в указанном порядке: ",
        "1. Стартовая строка (start line) — определяет тип сообщения, версию используемого протокола HTTP, запрашиваемый ресурс или код ответа. Занимает ровно одну строчку. ",
        "2. HTTP-заголовки (HTTP Headers) — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо описывают содержимое тела сообщения.",
        "3. Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.",
        "Пустая строка сообщает, что все метаданные для конкретного запроса или ответа были отправлены."
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP-запрос.",
      "answer": [
        "HTTP-запрос содержит четыре элемента: метод, URI, версию HTTP и адрес хоста. Метод указывает, какое действие нужно совершить. URI — это путь до конкретного файла на сайте. Версию HTTP нужно указывать, чтобы избежать ошибок, а адрес хоста помогает браузеру определить, куда отправлять HTTP-запрос."
      ],
      "isParagraph": true
    },
    {
      "heading": "Стартовая строка HTTP-запроса",
      "answer": [
        "Стартовая строка HTTP-запроса состоит из трех элементов: ",
        "1. Метод HTTP-запроса (method).",
        "2. Цель запроса: путь к ресурсу: URL ( /index.html ) ",
        "3. Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.",
        "В примере ниже стартовая строка указывает, что в качестве метода используется GET, обращение будет произведено к ресурсу /index.html, по версии протокола HTTP/1.1: ",
        "Пример: GET/index.html HTTP/1.1 "
      ],
      "isParagraph": true
    },
    {
      "heading": "Методы HTTP-запроса (Request Methods).",
      "answer": [
        "HTTP имеет несколько методов запроса, которые указывают, какое действие должно выполнится для данного ресурса. Методы могут быть безопасными, идемпотентными или кэшируемыми. ",
        "1. GET - метод для чтения данных с сайта. Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value).",
        "2. HEAD - запрашивает ресурс так же, как и метод GET, но без тела ответа.",
        "3. POST - Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы, изображения и другие типы данных в двоичном виде. Метод используют для создания новых ресурсов, для выгрузки файлов на сервер, для отправки заполненной формы логина.",
        "4. PUT - запросы приводят к замене целевого ресурса на данные, передаваемые в запросе. Его можно использовать для обновления содержимого существующего ресурса или для создания нового ресурса.",
        "5. DELETE - удаляет указанный ресурс.",
        "6. OPTIONS - Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.",
        "7. PATCH - Позволяет внести частичные изменения в указанный ресурс по указанному расположению."
      ],
      "isParagraph": true
    },
    {
      "heading": "Безопасный метод HTTP.",
      "answer": [
        "Метод HTTP безопасен , если он не изменяет состояние сервера. Другими словами, метод безопасен, если он приводит к операции только для чтения. Несколько распространенных HTTP-методов безопасны: GET, HEAD, или OPTIONS. Все безопасные методы также идемпотентны, но не все идемпотентные методы безопасны. Например, PUT и DELETE оба являются идемпотентными, но небезопасными. Все безопасные методы также идемпотентны: HEAD PUT DELETE POST."
      ],
      "isParagraph": true
    },
    {
      "heading": "Идемпотентный метод HTTP.",
      "answer": [
        "Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяет состояние сервера. Все безопасные методы также идемпотентны: HEAD PUT DELETE POST."
      ],
      "isParagraph": true
    },
    {
      "heading": "Кэшируемый ответ HTTP",
      "answer": [
        "Кешируемые ответы - это HTTP-ответы, которые могут быть закешированы, то есть сохранены для дальнейшего восстановления и использования позже, тем самым снижая число запросов к серверу.",
        " - Кэшируемые методы: GET, HEAD.",
        " - Некэшируемые методы: PUT, DELETE, часто POST"
      ],
      "isParagraph": true
    },
    {
      "heading": "Чем отличаются HTTP-методы GET и POST.",
      "answer": [
        "HTTP-методы GET и POST — самые распространённые способы отправить или получить данные с сервера. Но в разных случаях оба метода могут быть небезопасными или неудобными в использовании. В этой заметке рассмотрим, какой метод когда использовать.",
        "GET — метод для чтения данных с сайта. Например, для доступа к указанной странице. Он говорит серверу, что клиент хочет прочитать указанный документ. На практике этот метод используется чаще всего, например, в интернет-магазинах на странице каталога. Фильтры, которые выбирает пользователь, передаются через метод GET.",
        "POST — метод для отправки данных на сайт (сервер). Чаще всего с помощью метода POST передаются формы.",
        "GET для безопасных действий, POST для опасных",
        "Говоря совсем просто, GET-запросы лучше не использовать с приватной информацией. Вот почему: они кэшируются. Это значит, что логин и пароль, переданные через GET - запрос, могут остаться в интернете навсегда, например, в веб-архиве или кэше Гугла. Остаются в истории браузера. Чтобы узнать, какие данные отправлялись, достаточно нажать Ctrl+H.",
        "Сохраняются в закладках и пересылаются. Можно не обратить внимания и опубликовать в соцсетях или отправить ссылку с приватной информацией в GET-запросе. Сохраняются в логах сервера. Например, нельзя отправлять данные банковских карт через GET-запрос, так как это создаёт риски для пользователей. Таким образом, любые важные данные — логины, пароли, данные карты, персональные данные — лучше передавать с помощью метода POST. Также метод POST поддерживает тип кодирования данных multipart/form-data, что позволяет передавать файлы.",
        "Ещё раз коротко",
        "GET: фильтры в интернет-магазинах, передача параметров через ссылку, другие безопасные запросы.",
        "POST: любые формы с паролями или банковскими картами, формы заявок с персональными данными, отправка файлов."
      ],
      "isParagraph": true
    },
    {
      "heading": "Чем отличаются PUT- и POST-запросы?",
      "answer": [
        "PUT - запросы приводят к замене целевого ресурса на данные, передаваемые в запросе. Его можно использовать для обновления содержимого существующего ресурса или для создания нового ресурса.",
        "POST - запросы приводят к специфической для ресурса обработке данных, передаваемых в запросе. Их можно использовать для выполнения различных действий. В том числе — для создания новых ресурсов, для выгрузки файлов на сервер, для отправки форм.",
        "Ещё одно отличие между PUT и POST запросами заключается в том, что PUT-запросы являются идемпотентными, а POST-запросы — нет. То есть — если запрос, в котором передаются одни и те же данные, и который выполняется по одному и тому же URL, будет выполнен несколько раз, это равносильно однократному выполнению этого запроса. Многократное выполнение POST-запроса не эквивалентно его однократному выполнению. То есть — несколько таких запросов, например, могут привести к созданию нескольких объектов на сервере."
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP - заголовки.",
      "answer": [
        "Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию с HTTP-запросом или ответом.",
        "В HTTP-заголовке содержится строка (''ключ:значение'') с ''названием-заголовка:значением''. Пробелы перед значением игнорируются. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы.  Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.",
        "В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории: ",
        "1. Общего назначения, которые применяются ко всему сообщению целиком.",
        "2. Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.",
        "3. Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.",
        "-- ",
        "Самые частые заголовки запроса ",
        "1. Host. Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.",
        "2. User-Agent. Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.",
        "3. Refer. Используется для указания того, откуда поступил текущий запрос. Например, если вы решите перейти по какой-нибудь ссылке в этой статье, то вероятнее всего к запросу будет добавлен заголовок Refer: https://selectel.ru",
        "4. Accept. Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (‘ , ‘). А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.",
        "5. Cookie. Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.",
        "6. Authorization. Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Тело запроса. ",
      "answer": [
        "Тело запроса — это информация, которую передал браузер при запросе страницы. Но тело запроса присутствует только, если браузер запросил страницу методом POST. Дело в том, что POST — это метод, специально предназначенный для отправки данных на сайт. Чаще всего метод POST браузер задействует в момент отправки формы. В этом случае телом запроса будет содержимое формы. ",
        "Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. Некоторые виды запросов  могут отправлять данные на сервер в теле запроса: самый распространенный из таких методов — POST. ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP-ответ.",
      "answer": [
        "HTTP-ответ имеет три части: статус ответа, заголовки и тело ответа. В статусе ответа сообщается, всё ли прошло успешно и возникли ли ошибки. В заголовках указывается дополнительная информация, которая помогает браузеру корректно отобразить файл. А в тело ответа сервер кладёт запрашиваемый файл. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Стартовая строка ответа HTTP. ",
      "answer": [
        "HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело. ",
        "Стартовая строка HTTP-ответа называется строкой статуса (status line). На ней располагаются следующие элементы: ",
        "1. Уже известная нам по стартовой строке запроса версия протокола (HTTP/2 или HTTP/1.1).",
        "2. Код состояния, который указывает, насколько успешно завершилась обработка запроса. (Ниже это '200' - код ошибки)",
        "3. Пояснение — короткое текстовое описание к коду состояния. (Ниже это 'OK') Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.",
        "Так выглядит строка состояния ответа: HTTP/1.1 200 OK "
      ],
      "isParagraph": true
    },
    {
      "heading": "Заголовки ответа ",
      "answer": [
        "Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела. Они существуют в том же формате, что и остальные заголовки, а именно  «Имя-Значение» с двоеточием (:) в качестве разделителя. ",
        "Ниже приведены наиболее часто встречаемые в ответах заголовки: ",
        "1. Server. Содержит информацию о сервере, который обработал запрос. ",
        "Пример: Server: ngnix",
        " --",
        "2. Set-Cookie. Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов.",
        "Пример:  Set-Cookie:PHPSSID=bf42938f",
        " --",
        "3. WWW-Authenticate. Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.",
        "Пример: WWW-Authenticate: BASIC realm=»localhost»"
      ],
      "isParagraph": true
    },
    {
      "heading": "Тело HTTP - сообщения.",
      "answer": [
        "Тело HTTP - сообщения используется для передачи тела объекта запроса или тела объекта ответа. Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Самым популярным типом тела сообщения является либо HTML, либо JSON."
      ],
      "isParagraph": true
    },
    {
      "heading": "HTTP, коды состояния (ответов) и текст статуса",
      "answer": [
        "Коды состояния HTTP используются для того, чтобы сообщить клиенту статус их запроса. HTTP-сервер может вернуть код, принадлежащий одной из пяти категорий кодов состояния: ",
        "1хх. Информационный. Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.",
        "--- 100 Continue (продолжай)",
        "2хх. Успех. Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.",
        "--- 200 Ok (Успех). Возвращается в случае успешной обработки запроса, при этом тело ответа обычно содержит запрошенный ресурс.",
        "--- 201 Created (Создано)",
        "--- 204 No content (Нет содержимого)",
        "3хх. Перенаправление. Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.",
        "--- 300 Moved permanently (перемещено навсегда)",
        "--- 301 Moved temporarily (перемещено временно)",
        "--- 302 Found (перемещено временно). Перенаправляет клиента на другой URL. Например, данный код может прийти, если клиент успешно прошел процедуру аутентификации и теперь может перейти на страницу своей учетной записи.",
        "4хх. Ошибка клиента. Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа.",
        "--- 400 Bad request (некорректный запрос). Данный код можно увидеть, если запрос был сформирован с ошибками. Например, в нем отсутствовали символы завершения строки.",
        "--- 401 Unauthorized (не авторизован)",
        "--- 403 Forbidden (Запрещенный). Означает, что клиент не обладает достаточными правами доступа к запрошенному ресурсу. Также данный код можно встретить, если сервер обнаружил вредоносные данные, отправленные клиентом в запросе.",
        "--- 404 Not found (не найден). Каждый из нас, так или иначе, сталкивался с этим кодом ошибки. Данный код можно увидеть, если запросить у сервера ресурс, которого не существует на сервере.",
        "5хх. Ошибка сервера. Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.",
        "--- 500 Internal server error (Внутренняя ошибка сервера). Данный код возвращается сервером, когда он не может по определенным причинам обработать запрос.",
        "--- 502 Bad gateway (Ошибка проксирования)"
      ],
      "isParagraph": true
    },
    {
      "heading": "URI URL URN",
      "answer": [
        "URI - Uniform Resource Identifier. Унифицированный идентификатор ресурса. Включает в себя: URL и URN.",
        "URI: https://github.com/pulls/mentioned ",
        "URL - Uniform Resource Locator. Унифицированный определитель местонахождения ресурса.",
        "URL: https://github.com/",
        "URN - Uniform Resource Name. Унифицированное имя ресурса.",
        "URN: /pulls/mentioned"
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое Cross-Origin Resource Sharing (CORS)? ",
      "answer": [
        "Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.",
        "В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки. ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое HTTP cookie (куки) и для чего их используют?",
      "answer": [
        "Сookie (куки) — это небольшие текстовые файлы, сгенерированные сайтами. В них записана информация о посещении сайта. Эти файлы хранятся на компьютере. Cookie нужны, чтобы идентифицировать пользователя, использовать его учетные данные для входа в систему при следующем посещении страницы. Когда вы вернётесь на сайт, он узнает вас и автоматически подстроится. ",
        "Куки отправляются сервером на браузер пользователя, хранятся на жестком диске в папке Пользователи (Users). С каждым новым запросом к данному серверу, отсылаются обратно. ",
        "Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.",
        "Веб-клиент, всякий раз при попытке открыть страницу соответствующего сайта, пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.",
        " --",

        "Важная особенность у файлов cookie: ",
        "файлы cookie имеют время жизни, которое мы сами можем устанавливать. ",
        "-- ",

        "Файлы cookie представляют собой текстовые файлы с парами ключ-значение. Куки можно создавать через JavaScript при помощи свойства Document.cookie. Если флаг HttpOnly не установлен, то и доступ к существующим cookies можно получить через JavaScript. ",
        " - document.cookie = 'yummy_cookie=choco';",
        " - document.cookie = 'tasty_cookie=strawberry';",
        "-- ",

        "Обычно cookie-файлы хранятся на жестком диске в папке Пользователи (Users). Например, куки из браузера Google Chrome хранятся по следующему пути: C:UsersНазвание_пользователяAppDataLocalGoogleChromeUser DataDefault (или Profile)Cookies. Данные из других браузеров можно найти по схожему пути, только найдите папку другого браузера. ",
        "Cookie используются, главным образом, для: ",
        "1. Управления сеансом (логины, корзины для виртуальных покупок).",
        "2. Персонализации (пользовательские предпочтения).",
        "3. Мониторинга (отслеживания поведения пользователя).",
        "Один из наиболее частых случаев использования куки – это аутентификация....  ",
        "-- "
      ],
      "isParagraph": true
    },
    {
      "heading": "Прокси-сервер, прокси. ",
      "answer": [
        "Прокси-сервер – это дополнительный шлюз, участвующий в интернет-соединении, дополнительное звено между вами и интернетом. Proxy используется как посредник между клиентом и сайтом, на который он хочет перейти. По сути, прокси — это фильтр между человеком и огромными (и не всегда безопасными) данными в сети.",
        "При подключения через proxy-server происходит замена IP-адреса, что позволяет ускорить интернет-соединение, обойти блокировку какого-либо ресурса и другое.",
        "С прокси-серверами сталкиваются почти все пользователи интернета, даже если они об этом не подозревают. ",
        "---",
        "Прокси-сервер — промежуточный сервер (комплекс программ) в компьютерных сетях, выполняющий роль посредника между пользователем и целевым сервером (при этом о посредничестве могут как знать, так и не знать обе стороны), позволяющий клиентам как выполнять косвенные запросы (принимая и передавая их через прокси-сервер) к другим сетевым службам, так и получать ответы. Сначала клиент подключается к прокси-серверу и запрашивает какой-либо ресурс (например e-mail), расположенный на другом сервере."
      ],
      "isParagraph": true
    },
    {
      "heading": "Обратный прокси. ",
      "answer": [
        "Обратный прокси-сервер является службой, которая работает на каждом узле и обрабатывает разрешение конечных точек, автоматический повтор операций и другие сбои подключения от имени служб клиента. ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Зачем нужен прокси? ",
      "answer": [
        "При подключения через proxy-server происходит замена IP-адреса, что позволяет:",
        " - ускорить интернет-соединение;",
        " - обойти блокировку какого-либо ресурса;",
        " - усилить безопасность соединения;",
        " - защитить приватность (конфиденциальность) клиента, чтобы сайты не знали, кто именно их посещает;",
        " - балансировать нагрузку на посещаемый ресурс;",
        " - и другое."
      ],
      "isParagraph": true
    },
    {
      "heading": "Как работает прокси?",
      "answer": [
        "Прокси – это сервер, к которому вы подключаетесь, чтобы изменить свой IP-адрес. Работает это так:",
        "1. Пользователь из России подключился к прокси США. IP юзера изменился с российского на американский ",
        "2. Человек заходит на веб-ресурс.",
        "3. Устройство отправляет запрос прокси-серверу.",
        "4. Прокси-сервер отправляет запрос веб-странице от своего имени.",
        "5. Веб-страница отправляет данные промежуточному серверу",
        "6. Промежуточный сервер доставляет эти данные вам",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое прокси сервер и впн? ",
      "answer": [
        "Прокси - это посредник между клиентом и серверов. VPN - это виртуальная сеть, которая для устройства ничем не отличается от локальной. В большинстве случаев VPN определяется ПО как сетевой адаптер, поэтому программа, чей трафик направлен через VPN, не 'знает' об этом. Приложения работают, используя обычные сетевые протоколы. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Чем прокси отличается от VPN?",
      "answer": [
        "Главное отличие прокси от VPN заключается в том, что VPN защищает весь сетевой трафик, а прокси – только интернет-трафик. Прокси передает запросы, действуя как посредник, а VPN туннелирует всю сетевую активность до уровня операционной системы. Компании используют VPN, чтобы дать доступ сотрудникам к корпоративным ресурсам, не беспокоясь о том, что трафик будет перехвачен или задамплен провайдером."
      ],
      "isParagraph": true
    },
    {
      "heading": "Для чего используется WebSocket? В чем принцип его работы? ",
      "answer": [
        "WebSocket — протокол связи, предназначенный для обмена данными между браузером и сервером, используя постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.",
        "WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.",
        "--"
      ],
      "isParagraph": true
    },
    {
      "heading": "Что такое Веб-компоненты и какие технологии в них используются?",
      "answer": [
        "Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы. ",
        "Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других: ",
        "1. Custom Elements — API для создания собственных HTML элементов.",
        "2. HTML Templates — тег позволяет реализовывать изолированные DOM-элементы.",
        "3. Shadow DOM — изолирует DOM и стили в разных элементах.",
        "4. HTML Imports — импорт HTML документов."
      ],
      "isParagraph": true
    },
    {
      "heading": "Криптографическая защита.",
      "answer": [
        "Криптографическая защита - это защита данных с помощью криптографического преобразования, под которым понимается преобразование данных методом шифрованием, кодирования или иного преобразования информации. ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Домен, доменные имена это...  ",
      "answer": [
        "Домен — это часть адреса сайта. ",
        "Любой адрес сайта состоит из доменов разных уровней. ",
        "Например, в адрес yandex.ru входит домен первого уровня — «.ru» и домен второго уровня — «yandex». ",
        "Домен первого уровня обычно обозначает страну или тематику. Так, домены «.ru» и «.рф» предназначены для сайтов из России, а «.aero» — для авиатранспортных компаний. ",
        "Домены второго и последующих уровней чаще всего указывают на разделы сайта или внутренние проекты компании — например, market.yandex.ru. ",
        "-- ",
        "Доменное имя — символьное имя, служащее для идентификации областей, которые являются единицами административной автономии в сети Интернет... "
      ],
      "isParagraph": true
    },
    {
      "heading": "Как доменное имя связано с IP-адресом сайта. ",
      "answer": [
        "Компьютеры находят друг друга в Сети и обмениваются данными с помощью IP-адресов. IP-адрес — это строка из четырёх чисел (октетов), разделённых точками. В этих числах зашифрована информация о местоположении сервера с файлами сайта. Каждое доменное имя привязано к IP-адресу. Например, домену skillbox.ru соответствует адрес 178.248.237.96. "
      ],
      "isParagraph": true
    },
    {
      "heading": "IP-адрес  ",
      "answer": [
        "P-адресов. IP-адрес — это строка из четырёх чисел (октетов), разделённых точками. В этих числах зашифрована информация о местоположении сервера с файлами сайта. Каждое доменное имя привязано к IP-адресу. Например, домену skillbox.ru соответствует адрес 178.248.237.96. ",
        "IP-адрес — это 32-битный номер. Он уникально идентифицирует хост (компьютер или другое устройство, например, принтер или маршрутизатор) в сети TCP/IP. IP-адреса обычно выражаются в десятичном представлении с точками, в виде четырех номеров, разделенных точками, например, 192.168.123.132. Чтобы понять, как маски подсети используются для различия между хостами, сетями и подсетями, изучите IP-адрес в двоичном представлении. ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " ", " ", " ", " ", " ", " "],
      "isParagraph": true
    }
  ],
  "linksIconsLoaders": [
    {
      "href": "https://active-vision.ru/icon/",
      "title": "Скачайте иконки бесплатно"
    },
    {
      "href": "https://atuin.ru/blog/loadery-i-spinnery-na-css/",
      "title": "Сборник иконок лоадеров и спиннеров на CSS"
    },
    {
      "href": "https://html5book.ru/specsimvoly-html/",
      "title": "Спецсимволы HTML"
    },
    {
      "href": "https://symbl.cc/ru/html-entities/",
      "title": "Спецсимволы HTML-мнемоники"
    },
    {
      "href": "https://getemoji.com/",
      "title": "Copy and Paste Emoji. Скопируйте и вставьте эмодзи"
    },
    {
      "href": "https://developers.google.com/fonts/docs/material_icons#icon_font_for_the_web",
      "title": "Иконочный шрифт для Интернета. Установка, использование через Google Font"
    },
    {
      "href": "https://fonts.google.com/icons?selected=Material+Icons",
      "title": "Материальные иконки доступны в пяти стилях и различных загружаемых размерах и плотности. Иконки основаны на основных принципах и показателях Material Design."
    },
    {
      "href": "https://developers.google.com/fonts/docs/material_icons",
      "title": "Material Icons Guide. Обзор иконок материалов — где их взять и как интегрировать в свои проекты"
    },
    {
      "href": "",
      "title": ""
    },
    {
      "href": "",
      "title": ""
    }
  ]
}

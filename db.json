{
  "posts": [{ "id": 1, "title": "json-server", "author": "typicode" }],
  "comments": [{ "id": 1, "body": "some comment", "postId": 1 }],
  "profile": { "name": "typicode" },
  "linksCSS": [
    {
      "href": "https://www.npmjs.com/package/node-sass",
      "title": "npm i node-sass"
    },
    {
      "href": " ",
      "title": " "
    },
    {
      "href": "https://meyerweb.com/eric/tools/css/reset/",
      "title": "Сброс - reset CSS."
    },
    {
      "href": "https://bobbyhadz.com/",
      "title": "Блог боббихадз, статьи о веб-разработке и облачных вычислениях."
    },
    {
      "href": "https://active-vision.ru/icon/box-shadow/",
      "title": "CSS BOX-SHADOW ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/icon/gradient/",
      "title": "CSS GRADIENT ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/blog/youtube-video-na-sayt/",
      "title": "Добавляем YouTube видео на сайт"
    },
    {
      "href": "https://ru.savefrom.net/1-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1-%D1%81%D0%BA%D0%B0%D1%87%D0%B0%D1%82%D1%8C-%D1%81-youtube-80/",
      "title": "Скачать видео и музыку с Ютуба"
    },
    {
      "href": "https://webstool.ru/jquery.maskedinput.html",
      "title": "jQuery.Maskedinput js - маска для телефона"
    },
    {
      "href": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors",
      "title": "Селекторы CSS"
    },
    {
      "href": "https://htmlacademy.ru/blog/css/selectors",
      "title": "Селекторы CSS по htmlacademy"
    },
    {
      "href": "https://habr.com/ru/company/ruvds/blog/485640/",
      "title": "Какими способами можно визуально скрыть элемент?"
    },
    {
      "href": "http://htmlbook.ru/samlayout/blochnaya-verstka/strochnye-elementy",
      "title": "Строчные элементы в HTML (Языке Гипертекстовой Разметки),"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/HTML/Inline_elements",
      "title": "Строчные элементы по 'developer.mozilla'"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements",
      "title": "Блочные элементы по 'developer.mozilla'"
    },
    {
      "href": "http://htmlbook.ru/css/display",
      "title": "Свойство display."
    },
    {
      "href": "http://htmlbook.ru/samlayout/blochnaya-verstka/pozitsionirovanie-elementov",
      "title": "Позиционирование элементов"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements",
      "title": "Псевдоэлемент в CSS"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-classes",
      "title": "Псевдокласс в CSS"
    },
    {
      "href": "https://learn.javascript.ru/size-and-scroll-window#zapretit-prokrutku",
      "title": "Запретить прокрутку"
    },
    {
      "href": "https://active-vision.ru/blog/polosa-prokrutki-css/",
      "title": "Как стилизовать или убрать полосу прокрутки — CSS скроллбар"
    },
    {
      "href": "https://ru.stackoverflow.com/questions/431590/%D0%A3%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-input-type-number",
      "title": "Убрать стрелочки с input type='number'"
    },
    {
      "href": "https://html5book.ru/css3-ten-bloka/",
      "title": "Как сделать тень блока с помощью свойства box-shadow"
    },
    {
      "href": "https://developer.mozilla.org/ru/docs/Web/CSS/transform",
      "title": "transform Интерактивный пример"
    },
    {
      "href": "https://habr.com/ru/company/ruvds/blog/493660/",
      "title": "CSS: полное руководство по функции calc()"
    },
    {
      "href": "https://active-vision.ru/blog/css-psevdoklass-is/",
      "title": "CSS псевдокласс :is() — как и где его использовать"
    },
    {
      "href": "https://active-vision.ru/blog/kak-sdelat-stupenchatuyu-animatsiyu-pri-navedenii-na-chistom-css/",
      "title": "Как сделать ступенчатую анимацию при наведении курсора на чистом CSS"
    },

    {
      "href": "https://materializecss.com/",
      "title": "Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design."
    },
    {
      "href": "https://vk.com/@result.school-17-klassnyh-css-bibliotek",
      "title": "17 классных CSS-библиотек. Подборка полезных CSS библиотек, которые помогут вам при разработке веб-сайтов"
    },
    {
      "href": "https://animate.style/",
      "title": "Библиотека 'Animate.css'"
    },
    {
      "href": " ",
      "title": " "
    }
  ],
  "linksCSSFishki": [
    {
      "href": "https://active-vision.ru/icon/box-shadow/",
      "title": "BOX-SHADOW ГЕНЕРАТОР"
    },
    {
      "href": "https://active-vision.ru/icon/gradient/",
      "title": "GRADIENT ГЕНЕРАТОР"
    },
    {
      "href": "",
      "title": ""
    }
  ],
  "linksFrameworksCSS": [
    {
      "href": "https://www.npmjs.com/package/node-sass",
      "title": "npm i node-sass"
    },
    {
      "href": "https://storybook.js.org/",
      "title": "Storybook — это мастер-класс по внешнему интерфейсу для изолированного создания компонентов и страниц пользовательского интерфейса. Тысячи команд используют его для разработки пользовательского интерфейса, тестирования и документации. Это с открытым исходным кодом и бесплатно."
    },
    {
      "href": "https://habr.com/ru/post/340384/",
      "title": "Создание библиотеки компонентов с использованием Storybook"
    },
    {
      "href": "https://ant.design/docs/react/introduce",
      "title": "Ant Design of React - библиотека пользовательского интерфейса React antd, которая содержит набор высококачественных компонентов и демонстраций для создания многофункциональных интерактивных пользовательских интерфейсов."
    },
    {
      "href": "https://loading.io/css",
      "title": "Pure CSS Loaders"
    },
    {
      "href": "https://tailwindcss.com/docs/guides/create-react-app",
      "title": "Tailwind CSS - Утилитарный CSS-фреймворк для создания любого дизайна в вашей разметке."
    },
    {
      "href": "https://www.youtube.com/watch?v=_KWNWBhR6Vc",
      "title": "Tailwind CSS + React - Проект с нуля. Max Roslow."
    },
    {
      "href": "https://react-bootstrap.netlify.app/components/alerts/",
      "title": "bootstrap components (компоненты)"
    },
    {
      "href": "https://bootstrap-5.ru/",
      "title": "Bootstrap"
    },
    {
      "href": "https://react-bootstrap.github.io/getting-started/introduction/",
      "title": "React-Bootstrap. npm install react-bootstrap bootstrap"
    },
    {
      "href": "https://react-bootstrap-v4.netlify.app/getting-started/introduction/",
      "title": "React-Bootstrap. npm install react-bootstrap bootstrap@4.6.0"
    },
    {
      "href": "https://react.school/material-ui",
      "title": "Material UI — библиотека пользовательского интерфейса React. Честно говоря, нет второй библиотеки пользовательского интерфейса для React, которую мы могли бы порекомендовать."
    },
    {
      "href": "https://v4.mui.com/ru/getting-started/installation/",
      "title": "Инструкция по установке Material-UI, самый популярный в мире фреймворк для пользовательского интерфейса React."
    },
    {
      "href": "https://mui.com/material-ui/getting-started/overview/",
      "title": "Material UI — это библиотека компонентов пользовательского интерфейса React, реализующая Material Design от Google."
    },
    {
      "href": "https://mui.com/material-ui/about-the-lab/",
      "title": "О лаборатории. В этом пакете размещаются компоненты инкубатора, которые еще не готовы к перемещению в ядро."
    },
    {
      "href": "https://mui.com/",
      "title": "Material UI. React. Typescript. CSS "
    },
    {
      "href": "https://github.com/mui/material-ui",
      "title": "mui/material-ui"
    },
    {
      "href": "https://mui.com/material-ui/react-rating/#main-content",
      "title": "material-ui components (компоненты)"
    },
    {
      "href": "https://www.youtube.com/watch?v=OZ_FUaV_xbg&t=6s",
      "title": "Библиотека компонентов Material UI. Быстрый старт. Михаил Непомнящий."
    },
    {
      "href": "",
      "title": ""
    },
    {
      "href": "",
      "title": ""
    }
  ],
  "arrayCSS": [
    {
      "heading": "CSS, фреймворки CSS.",
      "answer": [
        "Каскадная таблица стилей (CSS) формально является набором команд и инструментов для работы с внешним видом веб-страницы. Она делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. Как и в случае с языками программирования, существует множество готовых библиотек CSS, созданных профессионалами для удобства работы со стилями.",
        "CSS-фреймворк — фреймворк, созданный для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки (проблемы совместимости различных версий браузеров и т. д.). Готовые к использованию классы являются их основными строительными блоками. Они позволяют применять к элементам HTML заранее определенные правила, а также включают в себя готовые компоненты (меню, кнопки, карточки). Данные фреймворки подразумевают использование различных подходов для корректного отображения сайтов на устройствах любого размера. Многие разработчики предпочитают использование CSS-фреймворков, вместо прописывания всех стилей вручную. Это обусловлено следующими причинами:",
        " - Более быстрая разработка ",
        " - Поддержка кроссбраузерности",
        " - Поддержка различных устройств и размеров экранов",
        " - Единообразие кода при работе в команде позволяет снизить число разногласий при разработке. ",
        " - Как и библиотеки скриптовых языков программирования, CSS-библиотеки, обычно имеющие вид внешнего CSS-файла, добавляются в заголовок веб-страницы."
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим самые популярные CSS-фреймворки.",
      "answer": [
        "Bootstrap",
        "https://getbootstrap.com/",
        "Material Design for Bootstrap",
        "https://mdbootstrap.com/docs/standard/",
        "Materialize",
        "https://materializecss.com/",
        "Bulma",
        "https://bulma.io/",
        "Pure",
        "https://purecss.io/",
        "Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design.",
        "https://materializecss.com/",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Какими CSS-фреймворками вы пользовались? Что бы вы хотели в них изменить/улучшить?",
      "answer": [
        "Использовал Bootstrap, Materialize и др. CSS-фреймворки накладывают ограничения и добавляют работы по переопределению дефолтных свойств элементов. Если нет чётких требования использования фреймворков, стараюсь их избегать."
      ],
      "isParagraph": true
    },
    {
      "heading": "Какая разница между селекторами идентификаторов и классов в CSS?",
      "answer": [
        "Идентификаторы (id) уникальны. У элемента может быть только один идентификатор. На странице может присутствовать лишь один элемент с конкретным идентификатором.",
        "Имена классов (class) не являются уникальными. Один и тот же класс можно назначать множеству элементов. Элементу может быть назначено несколько классов.",
        "Если некий стиль нужно применить к нескольким элементам страницы — эту задачу нужно решать с использованием классов."
      ],
      "isParagraph": true
    },
    {
      "heading": "Псевдоэлементы ::after, ::before и другие",
      "answer": [
        "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент ::first-line может быть использован для изменения шрифта первой строки абзаца."
      ],
      "isParagraph": true
    },
    {
      "heading": "Псевдоклассы :hover, :visited, :checked и другие",
      "answer": [
        "Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое позволяет стилизовать элемент: ",
        " - на основе отношений в DOM-дереве,",
        " - истории посещений (например, :visited),",
        " - состоянии содержимого (вроде :checked у некоторых элементов формы)",
        " - или позиции курсора мыши (например, :hover определяет, находится ли курсор мыши над элементом)... ",
        " - Например, :hover может быть использован для изменения цвета кнопки при наведении курсора на неё."
      ],
      "isParagraph": true
    },
    {
      "heading": "Как задать элементу определенные стили при наведении, при нажатии, при фокусе?",
      "answer": [
        "при наведении - с помощью псевдокласса hover ",
        "при нажатии - с помощью псевдокласса active ",
        "при фокусе - с помощью псевдокласса focus "
      ],
      "isParagraph": true
    },
    {
      "heading": "У вас есть список покупок. Каждому второму элементу списка необходимо задать синий фон. Как это можно сделать используя псевдоселекторы ",
      "answer": ["С помощью псевдокласса tr:nth-child(even) или tr:nth-child(2n) (чётные строки HTML)", " "],
      "isParagraph": true
    },
    {
      "heading": "Как пользоваться медиазапросами @media в CSS?",
      "answer": [
        "В медиазапросах используется правило @media, с помощью которого можно применять CSS-стили к различным типам содержимого. Медиазапросы могут использоваться и для настройки элементов страниц с учётом характеристик среды, в которой просматривают страницы.",
        "/* Изменить фоновый цвет любого элемента div на ''red'' в том случае, если ширина окна браузера составляет 600px или меньше */ ",
        "@media only screen and ( max-width: 600px ) {div { background-color: red }} ",
        "Медиа-запросы @media позволяют задавать различные стили элементам, компонентам вэб-приложения для определенного размера экрана, типа устройства, где данное вэб-приложение просматривается или используется. Все медиа-запросы начинаются с @media, а далее следует условие. ",
        "С помощью медиа-запросов можно задать стили для следующих типов устройств: ",
        " - all — все типы (значение используется по умолчанию)",
        " - braille — устройства, основанные на системе Брайля, которые предназначены для чтения слепыми людьми",
        " - embossed — принтеры, использующие для печати систему Брайля ",
        " - handheld — смартфоны и аналогичные им аппараты",
        " - print — принтеры и другие печатающие устройства",
        " - projection — проекторы",
        " - screen — экран монитора",
        " - speech — речевые синтезаторы, а также программы для воспроизведения текста вслух",
        " - tty — устройства с фиксированным размером символов",
        " - tv — телевизоры."
      ],
      "isParagraph": true
    },
    {
      "heading": "Специфичность CSS-селекторов и как она работает?",
      "answer": [
        "Если одному и тому же элементу определенно сразу несколько CSS-правил с разными селекторами, то браузер применит тот стиль, который определён по специфичности CSS-селекторов.",
        "Специфичность CSS-селекторов - это алгоритм, основанный на правилах соответствия селекторов CSS, который определяет, какие стили будут примены к данному элементу.",
        "Специфичность селекторов по возрастанию:",
        " - тег и псевдоэлемент имеют специфичность 0001 ",
        " - класс, псевдокласс, атрибут - 0010 ",
        " - id имеет специфичность 0100 ",
        " - инлайновый стиль (style=''...'') указанный в HTML-коде имеет приоритет 1000 ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "reset - «сброс», Normalize - «нормализация». В чем разница между ними?",
      "answer": [
        "Сброс (reset) сбрасывает все дефолтно-браузерные стили HTML-элементов.",
        "Normalize приводит стили к единому виду во всех браузерах.",
        "Цели normalize.css: ",
        " - сохранять полезные настройки браузера, а не стирать их;",
        " - нормализовать стили для широкого круга HTML-элементов;",
        " - корректировать ошибки и несоответствия браузера;",
        " - совершенствовать юзабилити незаметными улучшениями;",
        " - объяснять код, используя комментарии и детальную документацию.",
        " Из-за кроссбраузерности следует выбирать Normalize, но я пользуюсь reset"
      ],
      "isParagraph": true
    },
    {
      "heading": "Как вы решаете стилевые проблемы, связанные с особенностями браузеров?",
      "answer": [" - Использую normalize или reset CSS", " - Использую автопрефиксы (autoprefixer)"],
      "isParagraph": true
    },
    {
      "heading": "floats, как они работают",
      "answer": [
        "При применении этого свойства происходит следующее:",
        " 1. Элемент позиционируется как обычно, а затем вынимается из потока документа и сдвигается влево (для left) или вправо (для right) до того как коснётся либо границы родителя, либо другого элемента с float. ",
        " 2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться. ",
        " 3. Другие непозиционированные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из потока.  ",
        " 4. Строки (inline-элементы), напротив, «знают» о float и обтекают элемент по сторонам."
      ],
      "isParagraph": true
    },
    {
      "heading": "свойство z-index",
      "answer": [
        "Позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы. Их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative (абсолютное, фиксированное или относительное).",
        " - Элементы с большим z-index перекрывают элементы с меньшим. ",
        " - При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML написан ниже.",
        " - Если свойства z-index и позиционирование не заданы явно, то порядок наложения равен порядку следования элементов в HTML."
      ],
      "isParagraph": true
    },
    {
      "heading": "Эффективый CSS, на что обратить внимание?",
      "answer": [
        "Для написания эффективного CSS должна быть система. Я использую модификацию БЭМ и препроцессор SASS. Код можно переиспользовать."
      ],
      "isParagraph": true
    },
    {
      "heading": "Какими способами можно визуально скрыть элемент?",
      "answer": [
        "Элементы, невидимые на странице, могут пребывать в различных состояниях:",
        " - Некий элемент совершенно невидим и, более того, удалён из потока документа.",
        " - Глазами элемент не увидеть, но он присутствует в документе и доступен для ассистивных технологий наподобие средств для чтения с экрана.",
        " - Элемент видим, но скрыт от средств для чтения с экрана."
      ],
      "isParagraph": true
    },
    {
      "heading": "1. HTML5-атрибут hidden ",
      "answer": [
        "Hidden — это логический HTML-атрибут, скрывающий элементы, которым он назначен. Когда браузер загружает страницу, он не выведет элементы с атрибутом hidden, за исключением тех случаев, когда видимость элементов будет включена вручную средствами CSS.",
        "<img hidden src=''landscape.jpg'' /> ",
        "Вот CSS-код, который здесь использован:  ",
        " - 1. img[ hidden ] { display: none }",
        " - 2. @media ( min-width: 400px ) { img[ hidden ] { display: block }}",
        "Если рассмотреть 'атрибут hidden' с точки зрения доступности контента, то окажется, что этот атрибут полностью скрывает элемент. В результате с этим элементом не смогут работать средства для чтения с экрана. Не используйте этот атрибут в тех случаях, когда некие элементы страниц нужно делать невидимыми для человека, но не для программ для чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. CSS-свойство display",
      "answer": [
        " - 1. img { display: none } ",
        " - 2.  @media ( min-width: 400px ) {img { display: block }} ",
        "При использовании свойства 'display: none' элемент становится невидимым и, кроме того, недоступным для средств чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "3. CSS-свойство opacity",
      "answer": [
        " - 1. img { opacity: 0 }  ",
        "Элемент, скрытый с помощью opacity: 0, остаётся доступным для средств чтения с экрана. Такой элемент может получить фокус при работе со страницей с помощью клавиатуры. "
      ],
      "isParagraph": true
    },
    {
      "heading": "4. CSS-свойство visibility",
      "answer": [
        " - 1. article { visibility: hidden }",
        " - 2. img {  visibility: visible } ",
        "При применении свойства visibility: hidden элемент оказывается скрытым. Он, кроме того, удаляется из дерева доступности и, в результате, его не замечают средства для чтения с экрана. "
      ],
      "isParagraph": true
    },
    {
      "heading": "5.Скрытие элементов и позиционирование",
      "answer": [
        " - .container { position: absolute; top: -100%; (left: -100%); (right: -100%); }",
        " - .container:focus { position: absolute; top: 0; (left: 0); (right: 0); }",
        "Элемент, выведенный за пределы области просмотра, доступен для средств чтения с экрана, добраться до него можно и с помощью клавиатуры. Он лишь оказывается невидимым при обычной работе со страницей."
      ],
      "isParagraph": true
    },
    {
      "heading": "6. Размеры компонента",
      "answer": ["width: 0px; height: 0px;"],
      "isParagraph": true
    },
    {
      "heading": "7. CSS-свойство clip-path",
      "answer": [
        "Если к элементу применяется CSS-свойство clip-path — оно позволяет описать область, определяющую то, какая часть элемента должна быть скрытой, а какая — видимой.",
        " -  img { clip-path: circle(0 at 50% 50%) }",
        "Элемент, к которому применено свойство clip-path, скрыт лишь визуально. До него можно добраться с помощью клавиатуры, он доступен для программ чтения с экрана."
      ],
      "isParagraph": true
    },
    {
      "heading": "8. Манипуляции с цветом текста и с размером шрифта",
      "answer": [
        "Хотя скрытие текста путём изменения его цвета или размеров шрифта распространено не так широко, как ранее рассмотренные методики скрытия элементов, в некоторых случаях это может пригодиться."
      ],
      "isParagraph": true
    },
    {
      "heading": "9. Настройка прозрачности цвета",
      "answer": [
        "Если использовать для текста прозрачный цвет, то этот текст окажется невидимым. Это может оказаться полезным при создании кнопок, на которых используются только значки."
      ],
      "isParagraph": true
    },
    {
      "heading": "10. Настройка размера шрифта",
      "answer": ["Кроме того, если установить размер шрифта в значение 0, это тоже позволит скрыть текст."],
      "isParagraph": true
    },
    {
      "heading": "Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?",
      "answer": ["Использовал сетку Bootstrap, CSS grid, флекс. Предпочитаю флекс."],
      "isParagraph": true
    },
    {
      "heading": "Что такое блочный контекст форматирования?",
      "answer": [
        "Блочный контекст форматирования — это отображение и взаимодействие компонентов веб-страницы в привычном для блоков порядке.",
        "Блочный контекст форматирования могут создать: ",
        " - блочные HTML-элементы",
        " - float-элементы, флекс-элементы, грид-элементы",
        " - позиционированные элементы",
        " - «строчные блоки» (элементы с display: inline-block)",
        " - ячейки, анонимные ячейки, заголовки таблицы "
      ],
      "isParagraph": true
    },
    {
      "heading": "Строчная модель. Строчные элементы в HTML (Языке Гипертекстовой Разметки)",
      "answer": [
        "Строчные элементы, это те, которые занимают только то пространство, которое ограничено тегами, определяющими строчный элемент (необходимое для отображения их содержимого) и не нарушая потока содержимого (не требующее новой строки после каждого элемента).",
        "Строчный элемент не начинается с новой строки, в ширину занимает столько места, сколько это необходимо для его отображения."
      ],
      "isParagraph": true
    },
    {
      "heading": "В чём разница между строчным, блочным и блочно-строчным элементом?",
      "answer": [
        "Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства display установлено как inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. Он занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство display задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов.",
        "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
        "div { display: inline-block } "
      ],
      "isParagraph": true
    },
    {
      "heading": "Строчный элемент - 'inline' ",
      "answer": [
        " - Размер зависит от контента.",
        " - Ширину и высоту задавать нельзя.",
        " - Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит - от line-height.",
        " - Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.",
        " ------------------------------------",
        "Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено.",
        "Эффект схлопывания отступов не действует. ",
        "Свойства, связанные с размерами (width, height) не применимы.",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько строчных элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.",
        "Можно выравнивать по вертикали с помощью свойства vertical-align."
      ],
      "isParagraph": true
    },
    {
      "heading": "Блочный элемент - 'block' ",
      "answer": [
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. ",
        "Такой элемент занимает всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.",
        "К блочным элементам относятся контейнеры div, h1, form и др ",
        "Блочная модель отвечает за определение того, сколько места займет блочный элемент, схлопнутся или нет border или margin, размеры блока. ",
        "Размеры блочного элемента складываются из width, height, padding, border, and margin. ",
        "Если высота (height) блока не задана, то высота блока равна: высота контента этого блока + padding'и.",
        "Если ширина блока не задана, то блоки, для которых не задано float, будут иметь ширину: ширина родителя - padding'и родителя.",
        " ------------------------------------",
        " - Начинается с новой строки родительского элемента и занимает всю строку. ",
        " - Можно задавать ширину и высоту. ",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон.",
        " ------------------------------------",
        "Блоки располагаются по вертикали друг под другом.",
        "На прилегающих сторонах элементов действует эффект схлопывания отступов. ",
        "Запрещено вставлять блочный элемент внутрь строчного. Например, <a><h1>Заголовок</h1></a> не пройдёт валидацию, правильно вложить теги наоборот — <h1><a>Заголовок</a></h1>. ",
        "По ширине блочные элементы занимают всё допустимое пространство. ",
        "Если задана ширина контента (свойство width), то ширина блока складывается из значений width, полей, границ, отступов слева и справа.",
        "Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.",
        "Если задана высота контента (свойство height), то высота блока складывается из значения height, полей, границ, отступов сверху и снизу. При превышении указанной высоты контент отображается поверх блока. ",
        "На блочные элементы не действуют свойства, предназначенные для строчных элементов, вроде vertical-align. ",
        "Текст по умолчанию выравнивается по левому краю."
      ],
      "isParagraph": true
    },
    {
      "heading": "Блочно-строчный элемент - 'inline-block' ",
      "answer": [
        " - Размер зависит от контента.",
        " - Можно задавать ширину и высоту.",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон. ",
        " ------------------------------------",
        "Внутрь строчно-блочных элементов допустимо помещать текст, строчные или блочные элементы. ",
        "Высота элемента вычисляется браузером автоматически, исходя из содержимого блока. ",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости. ",
        "Можно выравнивать по вертикали с помощью свойства vertical-align. ",
        "Разрешено задавать ширину и высоту. ",
        "Эффект схлопывания отступов не действует. ",
        " ------------------------------------",
        "Пример использования:",
        "http://htmlbook.ru/samlayout/blochnaya-verstka/strochno-blochnye-elementy"
      ],
      "isParagraph": true
    },
    {
      "heading": "Что делает * { box-sizing: border-box; }? В чём его преимущества?",
      "answer": [
        "Свойство box-sizing определяет как вычисляется общая ширина и высота элемента. По умолчанию все элементы имеют box-sizing: content-box. - `content-box`. Если мы задаём элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а финальная ширина элемента, в этом случае, увеличится на сумму отступов и толщину бордера. ",
        "Значение свойства `border-box` говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Свойство display определяет тип отображения элемента, как элемент должен быть показан в документе.",
      "answer": [
        "1. none - элемент не показывается. ",
        "2. block - блочные элементы располагаются вертикально один над другим. Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно. Это значение`display`многие элементы имеют по умолчанию:`div` , заголовок`h1,`параграф`p.` ",
        "3. Inline-элементы располагаются на одной строке, последовательно. Ширина и высота элемента определяются по содержимому. Поменять их нельзя.",
        "4. Inline-block - элемент продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока, ему можно указать ширину и высоту явно. ",
        "5. Flex - это свойство, при котором элемент растягивается или сжимается для заполнения собой свободного пространства. ",
        "6. Inline-flex - похоже на флекс, только элементы будут растягиваться или сжиматься инлайново (в строку) для заполнения собой свободного пространства. ",
        "7. Table - Для таблицы целиком`table`, для строки –`table-row`, для ячейки –`table-cell`и т.д. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Пользовались ли вы Flexbox или Grid?",
      "answer": ["Да. Использую flexbox. У grid всё ещё не такая широкая поддержка браузеров."],
      "isParagraph": true
    },
    {
      "heading": "Позиционирование элементов, типы позиционирования.",
      "answer": [
        "Позиционированием называется положение элемента в системе координат. Различают четыре типа позиционирования: нормальное, абсолютное, фиксированное и относительное. В зависимости от типа, который устанавливается через свойство position, изменяется и система координат.",
        "Благодаря комбинации свойств position, left, top, right и bottom элемент можно накладывать один на другой, выводить в точке с определёнными координатами, фиксировать в указанном месте, определить положение одного элемента относительно другого и др. Подобно другим свойствам CSS управление позиционированием доступно через скрипты. Таким образом, можно динамически изменять положение элементов без перезагрузки страницы, создавая анимацию и различные эффекты.",
        "1. Нормальное позиционирование.",
        "Если для элемента свойство position не задано или его значение static, элемент выводится в потоке документа как обычно. Иными словами, элементы отображаются на странице в том порядке, как они идут в исходном коде HTML. Свойства left, top, right, bottom если определены, игнорируются.",
        "2. Абсолютное позиционирование",
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью» ",
        "3. Фиксированное положение",
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю",
        "4. Относительное позиционирование",
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Абсолютное позиционирование",
      "answer": [
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью»",
        "Для режима характерны следующие особенности. ",
        " - Ширина слоя, если она не задана явно, равна ширине контента плюс значения полей, границ и отступов.",
        " - Слой не меняет своё исходное положение, если у него нет свойств right, left, top и bottom.",
        " - Свойства left и top имеют более высокий приоритет по сравнению с right и bottom. Если left и right противоречат друг другу, то значение right игнорируется. То же самое касается и bottom",
        " - Если left задать отрицательное значение, то слой уйдёт за левый край браузера, полосы прокрутки при этом не возникнет. Это один из способов спрятать элемент от просмотра. То же относится и к свойству top, только слой уйдёт за верхний край.",
        " - Если left задать значение больше ширины видимой области или указать right с отрицательным значением, появится горизонтальная полоса прокрутки. Подобное правило работает и с top, только речь пойдёт о вертикальной полосе прокрутки.",
        " - Одновременно указанные свойства left и right формируют ширину слоя, но только если width не указано. Стоит добавить свойство width и значение right будет проигнорировано. Аналогично произойдёт и с высотой слоя, только уже участвуют свойства top, bottom и height.",
        " - Элемент с абсолютным позиционированием перемещается вместе с документом при его прокрутке.",
        "Свойство position со значением absolute можно использовать для создания эффекта фреймов. Кроме абсолютного позиционирования для элементов необходимо назначить свойство overflow со значением auto. Тогда при превышении контентом высоты видимой области появится полоса прокрутки. Высота и ширина «фреймов» формируется автоматически путём одновременного использования свойств left, right для ширины и top, bottom для высоты ",
        " - В браузере IE6 для абсолютно позиционированных элементов нельзя одновременно задать свойства left, right и top, bottom.",
        "Абсолютное позиционирование также применяется для создания различных эффектов, например, всплывающей подсказки к фотографиям. В отличие от атрибута title тега <img> который также выводит текст подсказки, через стили можно управлять видом текста выводимого с помощью скрипта. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Фиксированное положение",
      "answer": [
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю"
      ],
      "isParagraph": true
    },
    {
      "heading": "Относительное позиционирование",
      "answer": [
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. ",
        "Свойства bottom и right производят обратный эффект. При положительном значении right сдвигает элемент влево от его правого края, при отрицательном — сдвигает вправо (рис. 3.47). При положительном значении bottom элемент поднимается вверх, при отрицательном опускается вниз.",
        "Для относительного позиционирования характерны следующие особенности ",
        " - Этот тип позиционирования не применим к элементам таблицы вроде ячеек, строк, колонок и др.",
        " - При смещении элемента относительно исходного положения, место, которое занимал элемент, остаётся пустым и не заполняется ниже или вышележащими элементами."
      ],
      "isParagraph": true
    },
    {
      "heading": "sticky - смесь relative и fixed.",
      "answer": [
        "Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент.",
        "Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow) "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вложенные слои",
      "answer": [
        "Обычно относительное позиционирование само по себе применяется не часто, поскольку есть ряд свойств выполняющих фактически ту же роль, к примеру, тот же margin. Но сочетание разных типов позиционирования для вложенных слоёв является одним из удобных и практичных приёмов вёрстки. Если для родительского элемента задать relative, а для дочернего absolute, то произойдёт смена системы координат и положение дочернего элемента при этом указывается относительно его родителя ",
        "Отсчёт координат ведётся от внутреннего края границы, значения полей не учитываются",
        "Благодаря использованию четырёх свойств left, right, top, bottom для управления положением внутреннего слоя, размеры родительского слоя знать не обязательно. Это расширяет сферу применения позиционирования, поэтому position довольно активно применяется при вёрстке различных элементов.  "
      ],
      "isParagraph": true
    },
    {
      "heading": "В чём разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?",
      "answer": [
        " - static - значение по умолчанию, позволяет элементу находиться в обычном его состоянии. Свойства top, right, bottom, left и z-index не применяются.",
        " - relative - элемент позиционируется в соответствии с потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов.",
        " - absolute - элемент выдёргивается из потока и выстраивается относительно ближайшего элемента-предка с position: relative. Если его нет, то относительно body (страницы). Абсолютно спозиционированные элементы могут иметь margin и padding и не схлопываются с margin и padding других элементов. Никак не влияют на другие элементы.",
        " - fixed - элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. С помощью top, bottom и т.д. его можно прибить соответственно сверху, снизу и т.п.. Остаётся на позиции относительно окна документа и не меняет положение при скроле.",
        " - sticky - смесь relative и fixed. Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент. Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow)"
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование CSS препроцессоров? Опишите, что вам нравится и не нравится в CSS препроцессорах, которыми вы пользовались. ",
      "answer": [" Преимущества: ", " - Вложенность. Удобно писать по БЭМу. ", " - Переменные."],
      "isParagraph": true
    },
    {
      "heading": "1. Центрирование блочного элемента ",
      "answer": [
        "Задать родителю (display: flex) ",
        "  .container { display: flex }",
        "Задать дочернему флекс-элементу (margin: auto).",
        "  .child { margin: auto }  "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. Центрирование блочного элемента",
      "answer": [
        "Задать контейнеру-родителю: .container { display: flex;  align-items: center;  justify-content: center; }"
      ],
      "isParagraph": true
    },
    {
      "heading": "3. Центрирование блочного элемента по горизонтали",
      "answer": [".child { width: 123px; margin: 12px auto }"],
      "isParagraph": true
    },
    {
      "heading": "Центрирования инлайновых элементов ",
      "answer": [
        "По горизонтали: h1 {text-align: center}",
        "По вертикали: h1 {vertical-align: middle} ",
        " ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание инлайновых элементов с помощью line-height ",
      "answer": [
        "Если известно, что внутренний блок должен занимать не более одной строки текста, то можно воспользоваться свойством line-height и задать его равным высоте внешнего блока. Поскольку контент внутреннего блока не должен переноситься на вторую строку, рекомендуется также добавить правила white-space: nowrap и overflow: hidden. ",
        " - .container { height: 200px; line-height: 200px }",
        " - .child { white-space: nowrap; overflow: hidden }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание многострочного текста",
      "answer": [
        " .container { height: 200px; line-height: 200px }",
        " .child { line-height: normal; display: inline-block; vertical-align: middle } "
      ],
      "isParagraph": true
    },
    {
      "heading": "1. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью ''растягивания'' ",
      "answer": [
        "Данный способ можно применять, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
        "Для этого нужно: ",
        " - 1. задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное;",
        " - 2. добавить внутреннему блоку правила top: 0 и bottom: 0, в результате чего он растянется на всю высоту внешнего блока;",
        " - 3. установить значение auto для вертикальных отступов внутреннего блока.",
        " .container { position: relative }",
        " .child { height: 100px; position: absolute( или fixed); top: 0; bottom: 0; margin: auto 0 }",
        "Минус данного способа — должна быть известна высота внутреннего блока. "
      ],
      "isParagraph": true
    },
    {
      "heading": "2. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью отрицательного margin-top",
      "answer": [
        "Этот способ получил широкую известность и применяется очень часто. Как и предыдущий, он применяется, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
        " - 1. Нужно задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное.",
        " - 2. Затем необходимо сдвинуть внутренний блок вниз на половину высоты внешнего блока top: 50% и поднять вверх на половину собственной высоты margin-top: (H .child / 2).",
        "  .container { position: relative } ",
        "  .child { height: 100px; position: absolute; top: 50%; margin-top: -50px }"
      ],
      "isParagraph": true
    },
    {
      "heading": "3. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью transform",
      "answer": [
        "Данный способ похож на предыдущий, но он может быть применен, когда высота внутреннего блока неизвестна.",
        "Можно использовать top: 50%, left: 50% в сочетании с translateX(-50%) translateY(-50%) для динамического горизонтального/вертикального центрирования элемента: ",
        " .container { position:relative }",
        " .child { position: absolute( или fixed);  top: 50%; left: 50%; transform: translateX(-50%) translateY(-50%) }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Выравнивание с помощью псевдоэлемента",
      "answer": [
        "Это наиболее универсальный способ, который может применяться, когда неизвестны высоты обоих блоков. ",
        "Суть способа в добавлении внутри внешнего блока строчного блока inline-block высотой в 100% и задания ему вертикального выравнивания. В этом случае высота добавленного блока будет равна высоте внешнего блока. Внутренний блок выровняется по вертикали относительно добавленного, а значит, и внешнего блока. ",
        "Чтобы не нарушать семантику, строчный блок рекомендуется добавить с помощью псевдоэлемента before или after. ",
        "  .container:before { display: inline-block; height: 100%; vertical-align: middle }",
        " .child { display: inline-block; vertical-align: middle }"
      ],
      "isParagraph": true
    },
    {
      "heading": "Запретить прокрутку страницы: document.body.style.overflow = 'hidden';",
      "answer": ["document.body.style.overflow = 'hidden';"],
      "isParagraph": true
    },
    {
      "heading": "Разрешить прокрутку страницы: document.body.style.overflow = '' ;",
      "answer": ["document.body.style.overflow = '' ; "],
      "isParagraph": true
    },
    {
      "heading": "Как стилизовать или убрать полосу прокрутки — CSS скроллбар",
      "answer": [
        "Убрать полосу прокрутки у элемента: .element::-webkit-scrollbar { width: 0; }",
        "Убрать полосу прокрутки для всей страницы: ::-webkit-scrollbar { width: 0; }",
        ".element { width: 1280px; display: flex; overflow-x: scroll; ",
        "  @media screen and (min-width: 1280px) { ",
        " overflow-x: hidden; .element::-webkit-scrollbar { width: 0; }}}"
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " "],
      "isParagraph": true
    }
  ],
  "linksArrayMethods": [
    {
      "href": "https://habr.com/ru/company/ruvds/blog/430380/",
      "title": "Руководство по JavaScript, часть 5: массивы и циклы"
    },
    {
      "href": "https://learn.javascript.ru/array",
      "title": "Массивы"
    },
    {
      "href": "https://learn.javascript.ru/array-methods",
      "title": "Методы массивов"
    },
    {
      "href": "https://habr.com/ru/company/plarium/blog/483958/",
      "title": "15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году"
    },
    {
      "href": "https://digitrain.ru/articles/272353/",
      "title": "Мутировать или не мутировать? Шпаргалка по методам массивов JavaScript"
    },
    {
      "href": "https://itchief.ru/javascript/arrays",
      "title": "Массивы в JavaScript"
    },
    {
      "href": "https://only-to-top.ru/blog/coding/2020-12-30-js-array-cheatsheet.html",
      "title": "Методы массивов"
    },
    {
      "href": "https://habr.com/ru/post/247857/",
      "title": "Все способы перебора массива в JavaScript"
    },
    {
      "href": "https://wm-school.ru/js/index.php",
      "title": "Шикарный учебник по JavaScript на русском языке"
    },
    {
      "href": "https://www.techonthenet.com/js/array_entries.php",
      "title": "Шикарный учебник по JavaScript на русском языке"
    }
  ],
  "linksDestructuring": [
    {
      "href": "https://habr.com/ru/company/otus/blog/594541/",
      "title": "Деструктуризация массивов и объектов в JavaScript — в чем разница?"
    },
    {
      "href": "https://learn.javascript.ru/destructuring-assignment",
      "title": "Деструктурирующее присваивание"
    },
    {
      "href": "https://tproger.ru/translations/delaem-kod-chishhe-s-pomoshhju-destrukturizacii-obektov-v-javascript/",
      "title": "Делаем код чище с помощью деструктуризации объектов в JavaScript"
    }
  ],
  "arrayDestructuringArrays": [
    {
      "heading": "Деструктурирующее присваивание",
      "answer": [
        "В JavaScript есть две, чаще всего используемые, структуры данных – это Object и Array.",
        " - Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.",
        " - Массивы позволяют нам собирать элементы данных в упорядоченный список.",
        "Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности. ",
        "Деструктурирующее присваивание в JavaScript — это изящный способ извлечения значений из массивов и объектов, при котором в полной мере реализуется принцип DRY (англ. Don’t repeat yourself — «Не повторяйся») ",
        "Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны. ",
        "Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. Скоро мы увидим это."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массива",
      "answer": [
        "Деструктуризация массива (англ. array destructuring) — это особый синтаксис, позволяющий извлекать значения из массива и записывать их в новые переменные с минимумом кода.",
        "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
        "Значения элементов массива копируем в новые переменные:",
        " - const [firstName, lastName, website] = profile;",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'",
        "Это и есть деструктуризация массива. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массива напрямую",
      "answer": [
        "const [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Синтаксис деструктуризации массива при необходимости объявления переменных без инициализации",
      "answer": [
        "При использовании деструктуризации массива JavaScript позволяет отдельно объявлять переменные, а уже затем присваивать им значения.",
        " - let firstName, lastName, website;",
        " - [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации массива с использованием переменной 'оператора остатка' остальной части литерала массива ",
      "answer": [
        "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
        "Если понадобится присвоить 'Oluwatobi' переменной firstName, а остальные элементы массива — другой переменной? Как это сделать?",
        "JavaScript позволяет использовать оператор остатка внутри деструктурирующего массива для присваивания переменной значений остальных элементов обычного массива.",
        " - const [firstName, ...otherInfo] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(otherInfo); // ['Sofela', 'codesweetly.com' ]",
        "Примечание: оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего массива, иначе возникнет синтаксическая ошибка (SyntaxError)"
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для извлечения значений по любому, произвольному индексу",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "А теперь представим, что нам нужно извлечь только значение 'codesweetly.com'",
        " - const [, , website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
        " - console.log(website); // 'codesweetly.com'",
        "В коде выше мы использовали запятые для пропуска переменных в первой и второй позициях деструктурирующего массива. ",
        "Таким образом нам удалось связать переменную website с третьим значением из обычного массива, указанного справа от оператора присваивания (то есть 'codesweetly.com') "
      ],
      "isParagraph": true
    },
    {
      "heading": "Как работают значения по умолчанию при использовании деструктурирующего присваивания массива",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "Иногда значение, которое требуется извлечь из массива, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем массиве значения по умолчанию. ",
        "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из массива, не существует (или имеет значение undefined). ",
        "В деструктурирующем массиве задаём значения по умолчанию: ",
        " - const [ firstName = 'Tobi', website = 'CodeSweetly' ] = [ 'Oluwatobi' ];",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(website); // 'CodeSweetly'",
        "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
        "Поэтому при попытке извлечь значение с индексом 1 из массива, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в массиве [ 'Oluwatobi' ] существует значение только с нулевым индексом. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для обмена значений переменных",
      "answer": [
        "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
        "А что если нужно поменять значение переменной firstName на значение переменной website?",
        "При помощи деструктурирующего присваивания массива можно поменять местами значения двух или нескольких переменных.",
        "Рассмотрим пример: ",
        " - let firstName = 'Oluwatobi';",
        " - let website = 'CodeSweetly';",
        " - [firstName, website] = [website, firstName]; поменяли местами значения двух переменных.",
        " - console.log(firstName); // 'CodeSweetly'",
        " - console.log(website); // 'Oluwatobi'",
        "В коде выше мы использовали прямую деструктуризацию массива для повторного присваивания переменным firstName и website значений литерала массива, указанного справа от оператора присваивания. ",
        "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi' "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации массива для извлечения значений из массива в параметры функции",
      "answer": [
        "Отметим, что деструктуризацию массива также можно использовать для извлечения значений из обычного массива в параметры функции ",
        "Ниже приводится пример использования деструктуризации массива для извлечения значения из массива в параметр функции:",
        " // Определяем массив с двумя элементами:",
        " - const profile = [ 'Oluwatobi', 'Sofela' ];",
        " // Определяем функцию с одним деструктурирующим массивом, содержащим два параметра:",
        " - function getUserBio([firstName, lastName]) {",
        " - return `My name is ${firstName} ${lastName}",
        "}",
        " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
        " - getUserBio(profile);",
        " // Приведенный выше вызов вернет:",
        " - 'My name is Oluwatobi Sofela.'",
        "В коде выше мы использовали параметр, который деструктурирует массив для извлечения значений из массива profile в параметры firstName и lastName функции getUserBio ",
        "Примечание: параметр, деструктурирующий массив, обычно называют деструктурирующим параметром. ",
        " ",
        " "
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим еще один пример использования деструктуризации массива для извлечения значений из массива в параметры функции",
      "answer": [
        " // Определяем массив с двумя строковыми значениями и одним вложенным массивом:",
        " - const profile = [ 'codesweetly.com', 'Male', [ 'Oluwatobi', 'Sofela']];",
        " // Определяем функцию с двумя деструктурирующими массивами, каждый из которых содержит параметр:",
        " - function getUserBio([website, , [userName]]) {",
        " - return `${userName} runs ${website}` ",
        "}",
        " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
        " - getUserBio(profile);",
        " // Приведенный выше вызов вернет:",
        " 'Oluwatobi runs codesweetly.com'",
        "В коде выше мы использовали два параметра, деструктурирующих массив, для извлечения значений из массива profile в параметры website и userName функции getUserBio. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вызов функции, содержащей параметры, деструктурирующие массив, без передачи ей аргументов",
      "answer": [
        "Время от времени может понадобиться вызвать функцию, содержащую деструктурирующий параметр, не передавая ей никакого аргумента. В этом случае необходимо использовать подход, при котором браузер не выдаст ошибку TypeError. ",
        " - function getUserBio([firstName]) {",
        " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
        " - return `My name is ${firstName}.`",
        "}",
        "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
        "getUserBio(); ",
        "После вызова вышеуказанной функции getUserBio браузер выдаст ошибку TypeError: (Ошибка типа: undefined невозможно итерировать). ",
        "Сообщение TypeError возникает потому, что функции, содержащие деструктурирующий параметр, ожидают, что им будет передан хотя бы один аргумент. ",
        "Однако подобных сообщений об ошибках можно избежать, назначив деструктурирующему параметру аргумент по умолчанию. ",
        " - function getUserBio([firstName] = []) {",
        " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
        " - return `My name is ${firstName}.`",
        "}",
        "Обратите внимание, что в приведенном выше коде мы присвоили пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. ",
        "Теперь снова вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр:",
        "getUserBio(); ",
        "Результат: ",
        " 'Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования' ",
        " 'My name is undefined.'",
        "Отметим, что необязательно использовать пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. Можно использовать любое другое значение, кроме null и undefined"
      ],
      "isParagraph": true
    }
  ],
  "arrayDestructuringObjects": [
    {
      "heading": "Деструктуризация объекта",
      "answer": [
        "Деструктуризация объекта (англ. object destructuring) — это особый синтаксис, позволяющий извлекать значения из объекта и записывать их в новые переменные с минимумом кода.",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }  ",
        "Делаем деструктуризацию: ",
        " const { firstName: firstName, lastName: lastName, website: website } = profile; ",
        "Получаем: ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'",
        "-------------------------- ",
        "Мы поместили три новые переменные в объект свойств ({...}) и присвоили им значения из объекта profile. ",
        "Другими словами, мы сказали компьютеру, чтобы тот извлек значения из объекта profile и записал их в переменные, указанные слева от оператора присваивания. ",
        "В результате JavaScript парсит объект profile и копирует его первое значение ('Oluwatobi') в первую переменную деструктурирующего объекта (firstName). ",
        "Аналогичным образом компьютер извлекает второе значение ('Sofela') из объекта profile и записывает его во вторую переменную (lastName) деструктурирующего объекта. ",
        "Наконец JavaScript копирует третье значение из объекта profile (codesweetly.com') в третью переменную (website) деструктурирующего объекта. ",
        "Отметим, что в { firstName: firstName, lastName: lastName, website: website } ключи являются ссылками на свойства объекта profile, при этом значения ключей представляют собой новые переменные. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация объекта, сокращенный синтаксис.",
      "answer": [
        "Также можно использовать сокращенный синтаксис, чтобы сделать код более читабельным.",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
        "Делаем деструктуризацию:",
        " const { firstName, lastName, website } = profile;",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта. Случай, когда имя свойства отличается от имени переменной ",
      "answer": [
        "Обратите внимание, что в приведенном выше коде было показано, как присвоить значение из объекта переменной в случае, когда свойство объекта и переменная имеют одинаковые имена.",
        "Однако можно присвоить значение свойства и переменной с другим именем. Давайте посмотрим как. ",
        "-------------------------- ",
        "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
        "Делаем деструктуризацию:",
        " const { firstName: forename, lastName: surname, website: onlineSite } = profile; ",
        " - console.log(forename); // 'Oluwatobi'",
        " - console.log(surname); // 'Sofela'",
        " - console.log(onlineSite); // 'codesweetly.com'",
        " - console.log(website); // 'ReferenceError: website не определен'",
        "В приведенном выше коде компьютер успешно извлек значения из объекта profile и определил их в переменные с именами forename, surname и onlineSite, несмотря на то что свойства и переменные имеют разные имена. ",
        "-------------------------- ",
        "const profile = { lastName: { familyName: 'Sofela' } }; ",
        "const { lastName: { familyName: surname } } = profile; ",
        "console.log(surname); // 'Sofela' ",
        "В приведенном выше коде компьютер успешно извлек значения из объекта profile в переменную с именем surname, несмотря на то что свойство и переменная имеют разные имена. ",
        "-------------------------- ",
        "Примечание: const { lastName: { familyName: surname } } = profile — это эквивалент const surname = profile.lastName.familyName "
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация объекта напрямую",
      "answer": [
        "Обратите внимание, что мы деструктурировали объект profile путем ссылки на него. Однако деструктуризацию объекта можно делать и напрямую. ",
        "Прямая деструктуризация объекта:",
        "-------------------------- ",
        "const { firstName, lastName, website } = {",
        " firstName: 'Oluwatobi',",
        " lastName: 'Sofela',",
        " website: 'codesweetly.com' }",
        "-------------------------- ",
        " - console.log(firstName); // 'Oluwatobi'",
        " - console.log(lastName); // 'Sofela'",
        " - console.log(website); // 'codesweetly.com'"
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта, объявление переменных без инициализации",
      "answer": [
        "Предположим, необходимо объявлять переменные в одном месте, а присваивать им значения — в другом. При использовании деструктуризации объекта JavaScript позволяет отделять объявление переменных от присваивания им значений.",
        "// Объявляем три переменные: ",
        " - let firstName, lastName, website;",
        "// Извлекаем значения для трех переменных выше: ",
        "({ firstName, lastName, website } = {",
        " - firstName: 'Oluwatobi',",
        " - lastName: 'Sofela',",
        " - website: 'codesweetly.com'",
        " });",
        "-------------------------- ",
        "Примечание: ",
        "1. Деструктурирующее присваивание объекта нужно обязательно заключать в круглые скобки, чтобы компьютер понимал, что деструктуризация объекта — это литерал объекта, а не блок",
        "2. После круглых скобок деструктурирующего присваивания объекта необходимо ставить точку с запятой (;). Тогда компьютер не будет интерпретировать круглые скобки как вызов функции, которая могла находиться на предыдущей строке."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризации объекта с использованием переменной 'оператора остатка' остальной части объекта",
      "answer": [
        "А что если понадобится присвоить значение 'Oluwatobi' переменной firstName, а остальные значения из объекта — другой переменной? ",
        "JavaScript позволяет использовать оператор остатка внутри деструктурирующего объекта для присваивания переменной значений из остальной части литерала объекта.",
        "-------------------------- ",
        "const { firstName, ...otherInfo } = {",
        " - firstName: 'Oluwatobi',",
        " - lastName: 'Sofela',",
        " - website: 'codesweetly.com'",
        " }; ",
        " console.log(firstName); // 'Oluwatobi'",
        " console.log(otherInfo); // {lastName: 'Sofela', website: 'codesweetly.com'}",
        "-------------------------- ",
        "Примечание: ",
        " оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего объекта, иначе возникнет синтаксическая ошибка (SyntaxError). "
      ],
      "isParagraph": true
    },
    {
      "heading": "Как работают значения по умолчанию при использовании деструктурирующего присваивания объекта",
      "answer": [
        "Однако иногда значение, которое требуется извлечь из объекта со свойствами, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем объекте значения по умолчанию. Рассмотрим этот случай подробнее",
        "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из объекта, не существует (или имеет значение undefined). ",
        "Ниже показано, как в деструктурирующем объекте со свойствами задаются значения по умолчанию: ",
        "-------------------------- ",
        "const { firstName = 'Tobi', website = 'CodeSweetly' } = { ",
        " firstName: 'Oluwatobi' ",
        "}; ",
        "console.log(firstName); // 'Oluwatobi' ",
        "console.log(website); // 'CodeSweetly' ",
        "-------------------------- ",
        "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
        "Поэтому при попытке извлечь значение второго свойства объекта, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в {firstName: 'Oluwatobi'} присутствует только одно свойство. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации объекта для обмена значений переменных",
      "answer": [
        "А что если нужно поменять значение переменной firstName на значение переменной website?",
        "При помощи деструктурирующего присваивания объекта можно поменять местами значения двух или нескольких переменны ",
        "-------------------------- ",
        "let firstName = 'Oluwatobi'; ",
        "let website = 'CodeSweetly'; ",
        "({ firstName, website } = {firstName: website, website: firstName}); ",
        "console.log(firstName); // 'CodeSweetly' ",
        "console.log(website); // 'Oluwatobi' ",
        "-------------------------- ",
        "В коде выше мы использовали прямую деструктуризацию объекта для повторного присваивания переменным firstName и website значений литерала объекта, указанного справа от оператора присваивания. ",
        "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi'. "
      ],
      "isParagraph": true
    },
    {
      "heading": "Использование деструктуризации объекта для извлечения значений из свойств в параметры функции",
      "answer": [
        "Отметим, что деструктуризацию объекта также можно использовать для извлечения значений из свойств в параметры функции.",
        "Ниже приводится пример использования деструктуризации объекта для копирования значения свойства в параметр функции: ",
        "// Определяем объект с двумя свойствами: ",
        "const profile = {",
        " - firstName: 'Oluwatobi', ",
        " - lastName: 'Sofela',",
        "};",
        "// Определяем функцию с одним объектом деструктурирования, содержащим два параметра: ",
        "function getUserBio({ firstName, lastName }) {",
        " - return `My name is ${firstName} ${lastName}.`; ",
        "} ",
        "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
        "getUserBio(profile); ",
        "// Приведенный выше вызов вернет: ",
        "'My name is Oluwatobi Sofela.' ",
        "В коде выше мы использовали параметр, который деструктурирует объект для копирования значений из объекта profile в параметры firstName и lastName функции getUserBio. ",
        "Примечание: параметр, деструктурирующий объект, обычно называют деструктурирующим параметром."
      ],
      "isParagraph": true
    },
    {
      "heading": "Рассмотрим еще один пример: ",
      "answer": [
        "// Определяем объект с тремя родительскими свойствами: ",
        "const profile = { website: 'codesweetly.com', gender: 'Male', fullName: { firstName: 'Oluwatobi', lastName: 'Sofela' }}; ",
        "// Определяем функцию с двумя деструктурирующими объектами, каждый из которых содержит параметр: ",
        "function getUserBio({ website, fullName: { firstName: userName } }) { ",
        "return `${userName} runs ${website}`;",
        "} ",
        "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
        "getUserBio(profile); ",
        "// Приведенный выше вызов вернет: ",
        " 'Oluwatobi runs codesweetly.com'",
        "В коде выше мы использовали два деструктурирующих параметра для копирования значений из объекта profile в параметры website и userName функции getUserBio "
      ],
      "isParagraph": true
    },
    {
      "heading": "Вызов функции, содержащей деструктурированные параметры, без передачи ей аргументов",
      "answer": [
        "function getUserBio({ firstName } = {}) { ",
        " console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования'); ",
        " return `My name is ${firstName}.`;",
        "}",
        "Обратите внимание, что в приведенном выше коде мы присвоили пустой объект в качестве аргумента по умолчанию для деструктурирующего параметра. ",
        "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
        "getUserBio(); ",
        "'Do something else that does not need the destructuring parameter.'",
        "My name is undefined."
      ],
      "isParagraph": true
    },
    {
      "heading": "Деструктуризация массивов и объектов. Резюме",
      "answer": [
        "Деструктуризация массивов и объектов выполняется схожим образом. Основное различие между двумя деструктурирующими присваиваниями заключается, собственно, в том, что при деструктуризации массива значения извлекаются из массива, а при деструктуризации объекта — из объекта JavaScript. "
      ],
      "isParagraph": true
    },
    {
      "heading": " ",
      "answer": [" ", " ", " ", " "],
      "isParagraph": true
    }
  ]
}

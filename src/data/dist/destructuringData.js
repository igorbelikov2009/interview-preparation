"use strict";
exports.__esModule = true;
exports.arrayDestructuringObjects = exports.arrayDestructuringArrays = exports.linksDestructuring = void 0;
exports.linksDestructuring = [
    {
        href: "https://habr.com/ru/company/otus/blog/594541/",
        title: "Деструктуризация массивов и объектов в JavaScript — в чем разница?"
    },
    {
        href: "https://learn.javascript.ru/destructuring-assignment",
        title: "Деструктурирующее присваивание"
    },
    {
        href: "https://tproger.ru/translations/delaem-kod-chishhe-s-pomoshhju-destrukturizacii-obektov-v-javascript/",
        title: "Делаем код чище с помощью деструктуризации объектов в JavaScript"
    },
];
exports.arrayDestructuringArrays = [
    {
        heading: "Деструктурирующее присваивание",
        answer: [
            "В JavaScript есть две, чаще всего используемые, структуры данных – это Object и Array.",
            " - Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.",
            " - Массивы позволяют нам собирать элементы данных в упорядоченный список.",
            "Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности. ",
            "Деструктурирующее присваивание в JavaScript — это изящный способ извлечения значений из массивов и объектов, при котором в полной мере реализуется принцип DRY (англ. Don’t repeat yourself — «Не повторяйся») ",
            "Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны. ",
            "Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. Скоро мы увидим это.",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризация массива",
        answer: [
            "Деструктуризация массива (англ. array destructuring) — это особый синтаксис, позволяющий извлекать значения из массива и записывать их в новые переменные с минимумом кода.",
            "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
            "Значения элементов массива копируем в новые переменные:",
            " - const [firstName, lastName, website] = profile;",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
            "Это и есть деструктуризация массива. ",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризация массива напрямую",
        answer: [
            "const [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
        ],
        isParagraph: true
    },
    {
        heading: "Синтаксис деструктуризации массива при необходимости объявления переменных без инициализации",
        answer: [
            "При использовании деструктуризации массива JavaScript позволяет отдельно объявлять переменные, а уже затем присваивать им значения.",
            " - let firstName, lastName, website;",
            " - [firstName, lastName, website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризации массива с использованием переменной 'оператора остатка' остальной части литерала массива ",
        answer: [
            "Имеем массив const profile = ['Oluwatobi', 'Sofela', 'codesweetly.com']; ",
            "Если понадобится присвоить 'Oluwatobi' переменной firstName, а остальные элементы массива — другой переменной? Как это сделать?",
            "JavaScript позволяет использовать оператор остатка внутри деструктурирующего массива для присваивания переменной значений остальных элементов обычного массива.",
            " - const [firstName, ...otherInfo] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(otherInfo); // ['Sofela', 'codesweetly.com' ]",
            "Примечание: оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего массива, иначе возникнет синтаксическая ошибка (SyntaxError)",
        ],
        isParagraph: true
    },
    {
        heading: "Использование деструктуризации массива для извлечения значений по любому, произвольному индексу",
        answer: [
            "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
            "А теперь представим, что нам нужно извлечь только значение 'codesweetly.com'",
            " - const [, , website] = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ];",
            " - console.log(website); // 'codesweetly.com'",
            "В коде выше мы использовали запятые для пропуска переменных в первой и второй позициях деструктурирующего массива. ",
            "Таким образом нам удалось связать переменную website с третьим значением из обычного массива, указанного справа от оператора присваивания (то есть 'codesweetly.com') ",
        ],
        isParagraph: true
    },
    {
        heading: "Как работают значения по умолчанию при использовании деструктурирующего присваивания массива",
        answer: [
            "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
            "Иногда значение, которое требуется извлечь из массива, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем массиве значения по умолчанию. ",
            "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из массива, не существует (или имеет значение undefined). ",
            "В деструктурирующем массиве задаём значения по умолчанию: ",
            " - const [ firstName = 'Tobi', website = 'CodeSweetly' ] = [ 'Oluwatobi' ];",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(website); // 'CodeSweetly'",
            "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
            "Поэтому при попытке извлечь значение с индексом 1 из массива, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в массиве [ 'Oluwatobi' ] существует значение только с нулевым индексом. ",
        ],
        isParagraph: true
    },
    {
        heading: "Использование деструктуризации массива для обмена значений переменных",
        answer: [
            "Имеем массив const profile = [ 'Oluwatobi', 'Sofela', 'codesweetly.com' ]; ",
            "А что если нужно поменять значение переменной firstName на значение переменной website?",
            "При помощи деструктурирующего присваивания массива можно поменять местами значения двух или нескольких переменных.",
            "Рассмотрим пример: ",
            " - let firstName = 'Oluwatobi';",
            " - let website = 'CodeSweetly';",
            " - [firstName, website] = [website, firstName]; поменяли местами значения двух переменных.",
            " - console.log(firstName); // 'CodeSweetly'",
            " - console.log(website); // 'Oluwatobi'",
            "В коде выше мы использовали прямую деструктуризацию массива для повторного присваивания переменным firstName и website значений литерала массива, указанного справа от оператора присваивания. ",
            "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi' ",
        ],
        isParagraph: true
    },
    {
        heading: "Использование деструктуризации массива для извлечения значений из массива в параметры функции",
        answer: [
            "Отметим, что деструктуризацию массива также можно использовать для извлечения значений из обычного массива в параметры функции ",
            "Ниже приводится пример использования деструктуризации массива для извлечения значения из массива в параметр функции:",
            " // Определяем массив с двумя элементами:",
            " - const profile = [ 'Oluwatobi', 'Sofela' ];",
            " // Определяем функцию с одним деструктурирующим массивом, содержащим два параметра:",
            " - function getUserBio([firstName, lastName]) {",
            " - return `My name is ${firstName} ${lastName}",
            "}",
            " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
            " - getUserBio(profile);",
            " // Приведенный выше вызов вернет:",
            " - 'My name is Oluwatobi Sofela.'",
            "В коде выше мы использовали параметр, который деструктурирует массив для извлечения значений из массива profile в параметры firstName и lastName функции getUserBio ",
            "Примечание: параметр, деструктурирующий массив, обычно называют деструктурирующим параметром. ",
            " ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Рассмотрим еще один пример использования деструктуризации массива для извлечения значений из массива в параметры функции",
        answer: [
            " // Определяем массив с двумя строковыми значениями и одним вложенным массивом:",
            " - const profile = [ 'codesweetly.com', 'Male', [ 'Oluwatobi', 'Sofela']];",
            " // Определяем функцию с двумя деструктурирующими массивами, каждый из которых содержит параметр:",
            " - function getUserBio([website, , [userName]]) {",
            " - return `${userName} runs ${website}` ",
            "}",
            " // Вызываем getUserBio при передаче массива профилей в качестве аргумента:",
            " - getUserBio(profile);",
            " // Приведенный выше вызов вернет:",
            " 'Oluwatobi runs codesweetly.com'",
            "В коде выше мы использовали два параметра, деструктурирующих массив, для извлечения значений из массива profile в параметры website и userName функции getUserBio. ",
        ],
        isParagraph: true
    },
    {
        heading: "Вызов функции, содержащей параметры, деструктурирующие массив, без передачи ей аргументов",
        answer: [
            "Время от времени может понадобиться вызвать функцию, содержащую деструктурирующий параметр, не передавая ей никакого аргумента. В этом случае необходимо использовать подход, при котором браузер не выдаст ошибку TypeError. ",
            " - function getUserBio([firstName]) {",
            " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
            " - return `My name is ${firstName}.`",
            "}",
            "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
            "getUserBio(); ",
            "После вызова вышеуказанной функции getUserBio браузер выдаст ошибку TypeError: (Ошибка типа: undefined невозможно итерировать). ",
            "Сообщение TypeError возникает потому, что функции, содержащие деструктурирующий параметр, ожидают, что им будет передан хотя бы один аргумент. ",
            "Однако подобных сообщений об ошибках можно избежать, назначив деструктурирующему параметру аргумент по умолчанию. ",
            " - function getUserBio([firstName] = []) {",
            " - console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования') ",
            " - return `My name is ${firstName}.`",
            "}",
            "Обратите внимание, что в приведенном выше коде мы присвоили пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. ",
            "Теперь снова вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр:",
            "getUserBio(); ",
            "Результат: ",
            " 'Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования' ",
            " 'My name is undefined.'",
            "Отметим, что необязательно использовать пустой массив в качестве аргумента по умолчанию для деструктурирующего параметра. Можно использовать любое другое значение, кроме null и undefined",
        ],
        isParagraph: true
    },
];
exports.arrayDestructuringObjects = [
    {
        heading: "Деструктуризация объекта",
        answer: [
            "Деструктуризация объекта (англ. object destructuring) — это особый синтаксис, позволяющий извлекать значения из объекта и записывать их в новые переменные с минимумом кода.",
            "-------------------------- ",
            "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }  ",
            "Делаем деструктуризацию: ",
            " const { firstName: firstName, lastName: lastName, website: website } = profile; ",
            "Получаем: ",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
            "-------------------------- ",
            "Мы поместили три новые переменные в объект свойств ({...}) и присвоили им значения из объекта profile. ",
            "Другими словами, мы сказали компьютеру, чтобы тот извлек значения из объекта profile и записал их в переменные, указанные слева от оператора присваивания. ",
            "В результате JavaScript парсит объект profile и копирует его первое значение ('Oluwatobi') в первую переменную деструктурирующего объекта (firstName). ",
            "Аналогичным образом компьютер извлекает второе значение ('Sofela') из объекта profile и записывает его во вторую переменную (lastName) деструктурирующего объекта. ",
            "Наконец JavaScript копирует третье значение из объекта profile (codesweetly.com') в третью переменную (website) деструктурирующего объекта. ",
            "Отметим, что в { firstName: firstName, lastName: lastName, website: website } ключи являются ссылками на свойства объекта profile, при этом значения ключей представляют собой новые переменные. ",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризация объекта, сокращенный синтаксис.",
        answer: [
            "Также можно использовать сокращенный синтаксис, чтобы сделать код более читабельным.",
            "-------------------------- ",
            "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
            "Делаем деструктуризацию:",
            " const { firstName, lastName, website } = profile;",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризации объекта. Случай, когда имя свойства отличается от имени переменной ",
        answer: [
            "Обратите внимание, что в приведенном выше коде было показано, как присвоить значение из объекта переменной в случае, когда свойство объекта и переменная имеют одинаковые имена.",
            "Однако можно присвоить значение свойства и переменной с другим именем. Давайте посмотрим как. ",
            "-------------------------- ",
            "Определяем объект const profile = { firstName: 'Oluwatobi', lastName: 'Sofela', website: 'codesweetly.com' }",
            "Делаем деструктуризацию:",
            " const { firstName: forename, lastName: surname, website: onlineSite } = profile; ",
            " - console.log(forename); // 'Oluwatobi'",
            " - console.log(surname); // 'Sofela'",
            " - console.log(onlineSite); // 'codesweetly.com'",
            " - console.log(website); // 'ReferenceError: website не определен'",
            "В приведенном выше коде компьютер успешно извлек значения из объекта profile и определил их в переменные с именами forename, surname и onlineSite, несмотря на то что свойства и переменные имеют разные имена. ",
            "-------------------------- ",
            "const profile = { lastName: { familyName: 'Sofela' } }; ",
            "const { lastName: { familyName: surname } } = profile; ",
            "console.log(surname); // 'Sofela' ",
            "В приведенном выше коде компьютер успешно извлек значения из объекта profile в переменную с именем surname, несмотря на то что свойство и переменная имеют разные имена. ",
            "-------------------------- ",
            "Примечание: const { lastName: { familyName: surname } } = profile — это эквивалент const surname = profile.lastName.familyName ",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризация объекта напрямую",
        answer: [
            "Обратите внимание, что мы деструктурировали объект profile путем ссылки на него. Однако деструктуризацию объекта можно делать и напрямую. ",
            "Прямая деструктуризация объекта:",
            "-------------------------- ",
            "const { firstName, lastName, website } = {",
            " firstName: 'Oluwatobi',",
            " lastName: 'Sofela',",
            " website: 'codesweetly.com' }",
            "-------------------------- ",
            " - console.log(firstName); // 'Oluwatobi'",
            " - console.log(lastName); // 'Sofela'",
            " - console.log(website); // 'codesweetly.com'",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризации объекта, объявление переменных без инициализации",
        answer: [
            "Предположим, необходимо объявлять переменные в одном месте, а присваивать им значения — в другом. При использовании деструктуризации объекта JavaScript позволяет отделять объявление переменных от присваивания им значений.",
            "// Объявляем три переменные: ",
            " - let firstName, lastName, website;",
            "// Извлекаем значения для трех переменных выше: ",
            "({ firstName, lastName, website } = {",
            " - firstName: 'Oluwatobi',",
            " - lastName: 'Sofela',",
            " - website: 'codesweetly.com'",
            " });",
            "-------------------------- ",
            "Примечание: ",
            "1. Деструктурирующее присваивание объекта нужно обязательно заключать в круглые скобки, чтобы компьютер понимал, что деструктуризация объекта — это литерал объекта, а не блок",
            "2. После круглых скобок деструктурирующего присваивания объекта необходимо ставить точку с запятой (;). Тогда компьютер не будет интерпретировать круглые скобки как вызов функции, которая могла находиться на предыдущей строке.",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризации объекта с использованием переменной 'оператора остатка' остальной части объекта",
        answer: [
            "А что если понадобится присвоить значение 'Oluwatobi' переменной firstName, а остальные значения из объекта — другой переменной? ",
            "JavaScript позволяет использовать оператор остатка внутри деструктурирующего объекта для присваивания переменной значений из остальной части литерала объекта.",
            "-------------------------- ",
            "const { firstName, ...otherInfo } = {",
            " - firstName: 'Oluwatobi',",
            " - lastName: 'Sofela',",
            " - website: 'codesweetly.com'",
            " }; ",
            " console.log(firstName); // 'Oluwatobi'",
            " console.log(otherInfo); // {lastName: 'Sofela', website: 'codesweetly.com'}",
            "-------------------------- ",
            "Примечание: ",
            " оператор остатка всегда следует указывать в качестве последнего элемента деструктурирующего объекта, иначе возникнет синтаксическая ошибка (SyntaxError). ",
        ],
        isParagraph: true
    },
    {
        heading: "Как работают значения по умолчанию при использовании деструктурирующего присваивания объекта",
        answer: [
            "Однако иногда значение, которое требуется извлечь из объекта со свойствами, является undefined. В этом случае JavaScript предоставляет возможность установить в деструктурирующем объекте значения по умолчанию. Рассмотрим этот случай подробнее",
            "Установить значения по умолчанию может быть полезно на тот случай, если значение, которое требуется извлечь из объекта, не существует (или имеет значение undefined). ",
            "Ниже показано, как в деструктурирующем объекте со свойствами задаются значения по умолчанию: ",
            "-------------------------- ",
            "const { firstName = 'Tobi', website = 'CodeSweetly' } = { ",
            " firstName: 'Oluwatobi' ",
            "}; ",
            "console.log(firstName); // 'Oluwatobi' ",
            "console.log(website); // 'CodeSweetly' ",
            "-------------------------- ",
            "В коде выше мы задали 'Tobi' и 'CodeSweetly' в качестве значений по умолчанию для переменных firstName и website. ",
            "Поэтому при попытке извлечь значение второго свойства объекта, указанного в правой части, компьютер по умолчанию выводит 'CodeSweetly', поскольку в {firstName: 'Oluwatobi'} присутствует только одно свойство. ",
        ],
        isParagraph: true
    },
    {
        heading: "Использование деструктуризации объекта для обмена значений переменных",
        answer: [
            "А что если нужно поменять значение переменной firstName на значение переменной website?",
            "При помощи деструктурирующего присваивания объекта можно поменять местами значения двух или нескольких переменны ",
            "-------------------------- ",
            "let firstName = 'Oluwatobi'; ",
            "let website = 'CodeSweetly'; ",
            "({ firstName, website } = {firstName: website, website: firstName}); ",
            "console.log(firstName); // 'CodeSweetly' ",
            "console.log(website); // 'Oluwatobi' ",
            "-------------------------- ",
            "В коде выше мы использовали прямую деструктуризацию объекта для повторного присваивания переменным firstName и website значений литерала объекта, указанного справа от оператора присваивания. ",
            "Таким образом значение переменной firstName изменится с 'Oluwatobi' на 'CodeSweetly'. В то же время значение переменной website изменится с 'CodeSweetly' на 'Oluwatobi'. ",
        ],
        isParagraph: true
    },
    {
        heading: "Использование деструктуризации объекта для извлечения значений из свойств в параметры функции",
        answer: [
            "Отметим, что деструктуризацию объекта также можно использовать для извлечения значений из свойств в параметры функции.",
            "Ниже приводится пример использования деструктуризации объекта для копирования значения свойства в параметр функции: ",
            "// Определяем объект с двумя свойствами: ",
            "const profile = {",
            " - firstName: 'Oluwatobi', ",
            " - lastName: 'Sofela',",
            "};",
            "// Определяем функцию с одним объектом деструктурирования, содержащим два параметра: ",
            "function getUserBio({ firstName, lastName }) {",
            " - return `My name is ${firstName} ${lastName}.`; ",
            "} ",
            "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
            "getUserBio(profile); ",
            "// Приведенный выше вызов вернет: ",
            "'My name is Oluwatobi Sofela.' ",
            "В коде выше мы использовали параметр, который деструктурирует объект для копирования значений из объекта profile в параметры firstName и lastName функции getUserBio. ",
            "Примечание: параметр, деструктурирующий объект, обычно называют деструктурирующим параметром.",
        ],
        isParagraph: true
    },
    {
        heading: "Рассмотрим еще один пример: ",
        answer: [
            "// Определяем объект с тремя родительскими свойствами: ",
            "const profile = { website: 'codesweetly.com', gender: 'Male', fullName: { firstName: 'Oluwatobi', lastName: 'Sofela' }}; ",
            "// Определяем функцию с двумя деструктурирующими объектами, каждый из которых содержит параметр: ",
            "function getUserBio({ website, fullName: { firstName: userName } }) { ",
            "return `${userName} runs ${website}`;",
            "} ",
            "// Вызываем getUserBio, в качестве аргумента передаём объект profile: ",
            "getUserBio(profile); ",
            "// Приведенный выше вызов вернет: ",
            " 'Oluwatobi runs codesweetly.com'",
            "В коде выше мы использовали два деструктурирующих параметра для копирования значений из объекта profile в параметры website и userName функции getUserBio ",
        ],
        isParagraph: true
    },
    {
        heading: "Вызов функции, содержащей деструктурированные параметры, без передачи ей аргументов",
        answer: [
            "function getUserBio({ firstName } = {}) { ",
            " console.log('Сделайте что-нибудь еще, для чего не нужен параметр деструктурирования'); ",
            " return `My name is ${firstName}.`;",
            "}",
            "Обратите внимание, что в приведенном выше коде мы присвоили пустой объект в качестве аргумента по умолчанию для деструктурирующего параметра. ",
            "Теперь вызовем функцию getUserBio, не передавая никакого аргумента в ее деструктурирующий параметр: ",
            "getUserBio(); ",
            "'Do something else that does not need the destructuring parameter.'",
            "My name is undefined.",
        ],
        isParagraph: true
    },
    {
        heading: "Деструктуризация массивов и объектов. Резюме",
        answer: [
            "Деструктуризация массивов и объектов выполняется схожим образом. Основное различие между двумя деструктурирующими присваиваниями заключается, собственно, в том, что при деструктуризации массива значения извлекаются из массива, а при деструктуризации объекта — из объекта JavaScript. ",
        ],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " "],
        isParagraph: true
    },
];

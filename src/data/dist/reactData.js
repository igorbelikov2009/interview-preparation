"use strict";
exports.__esModule = true;
exports.arrayReact = exports.linksReactPage = void 0;
exports.linksReactPage = [
    {
        href: "https://frontend-stuff.com/blog/tags/react/",
        title: "Frontend Stuff. 24 статей с категорией “React "
    },
    {
        href: "https://frontend-stuff.com/blog/common-mistakes-with-react-testing-library/",
        title: "Frontend Stuff. React Testing Library "
    },
    {
        href: "https://ru.reactjs.org/docs/getting-started.html",
        title: "Официальный справочник React на русском языке."
    },
    {
        href: "https://reactdev.ru/ ",
        title: "Справочник React на русском языке."
    },
    {
        href: "https://reactdev.ru/handbook/tutorial/ ",
        title: "Документация по React (на русском языке). React – это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами»."
    },
    {
        href: "https://reactdev.ru/types/ ",
        title: "React и Typescript (на русском языке). Типизация библиотеки React с помощью Typescript: Типизированный React, Функциональные компоненты, Классовые компоненты, Универсальные компоненты, Типизированные хуки, Контекст (Context), HOC (Higher-Order Components)."
    },
    {
        href: "https://reactdev.ru/libs/cra/",
        title: "Create React App (CRA на русском языке) - это интерфейс командной строки (command line interface, CLI), позволяющий создавать предварительно настроенные React-проекты. Предварительная настройка включает в себя, но не исчерпывается, настройкой Webpack и Babel."
    },
    {
        href: "https://reactdev.ru/graphql/ ",
        title: "GraphQL (на русском языке) — это язык запросов к API и среда выполнения этих запросов с имеющимися данными. GraphQL обеспечивает полное и понятное описание данных в вашем API, дает клиентам возможность запрашивать именно то, что им нужно, упрощает обновление API-интерфейсов и предоставляет мощные инструменты для разработчиков "
    },
    {
        href: "https://reactdev.ru/questions/#shouldcomponentupdate",
        title: "Вопросы про React на собеседовании. Частые вопросы и ответы про React, задаваемые на собеседованиях "
    },
    {
        href: "https://reactdev.ru/libs/react-router/",
        title: "Справочник React на русском языке. React Router DOM. React Router. Маршрутизатор"
    },
    {
        href: "https://reactdev.ru/libs/redux/ ",
        title: "Redux. Библиотека управления состоянием. Документация redux (на русском языке)."
    },
    {
        href: "https://reactdev.ru/libs/redux-toolkit/",
        title: "Redux Toolkit. Пакет (на русском языке), облегчающий работу с Redux "
    },
    {
        href: "https://habr.com/ru/post/498860/",
        title: "Введение в Redux & React-redux "
    },
    {
        href: "https://reactdev.ru/libs/recoil/",
        title: "Recoil - это новый инструмент (на русском языке) для управления состоянием в React-приложениях "
    },
    {
        href: "https://reactdev.ru/libs/react-query/",
        title: "React Query. Библиотека (на русском языке) для получения, кэширования, синхронизации и обновления 'серверного' состояния в React-приложениях "
    },
    {
        href: "https://reactdev.ru/libs/react-spring/",
        title: "React Spring. Библиотека для анимации интерфейсов (на русском языке)"
    },
    {
        href: "https://reactdev.ru/libs/styled-components/#_1",
        title: "Styled Components. Шпаргалка по библиотеке стилизации (на русском языке)"
    },
    {
        href: "https://reactdev.ru/libs/xstate/",
        title: "XState. Библиотека для управления конечными автоматами (на русском языке):  Базовая библиотека конечных автоматов и диаграмм состояний + интерпретатор, Минимальная библиотека конечных автоматов, Утилиты обхода графа для XState, React xуки и утилиты для использования XState в приложениях React, Функции композиции и утилиты Vue для использования XState в приложениях Vue, Утилиты Svelte для использования XState в приложениях Svelte, Утилиты Model-Based-Testing (с использованием XState) для тестирования любого программного обеспечения, Утилиты разработчика (проверки) для XState."
    },
    {
        href: "https://react-hook-form.com/",
        title: "React Hook Form. Валидация форм."
    },
    {
        href: "https://www.youtube.com/watch?v=Jxfun6Jnt5Q",
        title: "Валидация форм с react-hook-form в React-приложениях. Михаил Непомнящий. "
    },
    {
        href: "https://www.youtube.com/watch?v=Nicadhseqos&t=82s",
        title: "Zod для валидации API и форм. Михаил Непомнящий."
    },
    {
        href: "https://mobx.js.org/react-integration.html",
        title: "MobX and React"
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/674",
        title: "MobX — управление состоянием приложения"
    },
    {
        href: "https://www.npmjs.com/package/mobx-react-lite",
        title: "npm i mobx-react-lite"
    },
    {
        href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
        title: "Использование Axios с React"
    },
    {
        href: "https://ru.reactjs.org/docs/hooks-reference.html",
        title: "Справочник API хуков React"
    },
    {
        href: "https://fettblog.eu/typescript-react/hooks/",
        title: "TypeScript и React: хуки"
    },
    {
        href: "https://create-react-app.dev/docs/adding-typescript/",
        title: "npx create-react-app my-app --template typescript"
    },
    {
        href: "https://reactcommunity.org/react-transition-group/transition-group",
        title: "React Transition Group"
    },
    {
        href: "https://www.npmjs.com/package/react-transition-group?activeTab=versions",
        title: "npm i react-transition-group"
    },
    {
        href: "https://www.npmjs.com/package/react-router-dom",
        title: "npm i react-router-dom (6.9.0)"
    },
    {
        href: "https://www.npmjs.com/package/react-router-dom/v/5.3.3",
        title: "npm i react-router-dom@5.3.3"
    },
    {
        href: "https://habr.com/ru/company/kts/blog/598835/",
        title: "Что нового в react-router v6"
    },
    {
        href: "https://www.youtube.com/playlist?list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE",
        title: "React Router v6. Михаил Непомнящий. 10 видео "
    },
    {
        href: "https://www.npmjs.com/package/@types/react-router-dom",
        title: "npm i @types/react-router-dom  npm install --save @types/react-router-dom (types)"
    },
    {
        href: "https://betterprogramming.pub/12-react-hooks-every-react-developer-should-know-9c6352b81329",
        title: "12 хуков React, которые должен знать каждый разработчик React"
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/717",
        title: "React и Redux вместе. Часть 1 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/718",
        title: "React и Redux вместе. Часть 2 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/719",
        title: "React и Redux вместе. Часть 3 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/720",
        title: "React и Redux вместе. Часть 4 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/721",
        title: "React и Redux вместе. Часть 5 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/722",
        title: "React и Redux вместе. Часть 6 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/723",
        title: "React и Redux вместе. Часть 7 из 7 "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/640",
        title: "Использование хуков. Часть 1 из 3. useState(), useEffect(), useRef(), "
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/643",
        title: "Использование хуков. Часть 2 из 3. useContext(), useLayoutEffect(), useCallback(),  useMemo(), useImperativeHandle(), useReducer()."
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/658",
        title: "Хук useCallback() и массив зависимости."
    },
    {
        href: "https://tokmakov.msk.ru/blog/item/644",
        title: "Использование хуков. Часть 3 из 3. Правила хуков, пользовательские хуки: usePrevious(), useLocalStorage(), usePageBottom(), useCounter(), useMergedState(), useEventListener(), useWhatCausedRender(), useDebounce(), useThrottle(), useAsync(), useIsMountedRef(), useWindowSize(), useHistory(), useElementSize(), useHovered(), useInterval(), useTimeout(), useUpdateEffect(), "
    },
    {
        href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
        title: "Использование Axios с React"
    },
    {
        href: "https://react-spring-io.vercel.app/hooks/use-transition",
        title: "Анимация перехода между страницами в React SPA с react-spring Transitioning. В hooks use-transition выбираем: Transitioning between routes"
    },
    {
        href: "https://react-spring.dev/docs/getting-started",
        title: "React Spring — это библиотека "
    },
    {
        href: "https://www.npmjs.com/package/react-spring",
        title: "Установка анимации react-spring npm i react-spring "
    },
    {
        href: "https://www.youtube.com/watch?v=BSmXK6z0h3s&t=942s",
        title: "Анимация перехода между страницами в React SPA с react-spring"
    },
    {
        href: "https://stasonmars.ru/javascript/pogruzhaemsya-v-raboty-s-children-na-react/",
        title: "Погружаемся в работу с children на React"
    },
    {
        href: "https://habr.com/ru/post/319270/",
        title: "JSX — подробности"
    },
    {
        href: "https://www.youtube.com/watch?v=DLFzz2Wldxg",
        title: "React. Props Children"
    },
    {
        href: "https://www.8host.com/blog/kak-ispolzovat-axios-v-react/",
        title: "КАК ИСПОЛЬЗОВАТЬ AXIOS В REACT"
    },
    {
        href: "https://translated.turbopages.org/proxy_u/en-ru.ru.cb273f24-642bd6b1-73b932d8-74722d776562/https/www.freecodecamp.org/news/react-useeffect-absolute-beginners/  ",
        title: "React useEffect Hook для абсолютных новичков."
    },
    {
        href: "https://www.trio.dev/blog/7-top-react-state-management-libraries",
        title: "7 лучших библиотек управления состоянием React"
    },
    {
        href: " ",
        title: " "
    },
    {
        href: " ",
        title: " "
    },
];
exports.arrayReact = [
    {
        heading: "Что такое React? ",
        answer: [
            "React — это библиотека JavaScript для разработки интерфейсов, то есть внешней части сайтов и приложений, с которой взаимодействует пользователь. ",
            "Главная фишка React — компоненты и состояния. ",
            "Компонент — это кусочек кода, который отвечает за внешний вид одного из элементов сайта или приложения. Причём такие кусочки-компоненты могут быть вложенными. ",
            "Состояние — это вся информация об элементе, в том числе о его отображении. Например, состояние объекта «термометр» может описываться свойствами current_temperature, min и max. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Зачем нужен React.js, если есть HTML, JavaScript и CSS",
        answer: [
            "React.js — это JavaScript-библиотека от Facebook для удобной разработки интерфейсов, то есть внешней части сайтов и приложений, с которой взаимодействует пользователь.",
        ],
        isParagraph: true
    },
    {
        heading: "Каковы особенности React?",
        answer: [
            "    *  JSX (расширение синтаксиса JavaScript)",
            "    *  Виртуальный дом",
            "    *  Односторонняя привязка данных",
            "    *  Производительность",
            "    *  Расширения - браузерные инструменты React-разработчика",
            "    *  Условные операторы",
            "    *  Компоненты",
            "    *  Простота",
            "    *  SPA (одностраничное приложение)",
            " ",
            "    1. JSX (расширение синтаксиса JavaScript). ",
            "JSX представляет собой комбинацию HTML и JavaScript. Мы можем вставлять объекты JavaScript внутрь элементов HTML. Браузеры не поддерживают JSX, поэтому Babel компилирует или транскомпилирует код в код JavaScript. То, что в реакте похоже на код HTML, вовсе не HTML, это код JSX, синтаксис JSX. То, что нам кажется HTML-тегом, например <h1>, на самом деле является элементом JSX.",
            "      const name='GeekforGeeks';",
            "      const element = <h1>Добро пожаловать в {name}</h1>;",
            " ",
            "    2. Виртуальный DOM.  ",
            "DOM означает объектную модель документа . Это самая важная часть сети, поскольку она делится на модули и выполняет код. Обычно JavaScript Frameworks сразу обновляет весь DOM, что замедляет работу веб-приложения. Но в реакте используется виртуальный DOM, который является точной копией реального DOM. Всякий раз, когда в веб-приложении происходит модификация, сначала обновляется весь виртуальный DOM и определяется разница между реальным DOM и виртуальным DOM. После этого DOM обновляет только ту часть, которая недавно изменилась, и все остается по-прежнему.",
            " ",
            "    3. Односторонняя привязка данных.",
            "Односторонняя привязка данных, само название говорит о том, что это однонаправленный поток. Данные в реакте передаются только в одном направлении, то есть данные передаются сверху вниз, от родительских компонентов к дочерним компонентам. Свойства (пропсы) в дочернем компоненте не могут возвращать данные его родительскому компоненту, но могут иметь связь с родительскими компонентами для изменения состояний в соответствии с предоставленными входными данными. Это рабочий процесс односторонней привязки данных. Это делает все модульным и быстрым. ",
            " ",
            "    4. Производительность.",
            "Как мы уже говорили ранее, React использует виртуальный DOM и обновляет только измененные части. Таким образом, это заставляет DOM работать быстрее. DOM выполняется в памяти, поэтому мы можем создавать отдельные компоненты, которые ускоряют работу DOM. ",
            " ",
            "    5. Расширение.",
            "React имеет множество расширений, которые мы можем использовать для создания полноценных UI-приложений. Он поддерживает разработку мобильных приложений и обеспечивает рендеринг на стороне сервера. React дополнен Flux, Redux, React Native и т. д., что помогает нам создавать красивый пользовательский интерфейс. ",
            " ",
            "    6. Условные операторы.",
            "JSX позволяет нам писать условные операторы. Данные в браузере отображаются в соответствии с условиями, предусмотренными внутри JSX. ",
            " ",
            "    7. Компоненты.",
            " React.js делит веб-страницу на несколько компонентов, поскольку она основана на компонентах. Каждый компонент является частью дизайна пользовательского интерфейса, который имеет свою собственную логику и дизайн, как показано на изображении ниже. Таким образом, логика компонентов, написанная на JavaScript, упрощает и ускоряет работу, а также может использоваться повторно. ",
            " ",
            "    8. Простота.",
            "React.js основан на компонентах, что позволяет повторно использовать код, а React.js использует JSX, который представляет собой комбинацию HTML и JavaScript. Это делает код простым для понимания и отладки, а также требует меньше кода. ",
            " ",
            "    9. SPA (одностраничное приложение) ",
            "Одностраничные приложения (Single-Page Applications, SPA) — это веб-приложения (сайты), которые не перезагружают страницу при переходе между различными разделами. То есть все данные загружают на одной странице и динамически обновляют её при взаимодействии с пользователем.",
            "React.js использует SPA, где используются AJAX и HTML5 для создания гибких и адаптивных веб-приложений без постоянных перезагрузок страницы. ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие основные преимущества есть в React?",
        answer: [
            "    *  Использует виртуальный DOM, что улучшает производительность приложений.",
            "    *  Может использоваться как на стороне клиента, так и на стороне сервера.",
            "    *  JSX гораздо проще читать и понимать, чем JavaScript. ",
            "    *  Реализация системы компонентов — повторяющихся частей кода, которые используются в разных условиях и обстоятельствах и меняются в зависимости от контекста. ",
            "    *  Каждый компонент зависит только от своего состояния — а значит, гораздо легче устранять ошибки в коде, если что-то не работает или работает не так, как ожидалось. То есть ошибки становятся очевидными: компонент, который работает корректно сам по себе, всегда будет работать корректно — если только ему не передать какое-то неправильное состояние. ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие есть ограничения в React?",
        answer: [
            "React - это просто библиотека, а не полноценный фреймворк. ",
            "Его библиотека очень большая, и для ее понимания требуется время. ",
            "Начинающим программистам может быть немного сложно понять.",
            "Кодирование становится сложным, поскольку в нем используются встроенные шаблоны и JSX.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Основная цель React - минимизировать ошибки",
        answer: [
            "Основная цель React - минимизировать ошибки, возникающие при разработке пользовательских интерфейсов. ",
            "Это достигается за счёт использования компонентов - автономных логических фрагментов кода, которые описывают часть пользовательского интерфейса. А уже эти компоненты объединяются для создания полноценного пользовательского интерфейса. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Основная задача React. Как React изменяет DOM.",
        answer: [
            "Основная задача React — выяснить, как изменить DOM, чтобы он соответствовал тому, что компоненты хотят отображать на экране. React это делает: ",
            "    - путем «монтирования» (добавления узлов в DOM)  ",
            "    - «размонтирования» (удаления их из DOM)",
            "    - и «обновления» (внесения изменений в узлы, уже находящиеся в DOM).",
            "Процесс создания экземпляров и узлов DOM, соответствующих компонентам React, и вставки их в DOM называется монтированием. ",
        ],
        isParagraph: true
    },
    {
        heading: "Реальный DOM.",
        answer: [
            "Реальный DOM позволяет манипулировать элементами через javascript. DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. ",
            "    1. Обновляется медленно.",
            "    2. Можно напрямую обновлять HTML.",
            "    3. Создает новый DOM, если элемент обновляется. ",
            "    4. Манипуляции с DOM очень дороги.",
            "    5. Слишком много потерь памяти. ",
        ],
        isParagraph: true
    },
    {
        heading: "Виртуальный DOM.",
        answer: [
            "Виртуальный DOM - это облегченный объект JavaScript, который изначально является просто копией реального DOM.",
            "    1. Обновляется быстрее. ",
            "    2. Невозможно напрямую обновить HTML.",
            "    3. Обновляет элемент JSX, если обновляется.",
            "    4. Манипулировать DOM очень просто. ",
            "    5. Отсутствие потерь памяти.",
            "Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. ",
        ],
        isParagraph: true
    },
    {
        heading: "Что вы понимаете под виртуальным DOM? Объясните его работу. ",
        answer: [
            "Этот виртуальный DOM работает в три простых шага: ",
            "1. Когда состояние компонента React изменяется, React обновляет виртуальную модель DOM вместо непосредственного обновления фактической модели DOM. ",
            "2. Затем вычисляется разница между предыдущим представлением DOM и новым.",
            "3. Как только расчеты будут выполнены, реальный DOM будет обновлен только теми вещами, которые действительно изменились.",
            "-- ",
            "Таким образом, виртуальный DOM в React действует как оптимизация для увеличения скорости и эффективности обновлений пользовательского интерфейса. ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое JSX?",
        answer: [
            "JSX - сокращение от JavaScript XML.",
            "JSX — это расширение синтаксиса Javascript для описания интерфейса прямо в JS при создании React Elements с помощью синтаксиса, похожего на HTML. ",
            "--",
            "Браузеры могут читать только объекты JavaScript. Прежде чем запускать код JSX в браузере, его нужно преобразовать в обычный код JavaScript с помощью JSX-трансформеров, таких как Babel. Пакет webpack объединяет файлы JavaScript, чтобы они могли работать в браузере, а также может преобразовывать или упаковывать другие ресурсы. ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое компонент в React? В чем разница между функциональным компонентом React и классом React?",
        answer: [
            "Компоненты - это независимые, многоразовые участки кода пользовательского интерфейса приложения.",
            "В React есть два основных типа компонентов: функциональные компоненты и компоненты класса. ",
            "Классовый компонент: компонент, реализованный с использованием классов ES6, расширяющих React.Component.",
            "Функциональный компонент в React — это JavaScript-функция, которая на входе получает объект с данными для отрисовки компонента — их называют props, а на выходе возвращает описание интерфейса, который нужно отобразить.",
            "Функциональные компоненты, в большинстве случаев, заменяют классовые компоненты с помощью React Hooks.",
            "-- ",
            "Таким образом, основное различие между функциональными и классовыми компонентами в React заключается в том, что функциональные компоненты проще, понятнее и понятнее, в то время как классовые компоненты более мощные и предоставляют более продвинутые функции, но также и более сложные. ",
            "-- ",
            "Когда следует использовать классовые компоненты, а когда функциональные? ",
            "Если нужны жизненные этапы компонента - используем class компоненты. ",
            "Для оптимизации лучше функциональные.",
            "-- ",
            "Недостатки функциональных компонентов.",
            "1. Нет эквивалентов-хуков для жизненных циклов: getSnapshotBeforeUpdate (получить снимок перед обновлением) и componentDidCatch (компонент поймал).",
            "2. Старые сторонние библиотеки могут быть несовместимы с хуками.",
            "--",
            "Недостатки компонентов класса.",
            "1. Классы добавляют ненужную путаницу ради синтаксического сахара. ",
            "2.Классы приводят к громоздкому иерархическому дереву, особенно во время повторного использования кода, что приводит к снижению производительности и сложности тестирования. ",
            "3. Методы жизненного цикла класса разделяют связанные фрагменты кода. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между управляемыми (контролируемым) и неуправляемыми (неконтролируемым) компонентами? (Подробно, с примером...) ",
        answer: [
            "Оба являются элементами формы в React.",
            "1. Управляемый компонент - элемент формы input, значение которого контролирует React..",
            "В управляемом компоненте данные элемента формы обрабатываются компонентом React (не DOM) и сохраняются в состоянии компонента.  ",
            "Управляемый компонент принимает свое текущее значение в качестве пропсов, а также коллбэк для изменения этого значения.  Родительский компонент контролирует его, обрабатывая обратный вызов и управляя своим собственным состоянием и передавая новые значения в качестве реквизитов контролируемому компоненту. Вы также могли бы назвать это 'немым компонентом'.",
            "handleChange(event) { ",
            "setState({ value: event.target.value.toUpperCase() });",
            "} ",
            "-- ",
            "2. Неуправляемые компоненты хранят свои данные прямо в DOM, обрабатываются самим DOM с помощью ref.",
            "Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф. ",
            "import React, { useState(), useRef() } ",
            "-- ",
            "const NameForm: FC = () => { ",
            "const [ state, setState ] = useState( '' ) ",
            "const inputRef = useRef <HTMLInputElement> ( null ) ",
            "--",
            "handleSubmit(event) {",
            " - if( inputRef.current ) {",
            " - - event.preventDefault();",
            " - - alert( 'Отправленное имя: ' + inputRef.current.value );  ",
            " - - alert( 'Отправленное имя: ' + state );",
            " - }",
            "}",
            "--",
            "return (",
            "  <form onSubmit = { this.handleSubmit }>",
            "  - <input ",
            "  - - - - - - type='text' ",
            "  - - - - - - onChange = {( event ) => setState( event.target.value )}",
            "  - - - - - - placeholder='Управляемый' />",
            "  - <input type='text' ref={inputRef} placeholder='Неуправляемый' />",
            "  -  ",
            " - <input type='submit' value='Отправить' />",
            " </form>",
            ");",
            "}  ",
            "--------------------------------------------- ",
            "Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты. ",
            " ",
        ],
        isParagraph: true
    },
    // {
    //   heading:
    //     "Назовите разницу между презентационным (тупой, немой) и контейнерным (интеллектуальный, умный) компонентом?",
    //   answer: [
    //     "1. Презентационный. Компонент без состояния, также известный как «тупой», «немой» или «презентационный» компонент, — это компонент, который не поддерживает собственное внутреннее состояние. Он получает данные и обратные вызовы через пропсы (сокращение от свойств) и отображает пользовательский интерфейс только на основе этих реквизитов. Компоненты без сохранения состояния обычно используются для простых презентационных элементов, которым не требуется обрабатывать какую-либо сложную логику или обновления внутреннего состояния. Это простые функции, которые принимают пропсы и возвращают JSX.",
    //     "2. Контейнерный.  Компонент с отслеживанием состояния, также известный как «интеллектуальный», «умный» или «контейнерный» компонент, — это компонент, который поддерживает собственное внутреннее состояние. Он может обрабатывать обновления внутреннего состояния и побочные эффекты, а также может управлять состоянием других дочерних компонентов. Компоненты с отслеживанием состояния обычно используются для более сложных элементов, которым необходимо обрабатывать взаимодействие с пользователем, вызовы API или другую логику. Это компоненты класса, расширяющие React.Component.",
    //     "В общем, рекомендуется как можно больше использовать компоненты без состояния, чтобы приложение было простым и понятным. Компоненты с состоянием следует использовать только тогда, когда необходимо управлять состоянием или обрабатывать сложную логику. ",
    //     "-- ",
    //     "Презентационный (тупой, немой) - Не имеет состояния или логики. Может только получать пропсы, отображать переданные ему данные и генерировать события (работает на входящих параметрах ). Нужен для создания интерфейса. ",
    //     "Контейнерный (интеллектуальный, умный) - имеет состояние и логику. Может общаться с другими компонентами через пропсы и обратные вызовы. Может совершать вызовы API или выполнять сложную логику.",
    //     " ",
    //   ],
    //   isParagraph: true,
    // },
    {
        heading: "В чем разница между компонентом с состоянием («умный» или «контейнерный» компонент,) и компонентом без состояния («немой», «тупой» или «презентационный» компонент) в React? ",
        answer: [
            "В React компонент может быть либо без состояния, либо с состоянием. Основное различие между ними заключается в том, как они управляют своими данными и обновляют их. ",
            "1. Компоненты с состоянием имеют собственное внутреннее состояние, могут им управлять и обновлять. Также он может управлять данными, которые передаются ему в качестве свойств от других компонентов. ",
            "2. Компонент без состояния просто получают данные через свойства и отображают их без каких-либо манипуляций с данными. Эти компоненты считаются «чистыми», поскольку они связаны только с визуализацией данных и не имеют побочных эффектов. ",
            "Ключевое различие между ними заключается в том, как они управляют данными.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое props? ",
        answer: [
            "Props - сокращение от Properties.",
            "Props — набор значений, который используется для передачи данных от родительского компонента к его дочерним компонентам. Они доступны только для чтения и их нельзя менять.",
            "Пропсы считаются статическими и не могут быть изменены дочерним компонентом. Вместо этого родительский компонент отвечает за обновление значения своих пропсов и передачу обновленного значения дочернему компоненту. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое state? ",
        answer: [
            "state - это обычный объект JavaScript, управляемый внутри компонента. ",
            "State используется для хранения данных и управления ими, для изменения внутреннего состояния компонента и отслеживания пользовательских действий.",
            "State считается динамическим, что означает, что оно может меняться со временем в результате взаимодействия с пользователем или других событий. ",
            "В отличие от props, state можно изменять.",
            "Изменение state вызывает обновления для запуска повторного рендеринга.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между state и props? ",
        answer: [
            "state - это обычный объект JavaScript, управляемый внутри компонента. ",
            "State используется для хранения данных и управления ими, для изменения внутреннего состояния компонента и отслеживания пользовательских действий.",
            "State считается динамическим, что означает, что оно может меняться со временем в результате взаимодействия с пользователем или других событий. ",
            "В отличие от props, state можно изменять.",
            "-- ",
            "Props — набор значений, который используется для передачи данных от родительского компонента к его дочерним компонентам. Они доступны только для чтения и их нельзя менять.",
            "Пропсы считаются статическими и не могут быть изменены дочерним компонентом. Вместо этого родительский компонент отвечает за обновление значения своих пропсов и передачу обновленного значения дочернему компоненту. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что вызывает обновление компонента?",
        answer: ["Обновление компонента вызывают изменение состояния и изменение пропсов.", "SetState () "],
        isParagraph: true
    },
    {
        heading: "Что такое refs в React? Перечислите некоторые случаи, когда вам следует использовать refs.",
        answer: [
            "!!!   При использовании Refs рендеринг компонента не происходит. ",
            " ",
            "Refs - cокращенно от references (ссылки).",
            "Refs - атрибут, который предоставляет доступ к DOM-узлам или React-элементам, созданным в методе рендеринга.",
            "Они используются в случаях: ",
            "    -  когда мы хотим изменить значение дочернего компонента, не используя props (неуправляемый элемент); ",
            "    -  возможных измерений DOM элемента, его координат;",
            "    -  вызова анимаций;",
            "    -  для управление фокусом, выбором текста или воспроизведением мультимедиа.",
            "    -  взаимодействия со сторонними библиотеками, для добавления методов к компонентам.",
            "Можно возвращать ссылки на определенный элемент или компонент, возвращаемый render().",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое JEST?",
        answer: [
            "JavaScript фреймворк, для юнит тестирования на основе Jasmine. Разработал Facebook. Очень удобен именно для React. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что делает setState() и как это работает? ",
        answer: [
            "Вызов setState() изменяет состояние компонента, что повторно вызывает метод render().",
            "Изменение состояния, изменяет части приложения и строит новое дерево React элементов. Вычисляется, что должно отображаться на экране.",
            "Вызовы setState() являются асинхронными, поэтому время отрисововки компонента будет включать в себя время обновления.",
            "Обновления state не отражают новое значение сразу после вызова setState(). Нужен useEffect(). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какой второй аргумент можно опционально передать в setState и какова его цель? (Это для Class) ",
        answer: [
            "Второй аргумент, который при необходимости может быть передан в setState, - это функция обратного вызова, которая вызывается сразу после завершения setState и повторного рендеринга компонентов. ",
            "Если вы хотите, чтобы ваша программа обновила значение состояния с помощью setState, а затем выполнила определенные действия с обновленным значением состояния, вы должны указать эти действия в функции, которая должна быть вторым аргументом setState. ",
            " ",
            "      setState(( prev ) => prev + 1 ) ",
        ],
        isParagraph: true
    },
    {
        heading: "В setState можно передавать объект или функцию. В чем разница и что лучше использовать? ",
        answer: [
            "Props и state могут изменяться асинхронно. ",
            "Если мы передадим функцию, то мы точно будет знать, что state основывается на предыдущем состоянии.",
            " ",
            "      setState(( prev ) => !prev) ",
        ],
        isParagraph: true
    },
    {
        heading: "Как следует делать асинхронные запросы на сервер в React? ",
        answer: ["Для этого служит useEffect с пустым набором зависимостей. ", "Или  метод componentDidMount.", " "],
        isParagraph: true
    },
    {
        heading: "Как вы справляетесь с асинхронной загрузкой данных в приложении React? ",
        answer: [
            "1. Использую хук useEffect() в сочетании с fetch или axios для загрузки данных в компонент после его рендеринга. Хук useEffect позволяет синхронизировать компонент с внешней системой, такой как сервер, запустив побочный эффект (загрузку данных) после рендеринга компонента. Хук принимает функцию обратного вызова, содержащую эффект, и массив зависимостей. ",
            "2. Другой способ — использовать библиотеку, такую ​​как redux-thunk или redux-saga, для обработки асинхронного запроса и сохранения данных в хранилище/состоянии. Эти библиотеки предоставляют простой способ обработки асинхронных действий и поддержания чистоты состояния компонента. ",
            "3. Apollo graphql client — разработка приложений на react.js без redux",
            "Есть другие библиотеки ",
            "В любом случае важно следить за состоянием компонента и правильно обновлять его с помощью загруженных данных. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что значит компонент mounted?",
        answer: ["Компонент смонтирован, выводится, рендерится. Шаблон компонента соединен с DOM деревом", " "],
        isParagraph: true
    },
    {
        heading: "Что такое фрагменты?",
        answer: [
            "Специальный элемент в React позволяющий возвращать группу элементов без дополнительного родительского DOM элемента, например div. Фрагмент, практически не имеет веса, а div что-то да весит.",
            "<></> ",
            "<React.Fragment></React.Fragment>",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое событие в React? ",
        answer: [
            "Событие в React - это сигнал от браузера о том, что что-то произошло: наведение курсора мыши, щелчок мышью, нажатие клавиши и т. д. ",
            "Обработка этих событий аналогична обработке событий в элементах DOM. Но есть некоторые синтаксические различия, такие как:",
            "1. События в React называются с использованием camelCase (в стандартном html 'onclick', в React - 'onClick').",
            "2. В JSX в обработчик события передается функция компонента, а не строка.",
            "Аргумент event содержит набор свойств, специфичных для события.  Каждый тип события содержит свои собственные свойства и поведение, доступ к которым возможен только через его обработчик событий. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как React обрабатывает пользовательские события?",
        answer: [
            "Добавляет один обработчик события на корневой элемент. Обработчик событий — это функция обратного вызова, которая прикрепляется к элементу пользовательского интерфейса и выполняется, когда происходит указанное событие.",
            "Объект события оборачивает в свою обертку - SyntheticEvent для кроссбраузерности.",
            "React даёт в наше распоряжение кроссбраузерную обёртку SyntheticEvents, представляющую синтетические события и предназначенную для унификации работы с событиями DOM. Синтетические события весьма полезны по нескольким причинам: Они позволяет унифицировать особенности различных платформ, связанные с обработкой событий.  ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Context? ",
        answer: [
            "Контекст позволяет передавать глобальные данные всему дереву React-компонентов, избегая промежуточные компоненты.",
            "Контекст позволяет снабжать дочерние компоненты глобальными данными, независимо от того, насколько глубоко они находятся в дереве компонентов.",
            "Для использования контекста требуется 3 шага: создание, предоставление и использование контекста.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Context в React и для чего он используется? ",
        answer: [
            "Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык). ",
            "Контекст позволяет избежать передачи пропсов в промежуточные компоненты: ",
            "Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов. ",
            "    * React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов. ",
            "    * Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения. ",
            "    * Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext(). ",
            " ",
            "    * Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Рекомендации к работе с Context.",
        answer: [
            "Хоть в этом коде всё работает отлично, всё же есть некоторые аспекты с работой Context:",
            "    *  Не используйте Context, если он заменяет пробрасывание всего на один-два уровня. Этот инструмент — отличный способ, если нужно распространить состояние на множество компонентов, находящихся в «дереве» далеко друг от друга. Но если вам нужно просто опуститься или подняться на пару уровней, то пробрасывание будет легче и быстрее.",
            "    *  Постарайтесь не использовать Context для сохранения локального состояния. Например, если вам нужно сохранить введённые в форму данные, то лучше использовать локальное свойство.",
            "    *  Всегда оборачивайте родителя в Provider’а на как можно более низком уровне — не стоит использовать самую верхушку «дерева».",
            "    *  Наконец, если вы решили пересылать свойства таким способом, важно помнить про наблюдение за производительностью и рефакторингом. Но это скорее всего не понадобится, если просадки в производительности не будут сильно заметны.",
            "    *  Context лучше использовать для глобальных данных, которые не меняются.",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое React.createContext?",
        answer: [
            "React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Context.Provider?",
        answer: [
            "Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Class.contextType? ",
        answer: [
            "Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Context.Consumer?",
        answer: [
            "Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext(). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию компонента высшего порядка (HOC) в React и когда его использовать. (Higher-Order)",
        answer: [
            "Компонент высшего порядка (HOC) в React — это функция, которая принимает компонент в качестве аргумента и возвращает новый компонент с дополнительными параметрами (с добавленным поведением).",
            "Используйте HOC, когда вам нужно: ",
            "    1. Использовать общую логику для нескольких компонентов, например выборку данных или авторизацию. ",
            "    2. Слой абстракции для state и взаимодействия с ним.",
            "    3. Манипуляции со свойствами (управление пропсами).",
            "Примеры HOC включают withRouter HOC из react-router и connect HOC из react-redux . ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что делает shouldComponentUpdate (следует обновить компонент) и почему он важен? ",
        answer: [
            "Этап жизненного цикла, который решает, будет ли ре-рендер, или нет.",
            "Позволяет оптимизировать приложение",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Redux?",
        answer: [
            "Redux — это база данных в программе. Она хранит внутри себя данные (состояние) приложения.",
            "Redux отвечает только за данные и никак не связан с браузером, DOM и фронтендом в целом. Теоретически Redux можно использовать даже на бекенде в Node.js. Redux, с точки зрения кода — это объект, внутри которого лежат данные. Redux используется другими частями приложения для хранения данных, их изменения и извлечения. ",
            "Redux удобно использовать: ",
            "    1. Когда требуется синхронизировать состояние между многими компонентами; ",
            "    2. Постоянно приходится контролировать изменение состояния во времени — time travel debug; ",
            "    3. Приходится перехватывать и вмешиваться в процесс изменения состояния используя middleware.",
            " ",
            "Redux — это стэйт менеджер, библиотека для управления состоянием приложения в JavaScript.",
            "Он хранит состояние в дереве объектов внутри единого хранилища.",
            "Redux — позволяет передавать данные из единого стора, минуя необходимость передавать пропсы через каждый уровень (так называемое 'prop drilling').",
        ],
        isParagraph: true
    },
    {
        heading: "Как работает Redux?",
        answer: [
            "Redux хранит состояние в дереве объектов внутри единого стора. ",
            "    1. Единственная возможность изменить состояние - отправить action.",
            "    2. Action - это объект, который описывает действие (он отвечает на вопрос: 'Что я хочу изменить в состоянии?').",
            "    3. Далее action попадает в reducer, где описано, как состояние должно быть изменено. (reducer отвечает на вопрос: 'Как я хочу изменить стэйт?').",
            "    4. Корневой редюсер объединяет вывод нескольких редюсеров в одно дерево состояний.",
            "    5. Store сохраняет новое дерево состояний и уведомляет зарегистрированных слушателей. Для этого родительский компонент оборачивается в провайдер.",
        ],
        isParagraph: true
    },
    {
        heading: "Каким трем принципам следует Redux? ",
        answer: [
            "    1. Единственный источник истины (одно хранилище, которое управляет состоянием всего приложения).",
            "    2. Состояние доступно только для чтения (единственный способ обновить состояние – отправить action). Аction - это простой JS-объект, описывающий изменение в этих данных.",
            "    3. Изменения вносятся с помощью чистых функций (reducers).",
            " ",
            "Чистые функции - это функции, возвращаемое значение которых зависит исключительно от их аргументов.",
            "Чистые» функции - это любые функции, исходные данные которых получены исключительно из их входных данных и не вызывают побочных эффектов в приложении. Математические функции являются примерами «чистых» функций. ",
        ],
        isParagraph: true
    },
    {
        heading: "Что вы понимаете под “внутренним источником правды”? в Redux. ",
        answer: [
            "Redux использует ‘Хранилище’ для хранения всего состояния приложения в одном месте. Таким образом, все состояния компонентов хранятся в хранилище, и они получают обновления из самого хранилища. Единое дерево состояний упрощает отслеживание изменений с течением времени и отладку или проверку приложения.",
        ],
        isParagraph: true
    },
    {
        heading: "Flux-архитектура, Redux и MobX: Что такое Flux (поток) - архитектура? Какие сущности она имеет?",
        answer: [
            "Flux — это архитектурный шаблон или набор шаблонов программирования, обеспечивающий однонаправленный поток данных. Он контролирует производные данные и обеспечивает связь между несколькими компонентами, используя центральное хранилище, которое имеет полномочия для всех данных. Любое обновление данных в приложении должно происходить только здесь. Flux обеспечивает стабильность приложения и снижает количество ошибок во время выполнения. ",
            "Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении. ",
            "В минимальном варианте Flux-архитектура может содержать три слоя, взаимодействующие по порядку: ",
            "1. Действия (англ. actions) — выражение событий (часто для действий используются просто имена — строки, содержащие некоторый «глагол»). Диспетчеры передают действия нижележащим компонентам (хранилищам) по одному. Новое действие не передаётся пока предыдущее полностью не обработано компонентами. Действия из-за работы источника действия, например, пользователя, поступают асинхронно, но их диспетчеризация явлется синхронным процессом. Кроме имени (англ. name), действия могут иметь полезную нагрузку (англ. payload), содержащую относящиеся к действию данные.",
            "2. Диспетчер/Диспатчер (англ. dispatcher) предназначен для передачи действий хранилищам. В упрощённом варианте диспетчер может вообще не выделяться, как единственный на всё приложение. В диспетчере хранилища регистрируют свои функции обратного вызова (callback) и зависимости между хранилищами.",
            "3. Хранилище (англ. store) является местом, где сосредоточено состояние (англ. state) приложения. Остальные компоненты, согласно Flux, не имеют значимого (с точки зрения архитектуры) состояния. Изменение состояния хранилища происходит строго на основе данных действия и старого состояния хранилища при помощи чистых функций.",
            "4. Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю. Во Flux-архитектуре, которая может технически не касаться внутреннего устройства представлений вообще, это — конечная точка потоков данных. Для информационной архитектуры важно только, что данные попадают в систему (то есть, обратно в хранилища) только через действия.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Перечислите основные составляющие Redux.",
        answer: [
            "Redux состоит из следующих компонентов: ",
            "1. Action - это объект со свойством type, указывающие, какой тип действия выполняется. Описывает то, что произошло.",
            "2. Reducers — это функции, которые принимают Action и текущее состояние и возвращают результирующее состояние. Это место, где можно определить, как изменится состояние.",
            "3. Store —  хранилище. Store — это центральный объект, который поддерживает и обновляет состояние приложения. Store также занимается регистрацией и отменой регистрации слушателей",
            "4. dispatch — этот метод позволяет отправить Action диспетчеру и изменить state приложения.",
            "5. Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое action в Redux?",
        answer: [
            "Объект, который обязательно должен содержать ключ type. С помощью него Redux понимает, что именно нужно сделать со state.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните роль Reducer.  Что такое reducer?",
        answer: [
            "Простая чистая функция, принимающая state и action и модифицирующая state.",
            "Должна возвращать новый объект.",
            "Редюсеры работают, принимая предыдущее state и action, а затем возвращают новый state. Он определяет, какое обновление необходимо выполнить, в зависимости от типа action, а затем возвращает новые значения. Он возвращает предыдущее состояние как есть, если не нужно выполнять никакой работы.",
            "-- ",
            "1. Редюсеры — это чистые функции, которые определяют, как изменяется состояние приложения в ответ на ДЕЙСТВИЕ.",
            "2. Редюсеры работают, принимая предыдущее состояние и действие, а затем возвращая новое состояние.",
            "3. Он определяет, какое обновление необходимо выполнить, в зависимости от типа действия, а затем возвращает новые значения.",
            "4. Он возвращает предыдущее состояние как есть, если не нужно выполнять никаких действий.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между редюсером (reducer) и действием (action) в Redux?",
        answer: [
            "В Redux редюсер и действие — это два разных, но связанных понятия. ",
            "Действие — это простой объект JavaScript, описывающий изменение, которое необходимо внести в состояние приложения. У него есть свойство type , определяющее тип выполняемого действия, и свойство payload , предоставляющее любые дополнительные данные, необходимые для выполнения действия. Действия отправляются из приложения в хранилище Redux, которое затем передает действие редюсерам. ",
            "Редюсер — это чистая функция, которая принимает текущее состояние приложения и действие и возвращает следующее состояние приложения. Редуктор отвечает за обработку действий и соответствующее обновление состояния. Он не должен выполнять никаких побочных эффектов, таких как выполнение вызовов API, а вместо этого должен возвращать только следующее состояние. ",
            "Таким образом, действия описывают, что должно измениться, а редюсеры определяют, как должно измениться состояние в ответ на действия. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое store в Redux? ",
        answer: [
            "1. store (хранилище) — это объект JavaScript, который может хранить состояние приложения и предоставлять несколько вспомогательных методов для доступа к состоянию, отправки действий и регистрации слушателей.",
            "2. Все дерево состояний/объектов приложения сохраняется в одном хранилище.",
            "3. Мы можем передать промежуточное ПО в хранилище для обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. ",
            "4. Все действия возвращают новое состояние через редюсеры.",
            " - - state может быть получен через getState(). ",
            " - - Изменять state можно через dispatch(action). ",
            " - - Регистрировать изменения через subscribe(listener).",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: " Каковы преимущества Redux?",
        answer: [
            "Преимущества Redux перечислены ниже: ",
            "1. Предсказуемость результата - поскольку всегда есть один источник истины, то есть store, нет путаницы в том, как синхронизировать текущее состояние с actions и другими частями приложения. ",
            "2. Ремонтопригодность – код становится легче поддерживать с предсказуемым результатом и строгой структурой.",
            "3. Рендеринг на стороне сервера – вам просто нужно передать хранилище, созданное на сервере, на сторону клиента. Это очень полезно для первоначального рендеринга и обеспечивает лучший пользовательский интерфейс, поскольку оптимизирует производительность приложения.",
            "4. Инструменты разработчика - от действий до изменений состояния, разработчики могут отслеживать все, что происходит в приложении в режиме реального времени.",
            "5. Сообщество и экосистема - за Redux стоит огромное сообщество, что делает его еще более увлекательным в использовании. Большое сообщество талантливых людей вносит свой вклад в улучшение библиотеки и разрабатывает с ее помощью различные приложения.",
            "6. Простота тестирования - код Redux в основном состоит из небольших, чистых и изолированных функций. Это делает код тестируемым и независимым.",
            "7. Организация - Redux точно определяет, как должен быть организован код, это делает код более последовательным и простым, когда с ним работает команда.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Redux Toolkit? ",
        answer: [
            "Redux Toolkit: официальный набор инструментов -Redux, позволяющий быстро приступить к работе с Redux. Поставляется с готовыми функциями и утилитами, которые помогают легко настроить магазин и создавать действия и редукторы.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какова цель функции combReducers в Redux? ",
        answer: [
            "Функция combReducers используется для объединения различных редюсеров, обрабатывающих разные части состояния, в один корневой редюсер. Затем этот корневой редуктор передается функции createStore для создания хранилища Redux. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между подключенным компонентом и компонентом в React-Redux? ",
        answer: [
            "Подключенные компоненты — это компоненты более высокого порядка, которые обернуты вокруг простых компонентов, чтобы предоставить им доступ к хранилищу Redux. Подключенные компоненты используются для доступа к состоянию хранилища и действиям по отправке, тогда как обычные компоненты используются для управления элементами пользовательского интерфейса и состоянием локальных компонентов.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию Saga в Redux. ",
        answer: [
            "Saga в Redux — это способ управления побочными эффектами (например, асинхронными операциями, такими как выборка данных, и нечистыми операциями, такими как доступ к кешу браузера) в приложении Redux. Он реализован как промежуточное программное обеспечение с использованием функций генератора в JavaScript и работает в фоновом режиме, отдельно от основного потока вашего приложения, отслеживая действия, отправленные в хранилище. При обнаружении определенного действия Saga может выполнять различные задачи и инициировать дополнительные действия по мере необходимости, обновляя хранилище на основе результатов асинхронных операций. Основное преимущество использования Sagas заключается в том, что они упрощают анализ, тестирование и управление потоком данных в вашем приложении.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между синхронным действием и асинхронным действием в Redux?",
        answer: [
            "В Redux действие — это простой объект JavaScript, описывающий изменение состояния приложения. Действия могут быть как синхронными, так и асинхронными. ",
            "Синхронное действие — это действие, которое отправляется и немедленно обрабатывается хранилищем Redux. Хранилище обновляет состояние, и обновленное состояние немедленно становится доступным для использования компонентами. ",
            "С другой стороны, асинхронное действие — это действие, которое отправляется, но для его завершения требуется некоторое время. Асинхронные действия обычно используются при выполнении сетевых запросов или выполнении других операций, требующих времени. Эти действия не могут быть немедленно обработаны хранилищем Redux, поэтому для их выполнения требуется дополнительная логика. ",
            "В приложении Redux асинхронные действия часто обрабатываются с помощью промежуточного программного обеспечения, такого как redux-thunk или redux-saga , которые позволяют диспетчеризировать действия, представляющие начало и завершение асинхронных операций. Это ПО промежуточного слоя обеспечивает способ обработки асинхронности операции и обеспечения надлежащего обновления состояния после завершения операции. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое контекстный API?",
        answer: [
            "Как и Redux, Context API — это решение для управления состоянием.",
            " Контекст состоит из 3 основных частей: ",
            "1. Объект Context создается с использованием React.createContext (defaultValue)",
            "2. Провайдер — это компонент, который инициирует повторное рендеринг всех потребителей-потомков при изменении его значения.",
            "3. Потребитель — это компонент, который подписывается на изменения контекста.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что нельзя делать в методе render?",
        answer: [
            "Нельзя изменять состояние компонента (например вызывать setState). ",
            "Должен быть чистой (pure) функцией. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие типы middleware есть в redux для работы с асинхронностью?",
        answer: ["1. Redux Thunk.", "2. Redux Promise. ", "3. Redux Saga. ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: "Зачем нужен Redux Thunk?",
        answer: ["Middleware позволяющая изменять состояние приложения в Redux в асинхронном режиме.", " "],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию Thunk (Преобразователь) в Redux. ",
        answer: [
            "Преобразователь в Redux — это функция, которая возвращает другую функцию вместо простого объекта действия. Он используется для выполнения асинхронных операций и отправки нескольких действий. Преобразователи позволяют вам писать генераторы действий, которые возвращают функцию вместо действия. Это может быть полезно для выполнения асинхронных операций, таких как вызовы API, и диспетчеризации нескольких действий, например, одного, чтобы указать, что вызов API начался, и другого, чтобы указать, что он завершен. Внутренняя функция получает метод отправки хранилища в качестве аргумента, который можно использовать для отправки действий в любой момент в будущем. Преобразователи обычно реализуются с использованием промежуточного программного обеспечения, такого как промежуточное программное обеспечение redux-thunk .",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое PureComponent? (чистый компонент) ",
        answer: [
            "Тоже самое, что и Component, кроме того, что автоматически за вас реализует метод shouldComponentUpdate (следует обновить компонент). ",
            "PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния. ",
            "Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию чистого компонента в React. (PureComponent) ",
        answer: [
            "«Чистый компонент» в React — это компонент, который обновляется только при изменении его свойств или состояния.  ",
            "Напротив, «нечистый компонент» повторно рендерится каждый раз, когда повторно рендерится родительский компонент, независимо от того, изменились ли его пропсы или состояние. ",
            "Чистые компоненты более продуктивны, поскольку они не требуют повторного рендеринга.",
            "Расширяя React, компонент React можно сделать чистым.",
            "React заменяется PureComponent. Компонент.",
            "Это побуждает метод shouldComponentUpdate, который решает, следует ли выполнять повторный рендеринг, обеспечить автоматическое поверхностное сравнение реквизитов и состояния компонента. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Почему не стоит изменять state напрямую?",
        answer: [
            "Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. ",
            "Корректно использовать метод setState(). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как изменить state используя динамический ключ? ",
        answer: [
            "1. Используем атрибут name: ",
            "onChange( e ) {",
            "setState({",
            "[ e.target.name ] : e.target.value  ",
            "}) ",
            "-- ",
            "2. Используем атрибут id: ",
            "onChange( e ) {",
            "setState({",
            "[ e.target.id ] : e.target.value  ",
            "}) ",
            "-- ",
            "3. Или мы можем сначала создать этот объект, а затем передать этот объект в setState функцию, вот так: ",
            "onChange( e ) {",
            "let obj = {}; ",
            "obj [ e.target.id ] = e.target.value ",
            "setState( obj )",
            "-- ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое React Hooks? Объясните концепцию хука в React.",
        answer: [
            "Хуки — это именованные функции, которые позволяют нам использовать повторную логику для отслеживания состояния в React-компонентах. Названия хуков начинаются с префикса use.",
            " ",
            "С помощью хуков в React 16.8 можно писать приложения, используя только функциональные компоненты, без классов. ",
            "-- ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию пользовательского (кастомного) хука (Custom Hooks,) в React.",
        answer: [
            "Пользовательский хук в React — это функция JavaScript, которая позволяет извлекать логику состояния и поведение из компонента и повторно использовать его в нескольких компонентах. ",
            "Пользовательские хуки называются с использованием префикса use (например , useForm , useFetch ) и могут вызывать другие хуки, а также ваши собственные пользовательские хуки. У них те же правила, что и у хуков, и их можно вызывать только на верхнем уровне вашего компонента или ваших собственных пользовательских хуков. ",
            "Пользовательские хуки могут получать аргументы и возвращать значения, как и обычные функции, но они также могут управлять состоянием и выполнять побочные эффекты. Абстрагируя состояние и поведение в Custom Hook, вы можете улучшить читабельность и удобство сопровождения вашего кода. ",
            "Примеры вещей, которые вы можете создать с помощью Custom Hooks: ",
            "1. Получение данных.",
            "2. Управление обновлениями состояния.",
            "3. Обработка отправленных форм.",
            "4. Реализация анимации и переходов.",
            "И многое другое. ",
            "Использование пользовательских хуков может сделать ваши компоненты более чистыми, более удобными для повторного использования и более простыми для тестирования, что делает их мощным инструментом в вашем наборе инструментов React. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useState()",
        answer: [
            "Кратко: ",
            "1. useState — это хук, который позволяет добавлять и обновлять состояние для функциональных React-компонентов.",
            "2. useState, как и все хуки, является функцией.",
            "3. Аргумент: исходное состояние (initialState)",
            "4. Возвращает: пара, содержащая текущее состояние и функцию для его обновления.",
            "- ",
            "Подобно: ",
            "const [ state, setState ] = useState( initialState ); ",
            "Возвращает значение с состоянием (state) и функцию для его обновления (setState). ",
            "Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState). ",
            "Функция setState используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента: setState(newState);",
            " ",
            "Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым последним состоянием после применения обновлений. ",
            "Использование в setState объекта: ",
            "setState( initialState ) ",
            "-- ",
            "Использование в setState функции: ",
            "1. setState(( prev) => !prev ) ",
            "2. setState(( prev) => prev + 1 ) ",
            "3. setState(( prev) => prev - 1) ",
            "- ",
            "useState не объединяет объекты обновления автоматически. Вы можете повторить это поведение, комбинируя форму функции обновления с синтаксисом расширения объекта: ",
            "const [state, setState] = useState({}); ",
            "setState(prevState => { ",
            " - // Object.assign также будет работать",
            " - return {...prevState, ...updatedValues};",
            "}); ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useEffect()",
        answer: [
            "Кратко: ",
            "1. useEffect позволяет выполнять побочные эффекты в функциональных компонентах.",
            "2. useEffect срабатывает после рендеринга. ",
            "3. Аргументы: вызываемая функция и массив зависимостей.",
            "Побочные эффекты должны быть отделены от процесса рендеринга. Если нам нужно выполнить побочный эффект, это должно быть сделано строго после наш компонент рендерит. Это то, что дает нам useEffect. ",
            "Побочным эффектом называют операции, при которых происходит взаимодействие с внешним окружением (средой выполнения). К таким операциям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран, печать на принтере и так далее. ",
            "-- ",
            "Подобно: ",
            "useEffect(() => { функция }, [ массив зависимостей ]) ",
            "Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране. ",
            "По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Очистка эффекта (компонента).",
        answer: [
            "Нам нужно запустить побочные эффекты и тогда, когда компонент размонтирован. Это функция очистки, которая позволяет нам остановить побочные эффекты непосредственно перед размонтированием компонента. ",
            " ",
            "--",
            "Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку, идентификатор таймера или прослушиватель событий. Чтобы сделать это, функция переданная в useEffect, может вернуть функцию очистки. Например, чтобы создать / удалить прослушиватель событий: ",
            "useEffect(() => { ",
            " - // Добавляем прослушиватель событий",
            " - document.addEventListener('scroll', scrollHandler);",
            " - return function () {",
            " - - // Очищаем компнонент перед тем, как он покинет экран: удаляем прослушиватель событий",
            " - - document.removeEventListener('scroll', scrollHandler);",
            " - };",
            "}, [top]); ",
            "-- ",
            "Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта. В нашем примере это означает, что прослушиватель событий создаётся при каждом обновлении и удаляется перед закрытием.  ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Условное срабатывание эффекта, массив зависимостей хуков.",
        answer: [
            "По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда пересоздаётся, если значение какой-то из зависимости изменилось. ",
            "Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп source.",
            "Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом зависимостей, от которых зависит эффект. Наш обновлённый пример теперь выглядит так: ",
            "useEffect( ",
            " - () => {",
            " - - const subscription = props.source.subscribe();",
            " - - return () => {",
            " - - - subscription.unsubscribe();",
            " - - };",
            " - }, [props.source],",
            "); ",
            "Теперь подписка будет создана повторно только при изменении props.source. ",
            "-- ",
            "Примечание: ",
            "Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом. В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров. Отдельные страницы документации рассказывают о том, как поступить с функциями и что делать с часто изменяющимися массивами. ",
            "Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ([]) вторым аргументом. React посчитает, что ваш эффект не зависит от каких-либо значений из пропсов или состояния и поэтому не будет выполнять повторных запусков эффекта. ",
            "Если вы передадите пустой массив ([]), пропсы и состояние внутри эффекта всегда будут иметь значения, присвоенные им изначально.",
            "Не забывайте, что React откладывает выполнение useEffect, пока браузер не отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой.",
            "Массив зависимостей не передаётся в качестве аргументов функции эффекта. Тем не менее, в теории вот что происходит: каждое значение, на которое ссылается функция эффекта, должно также появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создать этот массив автоматически.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useContext()",
        answer: [
            "const value = useContext( MyContext );",
            "Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве. ",
            "Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext. Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext. ",
            "Запомните, аргументом для useContext должен быть непосредственно сам объект контекста: ",
            " - Правильно: useContext( MyContext )",
            " - Неправильно: useContext(MyContext.Consumer)",
            " - Неправильно: useContext(MyContext.Provider)",
            "Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации. ",
            "useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста. ",
            "Соединим все вместе с Context.Provider: ",
            "------------------------------------------ ",
            "-- Создадим файл context/index.ts -- ",
            "import { createContext } from 'react'; ",
            "-- ",
            "interface IAuthContext { ",
            " - isAuth: boolean;",
            " - setAuth: React.Dispatch< React.SetStateAction < boolean >>;",
            "} ",
            "-- ",
            "export const AuthContext = createContext< IAuthContext > ({ ",
            " - isAuth: false,",
            " - setAuth: () => {},",
            "}); ",
            "------------------------------------------ ",
            "-- функциональный компонент App -- ",
            "import React, { FC, useState } from 'react'; ",
            "import AppRouter from '../AppRouter'; ",
            "import { AuthContext } from '../../context/index'; ",
            "-- ",
            "const App: FC = () => { ",
            " - const [ isAuth, setAuth ] = useState< boolean >( false ); ",
            "-- ",
            "- return ( ",
            " - - <div>",
            " - - - <AuthContext.Provider value = {{ isAuth, setAuth }} >",
            " - - - - <AppRouter />",
            " - - - </AuthContext.Provider>",
            " - - </div>",
            " - );",
            "}; ",
            "export default App; ",
            "------------------------------------------ ",
            "-- функциональный компонент TopMenu -- ",
            "import React, { FC, useContext } from 'react'; ",
            "- ",
            "const TopMenu: FC = () => { ",
            " - const { isAuth, setAuth } = useContext( AuthContext ); ",
            " - const openAdminLogin = () => { setAuth ( true ) }",
            " - const closeAdminLogin = () => { setAuth ( false ) }",
            " ",
            " - return ( ",
            " - - // .... ",
            " - )",
            "export default TopMenu; ",
            "------------------------------------------ ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию контекста в React.",
        answer: [
            "В React контекст — это способ обмена данными, которые считаются «глобальными» для дерева компонентов. Это позволяет вам передавать данные через дерево компонентов без необходимости вручную передавать пропсы на каждом уровне. ",
            "Компонент, которому требуется доступ к данным контекста, может использовать их с помощью хука useContext или компонента Consumer. Чтобы сделать контекст доступным для компонента, родительский компонент должен предоставить его с помощью компонента Provider. ",
            "Контекст часто используется для данных, которые требуются многим компонентам приложения, таким как текущий авторизованный пользователь, текущая локаль или тема. ",
            "Следует отметить, что контекст следует использовать с осторожностью, так как он может затруднить анализ и тестирование ваших компонентов. Если есть возможность, лучше передавать пропсы по дереву компонентов вручную. ",
            " ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useMemo()",
        answer: [
            "useMemo() и useCallback() занимаются мемоизацией.",
            "Метод мемоизации сохраняет результаты вычислений в кэше и извлекает ту же информацию из кэша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.",
            "useCallback() мемоизирует сами колбеки, useMemo() мемоизирует значения.",
            "useMemo() сверяет, если предыдущие пропсы такие же, как и следующие, тогда он даже рендер не вызывает. Он вернёт предыдущий jsx. В это его смысл.    ",
            " ",
            "const memoizedValue = useMemo(() => { computeExpensiveValue ( a, b ) }, [ a, b ] ",
            "React.memo для оптимизации производительности работы. ",
            "React.memo – это компонент более высокого порядка, который позволяет оптимизировать производительность ваших компонентов, предотвращая ненужную повторную визуализацию. ",
            "Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. ",
            "Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo. ",
            "Если массив не был передан, новое значение будет вычисляться при каждом рендере. ",
            "Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана.",
            "Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.",
            " ",
            "Без useMemo: ",
            "      const newsFilteredByYear = [ ...news ].filter(( item ) => {",
            "            return new Date( item.date ).getFullYear() === Number( selectedYear );",
            "            });",
            " ",
            "С добавлением useMemo: ",
            "      const newsFilteredByYear = useMemo( () => { ",
            "            return [ ...news ].filter(( item ) => {",
            "                  return new Date( item.date ).getFullYear() === Number( selectedYear );",
            "            });",
            "      }, [ news, selectedYear ]); ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useCallback() ",
        answer: [
            "В каких случаях нам нужна мемоизация колбека? Чем она может быть полезна? ",
            "useCallback() используем только тогда, когда дочерний компонент useMemo(). ",
            "Смысл useCallback() в том, чтобы у нас не вызывался рендеринг компонента каждый раз, чтобы не создавалась каждый раз заново функция, например функция обработчика. useCallback() достаёт reference из прошлого, смотрит, если массив зависимостей не поменялся, тогда не создаётся заново функция, а возвращается старая, которая хранится где там внутри.  ",
            " ",
            "      import React, { useState, useMemo, useCallback, FC } from 'react'; ",
            " ",
            "      const useComponent: FC = () => { ",
            "            const [count, setCount] = useState(0);",
            "            const [numbers] = useState(() => [1, 6, 8, 14, 18, 3, 26]);",
            " ",
            "            const handlerClick: () => void = useCallback(() => {",
            "                  setCount((count) => count + 1);",
            "                  setCount((count) => count + 1);",
            "                  setCount((count) => count + 1);",
            "            }, []);",
            " ",
            "            const items = useMemo(() => {",
            "                  return numbers.map((num) => <li key={num}>{num}</li>);",
            "            }, [numbers]);",
            " ",
            "            return (",
            "                  <div>",
            "                        <ul>{items}</ul>",
            "                  </div>",
            "            );",
            "      }; ",
            " ",
            "      export default useComponent;",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useRef()",
        answer: [
            "      import React, { FC, useRef } from 'react'; ",
            " ",
            "1. В функциональном компоненте: ",
            "Refs  создаются с помощью useRef() и прикрепляются к элементам React через атрибут ref.",
            "      const refColumn = useRef< HTMLDivElement > ( null ); ",
            " ",
            "      useEffect(() => { ",
            "            if ( refColumn.current ) { ",
            "                  emitWidthColumn ( refColumn.current?.offsetWidth ); ",
            "            } ",
            "      }, [ emitWidthColumn ]); ",
            " ",
            "2. В jsx refs прикрепляются к элементам React через атрибут ref: ",
            "      return ( ",
            "            <div ref = { refColumn }> ",
            "                  <div> {title} </div>",
            "            </div> ",
            "      ); ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как передавать данные между компонентами в ReactJS ",
        answer: [
            "1. Через пропсы;",
            "2. Используя callback-функцию;",
            "3. Пробросом пропсов от уровня к уровню (prop drilling);",
            "4. При помощи контекста (React Context AP);",
            "5. Через хранилище (store);",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое prop drilling и как этого избежать?",
        answer: [
            "Передача свойств на прямую от родителя к ребенку через сложную и длинную иерархию компонентов.",
            "Избежать можно используя Context или например Redux.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как валидировать props в React? ",
        answer: [
            "Для этого есть дополнительная библиотека - PropTypes",
            "Для осуществления проверки типов рекомендуется использовать TypeScript - расширение JavaScript.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Разница между Flow и PropTypes? ",
        answer: [
            "Flow - статический инструмент для проверки типов. Использует аннотации и позволяет найти ошибки при компиляции (аналог TypeScript) ",
            "PropTypes - проверяет типы входящих параметров в runtime",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что не так с этим кодом?",
        answer: [
            "      setState(( prev, props ) => { ",
            "            return {",
            "                  counter: prev.counter + props.counter ",
            "            }  ",
            "      }) ",
            "С этим кодом все хорошо. Изменяем state на основе прошлого состояния и входящих параметров.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое рендеринг? (отрисовка страницы) ",
        answer: [
            "Ре́ндеринг или отрисо́вка — термин в компьютерной графике, обозначающий процесс получения изображения по модели с помощью компьютерной программы.",
        ],
        isParagraph: true
    },
    {
        heading: "Когда происходит рендеринг компонента? ",
        answer: ["Когда меняются пропсы и состояние. ", " "],
        isParagraph: true
    },
    {
        heading: "Для чего нужен атрибут key при рендере списков? ",
        answer: [
            "Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени. ",
            "Лучший способ выбрать ключ — это использовать уникальные значения, которые будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ. Индексы рекомендуется использовать только в тех случаях, когда точно не будет удалений этих элементов и нет возможности использовать id.",
            "Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в DOM. Эти ключи должны быть уникальным номером или строкой, с помощью которых React просто переупорядочивает элементы, а не перерисовывает их. Это приводит к увеличению производительности приложения. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Правда ли, что React делает ре-рендер всех компонентов и дочерних компонентов каждый раз когда вызывается setState? ",
        answer: ["По умолчанию - да. И в функциональном и в классовом компонентах.", " "],
        isParagraph: true
    },
    {
        heading: "Объясните разницу между рендерингом на стороне сервера и рендерингом на стороне клиента в React.",
        answer: [
            "В приложении React существует два основных способа рендеринга компонентов: рендеринг на стороне сервера (SSR) и рендеринг на стороне клиента (CSR). ",
            "1. Рендеринг на стороне сервера (SSR) — это когда первоначальный рендеринг приложения React выполняется на сервере. Сервер генерирует HTML для начального состояния приложения и отправляет его в браузер. Когда пакет JavaScript загружается, React вступает во владение, и приложение продолжает функционировать как SPA (одностраничное приложение) на стороне клиента. Его преимущества: ",
            "    -  Улучшена производительность для поисковых систем и пользователей на медленных соединениях. ",
            "    -  Более быстрое время до первого байта.",
            "    -  Лучшая доступность для пользователей, у которых отключен JavaScript.",
            "2. Рендеринг на стороне клиента (CSR) — это когда приложение React полностью визуализируется в браузере с использованием JavaScript. Браузер запрашивает пакет JavaScript с сервера, а затем отображает компоненты на стороне клиента. Преимущество этого подхода: ",
            "    -  более быстрая загрузка для пользователей, с быстрым подключением и более отзывчивом пользовательском интерфейсе.",
            " ",
            "В общем, CSR — это более простой вариант реализации и более популярный, но SSR — хороший выбор для определенных случаев использования, например, когда SEO является основной задачей или когда приложение нацелено на пользователей с медленным интернет-соединением. ",
            "Также стоит отметить, что возможен гибридный подход между SSR и CSR, который называется изоморфным или универсальным рендерингом. Такой подход позволяет использовать преимущества как SSR, так и CSR. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию компонента без рендеринга в React.",
        answer: [
            "Компонент без рендеринга — это компонент, у которого есть логика, но отсутствуют элементы HTML. Этот компонент предоставляет данные и методы другим компонентам через пропсы и обратные вызовы.",
            "Задача компонента без рендеринга — аккумулировать логику, которую можно повторно использовать в нескольких компонентах. ",
            "Другие компоненты, использующие логику, предоставляемую компонентом без рендеринга, могут затем отображать необходимые им HTML-элементы на основе данных и методов, которые они получают от компонента без рендеринга.",
            "Этот подход разделяет логику и визуализацию, упрощая поддержку и тестирование кода.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обрабатываете рендеринг на стороне сервера в приложении React?",
        answer: [
            "Рендеринг на стороне сервера (SSR) в React включает в себя рендеринг ваших компонентов React на сервере и отправку полученного HTML-кода клиенту. Это дает ряд преимуществ, включая повышение производительности и оптимизацию для поисковых систем (SEO). Чтобы реализовать SSR в приложении React, вы можете использовать библиотеку, например Next.js или Razzle, которая предоставляет простую в использовании структуру для обработки SSR. Кроме того, вы можете использовать API ReactDOMServer для ручного рендеринга ваших компонентов на сервере. Ключевыми этапами процесса являются: ",
            "1. Настройка вашего сервера для обработки входящих запросов и рендеринга соответствующих компонентов.",
            "2. Рендеринг компонентов на сервере с помощью ReactDOMServer.renderToString или ReactDOMServer.renderToStaticMarkup.",
            "3. Отправка полученного HTML-кода клиенту как часть ответа.",
            "4. Увлажнение компонентов на клиенте, чтобы пользователь мог интерактивно управлять ими.",
            "Стоит отметить, что SSR имеет некоторые компромиссы и дополнительную сложность, поэтому важно тщательно взвесить, является ли это правильным выбором для вашего приложения. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как можно улучшить производительность React приложения? ",
        answer: [
            "Для функциональных компонентов: ",
            "    1. Сохранение состояния компонента локальным, где это необходимо. ",
            "    2. Использование Hook React.memo() для предотвращения ненужных повторных рендеров. ",
            "    3. Разделение кода в React с помощью динамического импорта.",
            "    4. Виртуализация окон или списков в React.",
            "    5. Ленивая загрузка изображений в React.",
            " ",
            "Для класс компонентов: ",
            "    1. shouldComponentUpdate в класс компонентах.",
            "    2. PureComponent для класс компонентов.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Понимание того, как React обновляет пользовательский интерфейс. ",
        answer: [
            "Когда мы создаем компонент, React создает виртуальный DOM-дерево элементов в компоненте. Когда состояние компонента изменяется, React воссоздает виртуальный DOM-дерево и сравнивает результат с предыдущим рендерингом. ",
            "React использует концепцию виртуального DOM, чтобы минимизировать затраты на производительность повторного рендеринга веб-страницы, потому что фактический DOM требует больших затрат на манипулирование. ",
            "Это здорово, потому что уменьшает время рендеринга пользовательского интерфейса. Однако эта концепция также может замедлить работу сложного приложения, если оно не сконфигурировано должным образом. ",
            "Изменение состояния в компоненте React вызывает повторную визуализацию (рендеринг). Точно так же, когда состояние передается дочернему компоненту в качестве свойства, оно перерисовывается в дочернем компоненте и так далее, что нормально, потому что React должен обновлять пользовательский интерфейс. ",
            "Проблема возникает, когда на дочерние компоненты не влияет изменение состояния. Другими словами, они не получают никаких свойств от родительского компонента. ",
            "Тем не менее React повторно визуализирует эти дочерние компоненты. Итак, пока родительский компонент выполняет повторную визуализацию, все его дочерние компоненты выполняют повторную визуализацию независимо от того, передается ли им свойство или нет, это поведение React по умолчанию. ",
            "Всякий раз, когда состояние компонента обновляется, ChildComponent выполняет повторную визуализацию, даже если на него не влияет изменение состояния напрямую. ",
            "В большинстве случаев повторный рендеринг не должен вызывать проблем с производительностью, и мы не должны замечать никаких задержек в нашем приложении. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем ключевое отличие между React и Angular? ",
        answer: [
            "React - библиотека для отрисовки приложения. Для другого функционала нужны другие решения (например для данных - Redux).",
            "Angular - обширный фреймворк, где все решения есть в ядре (в коробке). ",
            " - Используя React - можно более гибко создавать приложения и более точечно управлять его частями.",
            " - Используя Angular - проще разрабатывать и поддерживать приложения.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Лучшие рекомендации (оптимизация) для React разработчиков в 2023 году. ",
        answer: [
            "1. Использование функциональных компонентов. ",
            "2. Использование hooks. ",
            "3. Использование React Context для управления состоянием.",
            "4. Использование React.memo для оптимизации производительности работы. React.memo – это компонент более высокого порядка, который позволяет оптимизировать производительность ваших компонентов, предотвращая ненужную повторную визуализацию.",
            "5. Использование библиотеки React Router.",
            "6. Использование расширения React Developer. ",
            "7. Использование линтера для соблюдения стиля кода. ",
            "8. Использование фреймворка для тестирования. ",
            "9. Использование сборщиков модулей. webpack",
            "10. Использование IDE (редактора кода) для повышения производительности. Visual Studio Code ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы справляетесь с оптимизацией кода в большом приложении React? ",
        answer: [
            " -- Разделение кода: исползование модулей, многоразовых компонентов.",
            " --  Отложенная загрузка. Отложенная загрузка позволяет загружать компоненты только тогда, когда они необходимы.",
            " -- Использование кэширования. Вы можете кэшировать данные и компоненты, которые часто используются в вашем приложении, чтобы избежать повторной выборки одних и тех же данных.",
            "-- ",
            "Оптимизация кода в большом приложении React может быть достигнута с помощью нескольких подходов: ",
            "1. Разделение кода. Это позволяет разделить код на более мелкие фрагменты, которые можно загружать по требованию, что сокращает время первоначальной загрузки приложения.",
            "2. Отложенная загрузка. Отложенная загрузка позволяет загружать компоненты только тогда, когда они необходимы, уменьшая объем кода, который необходимо загрузить и проанализировать при запуске.",
            "3. Использование сборщика, такого как Webpack: сборщик может помочь вам оптимизировать ваш код, уменьшив размер ваших файлов JavaScript, объединив несколько файлов в один и т. д.",
            "4. Использование кэширования. Вы можете кэшировать данные и компоненты, которые часто используются в вашем приложении, чтобы избежать повторной выборки одних и тех же данных.",
            "5. Использование эффективных алгоритмов и структур данных. Чтобы ваше приложение работало быстро, важно использовать алгоритмы и структуры данных, оптимизированные для повышения производительности.",
            "6. Регулярный мониторинг производительности и профилирование. Регулярный мониторинг производительности и профилирование могут помочь вам определить узкие места в производительности и области, требующие улучшения в вашем коде.",
            "7. Использование методов оптимизации, таких как мемоизация. Используя такие методы, как мемоизация, вы можете уменьшить количество ненужных повторных рендерингов и вычислений в своем приложении, повысив его общую производительность.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Использование линтера для соблюдения стиля кода. ",
        answer: [
            "Общий стиль кода важен для любого проекта, и это особенно важно при работе с командой. Линтер может помочь вам обеспечить согласованный стиль кода, обнаруживая и выделяя такие проблемы, как пропущенные точки с запятой, неиспользуемые переменные и другие распространенные ошибки. ",
            "Чтобы использовать линтер в вашем проекте React, вам сначала нужно установить его с помощью npm: ",
            "npm install eslint",
            "-- ",
            "Затем вы можете создать файл конфигурации для линтера, выполнив следующую команду: ",
            "npx eslint --init ",
            "-- ",
            "На этом этапе вы пройдете через серию подсказок по настройке линтера для вашего проекта. Как только настройка будет завершена, вы можете запустить этот инструмент, используя следующую команду: ",
            "npx eslint . ",
            "-- ",
            "После запуска линтера, он сообщит о любых обнаруженных проблемах. Вы также можете использовать специальные плагины для вашего текстового редактора, чтобы автоматически выделять возникающие проблемы во время работы. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обеспечиваете сохранение данных в приложении React? ",
        answer: [
            "В приложении React сохранение данных может быть реализовано различными способами, в том числе: ",
            "1. Локальное хранилище: это позволяет хранить пары ключ-значение в локальном хранилище браузера, которое можно получить даже после того, как пользователь закроет браузер или перезагрузит свое устройство.",
            "2. Файлы cookie: файлы cookie представляют собой небольшие фрагменты данных, которые хранятся в браузере пользователя и могут быть доступны веб-сайту при последующих посещениях.",
            "3. IndexedDB: это низкоуровневый API для хранения на стороне клиента больших объемов структурированных данных, включая файлы и большие двоичные объекты.",
            "4. Веб-база данных SQL: это устаревшая технология хранения данных в базе данных на стороне клиента с использованием SQL.",
            "5. Хранилище на стороне сервера: вы также можете хранить данные на удаленном сервере с помощью API или базы данных, такой как MySQL, MongoDB, PostgreSQL и т. д.",
            "6. Redux или Mobx: библиотеки управления состоянием, такие как Redux или Mobx, можно использовать для управления и сохранения состояния приложения в различных компонентах и ​​сеансах.",
            "Какой из них использовать, зависит от вашего конкретного случая использования и требований. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обрабатываете ошибки в приложении React? ",
        answer: ["Использую блок try-catch", " "],
        isParagraph: true
    },
    {
        heading: "В чем разница между статическим и динамическим компонентами в React?",
        answer: [
            "В React статический компонент — это компонент, который определен с фиксированным набором свойств или атрибутов и не изменяется в течение своего жизненного цикла. Статический компонент определяется с помощью простой функции JavaScript, которая возвращает дерево элементов, представляющих пользовательский интерфейс компонента. ",
            "С другой стороны, динамический компонент — это компонент, который может изменять свои свойства, состояние или поведение в зависимости от взаимодействия с пользователем или событий, происходящих в приложении. Динамический компонент обычно определяется с использованием компонента класса или функционального компонента с перехватчиками useState или useEffect.",
            "Вот пример статического компонента: ",
            "function welcome ( props ) { ",
            " - - return <h1>Hello, { props.name }</h1>; ",
            "}",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Специальными возможности в приложении React.",
        answer: [
            "Специальные возможности в React дают доступ к приложению людям с ограниченными способностями. Для этого применяются следующие методы: ",
            "1. Семантический HTML. Используйте семантические элементы HTML, такие как <button> , <nav> и <header> , чтобы четко определить структуру и цель вашего контента.",
            "2. Доступные пропсы: используйте доступные пропсы, такие как aria-label , role и tabIndex , чтобы предоставить дополнительную информацию вспомогательным технологиям, таким как программы чтения с экрана.",
            "3. Навигация с помощью клавиатуры. Убедитесь, что все функции доступны с помощью клавиатуры и что фокус клавиатуры управляется правильно.",
            "4. Цветовой контраст: убедитесь, что контраст между текстом и фоном достаточно высок, чтобы его могли прочитать люди с дальтонизмом или слабым зрением.",
            "5. Альтернативный текст. Предоставьте альтернативный текст изображениям, видео и другим нетекстовым элементам, чтобы обеспечить доступность информации для пользователей программ чтения с экрана.",
            "6. Тестирование средств чтения с экрана. Протестируйте приложение с помощью средств чтения с экрана и других вспомогательных технологий, чтобы выявить и устранить любые проблемы с доступностью.",
            "Важно отметить, что доступность — это непрерывный процесс, и его следует учитывать на протяжении всей разработки вашего приложения React. Использование таких инструментов, как правила линтинга и инструменты проверки доступности, также может помочь обеспечить доступность вашего приложения. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обеспечиваете совместимость браузера в приложении React? ",
        answer: [
            "Чтобы обеспечить совместимость браузера в приложении React, вы можете использовать различные методы, такие как: ",
            "1. Полифиллы: для поддержки старых браузеров вы можете использовать полифиллы. Полифиллы — библиотеки JavaScript, которые эмулируют отсутствующие функции в старых браузерах.",
            "2. Обнаружение браузера: вы можете использовать такие библиотеки, как browser-detect , чтобы определить браузер пользователя и его версию и соответствующим образом настроить свой код.",
            "3. Обнаружение функций: вместо того, чтобы полагаться на обнаружение браузера, вы можете использовать обнаружение функций, чтобы проверить, поддерживается ли конкретная функция браузером пользователя, прежде чем использовать ее.",
            "4. Сброс CSS: вы можете использовать сбросы CSS, такие как normalize.css , чтобы убедиться, что все браузеры отображают стили согласованным образом.",
            "5. Тестирование. Регулярное тестирование в различных браузерах и устройствах необходимо для выявления любых проблем совместимости на ранних этапах процесса разработки.",
            "Используя эти методы, вы можете обеспечить бесперебойную работу вашего приложения React в разных браузерах и на разных устройствах. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обеспечиваете безопасность в приложении React? ",
        answer: [
            "Обеспечение безопасности в приложении React включает в себя несколько шагов, в том числе: ",
            "1. Проверка ввода: проверяйте все вводимые пользователем данные на стороне клиента и сервера, чтобы предотвратить обработку любых вредоносных данных.",
            "2. Аутентификация и авторизация пользователей. Используйте безопасный механизм аутентификации, такой как веб-токены JSON (JWT), чтобы гарантировать, что только авторизованные пользователи могут получить доступ к конфиденциальным данным.",
            "3. Безопасное хранение конфиденциальных данных: не храните конфиденциальную информацию, такую ​​как пароли и номера кредитных карт, в локальном хранилище, вместо этого используйте зашифрованное хранилище.",
            "4. Внедрение HTTPS. Используйте HTTPS для обеспечения безопасной связи между клиентом и сервером и защиты от сетевых атак, таких как атаки «человек посередине».",
            "5. Поддержание зависимостей в актуальном состоянии: регулярно обновляйте React и его зависимости, чтобы исправить любые известные уязвимости безопасности.",
            "6. Использование политики безопасности контента (CSP): внедрите политику безопасности контента (CSP), чтобы ограничить типы ресурсов, которые можно загружать в приложение React, и предотвратить атаки межсайтовых сценариев (XSS)",
            "7. Регулярные проверки безопасности. Проводите регулярные проверки безопасности, чтобы своевременно выявлять и устранять потенциальные проблемы безопасности.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию провайдера в React-Redux. ",
        answer: [
            "«Поставщик» в React-Redux — это компонент более высокого порядка, который обертывает ваше приложение React и предоставляет ему возможность доступа к хранилищу Redux. Это позволяет вам передавать хранилище вашим компонентам, используя контекст, без необходимости вручную передавать его в качестве реквизита через каждый уровень дерева компонентов. ",
            "Используя Provider, вы гарантируете, что все ваши компоненты могут подписываться на хранилище и отправлять действия для изменения его состояния. Другими словами, Provider действует как мост между вашими компонентами React и вашим хранилищем Redux, делая хранилище доступным для всех компонентов вашего приложения. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы справляетесь с разделением кода в приложении React? ",
        answer: [
            "Разделение кода в React можно реализовать с помощью следующих подходов: ",
            "Динамический импорт. Динамический импорт позволяет лениво загружать компонент только тогда, когда это необходимо. Это делается с помощью синтаксиса import() и позволяет разделить код на более мелкие фрагменты, которые можно загружать по требованию. ",
            "Webpack Bundle Analyzer: это инструмент, который обеспечивает визуальное представление кода и его размера. Вы можете использовать этот инструмент для определения больших фрагментов кода, которые можно разделить на более мелкие фрагменты и загрузить лениво. ",
            "Используя эти подходы, вы можете эффективно справляться с разделением кода в приложении React и повышать его производительность за счет сокращения времени начальной загрузки и загрузки только необходимого кода по запросу. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Webpack Bundle Analyzer",
        answer: [
            "Если вы используете Create React App, Next.js, Gatsby или похожие инструменты, то у вас уже будет настроенный Webpack для бандлинга приложения. ",
            "Webpack Bundle Analyzer: это инструмент, который обеспечивает визуальное представление кода и его размера. Вы можете использовать этот инструмент для определения больших фрагментов кода, которые можно разделить на более мелкие фрагменты и загрузить лениво. ",
            "Большинство React-приложений «собирают» свои файлы такими инструментами, как Webpack, Rollup или Browserify. Сборка (или «бандлинг») — это процесс выявления импортированных файлов и объединения их в один «собранный» файл (часто называемый «bundle» или «бандл»). Этот бандл после подключения на веб-страницу загружает всё приложение за один раз. ",
            "Иначе, вам нужно будет настроить webpack самостоятельно. Для этого ознакомьтесь со страницами по установке и началу работы в документации по Webpack. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между компонентом React и элементом React?",
        answer: [
            "Компонент React — это класс или функция JavaScript, которая возвращает элемент React. Это многократно используемый элемент пользовательского интерфейса, описывающий часть пользовательского интерфейса.",
            "С другой стороны, элемент React — это простой объект JavaScript, представляющий узел DOM. Это неизменное представление узла DOM, которое можно создать с помощью React.createElement или JSX. ",
            "Короче говоря, компонент — это план создания элементов, а элемент — экземпляр компонента. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию промежуточного программного обеспечения в Redux. ",
        answer: [
            "В Redux промежуточное программное обеспечение — это программный компонент, который находится между хранилищем и процессом диспетчеризации действий для добавления дополнительных функций, таких как ведение журнала, отчеты о сбоях, обработка асинхронных действий и т. д. Он позволяет расширять поведение хранилища без изменения самого хранилища. . Промежуточное программное обеспечение применяется с использованием метода applyMiddleware и может быть составлено вместе для достижения желаемого поведения. Когда действие отправлено, оно проходит через каждое ПО промежуточного слоя в том порядке, в котором они были составлены, что дает ПО промежуточного слоя возможность взаимодействовать с действием до того, как оно достигнет хранилища. Это дает возможность манипулировать действиями и состоянием, а также выполнять сложные действия, которые могут охватывать несколько действий.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы справляетесь с интернационализацией в приложении React? ",
        answer: [
            "Обработка интернационализации (i18n) в приложении React включает в себя адаптацию пользовательского интерфейса и содержимого приложения для соответствия языковым и культурным требованиям различных регионов. ",
            "Существует несколько библиотек и методов, которые можно использовать для реализации интернационализации в приложении React, в том числе: ",
            "1. react-intl: популярная библиотека для интернационализации приложений React. Он предоставляет компоненты для форматирования дат, чисел и строк, а также обработки множественного числа и извлечения сообщений.",
            "2. Контекстный API: Контекстный API React можно использовать для хранения текущей локали и сделать ее доступной для компонентов, которым она нужна. Язык можно изменить динамически, чтобы переключить язык приложения.",
            "3. Пользовательские хуки: Пользовательские хуки могут быть написаны для инкапсуляции логики форматирования и получения сообщений, а также для упрощения использования в компонентах.",
            "4. Реализация интернационализации в приложении React может значительно улучшить взаимодействие с пользователем, говорящим на разных языках и проживающим в разных регионах. Это важное соображение для любого приложения, которое стремится иметь глобальный охват.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между функциональным компонентом React и классом React?",
        answer: [
            "Когда дело доходит до собеседования, важно понимать разницу между компонентами класса React и функциональными компонентами. Эти знания могут продемонстрировать ваше понимание React и его компонентов, а также показать вашу способность писать эффективный и удобный для сопровождения код. ",
            "Когда вас спросят о компонентах класса, вы можете подчеркнуть, что они определены как классы JavaScript, которые расширяют класс React.Component , имеют метод рендеринга и могут иметь дополнительные методы и состояние жизненного цикла. Вы также можете привести простой пример, чтобы показать свое понимание компонентов класса. ",
            "Когда вас спросят о функциональных компонентах, вы можете подчеркнуть, что они определены как простые функции JavaScript, которые возвращают разметку JSX компонента, и что они могут использовать состояние и другие функции React с перехватчиками. Вы также можете привести пример, показывающий, как написать функциональный компонент, который обеспечивает ту же функциональность, что и компонент класса. ",
            "Наконец, вы можете объяснить компромиссы между компонентами класса и функциональными компонентами, например, что функциональные компоненты обычно проще и легче читаются, в то время как компоненты класса предлагают больше возможностей и гибкости. Демонстрация вашей способности взвешивать плюсы и минусы каждого подхода может продемонстрировать ваши навыки критического мышления и способность писать код, который можно обслуживать. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните концепцию мемоизации в React.",
        answer: [
            "Метод мемоизации сохраняет результаты вычислений в кэше и извлекает ту же информацию из кэша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.",
            "Метод мемоизации использует оперативную память компьютера, поэтому использовать его надо с осторожностью, строго по необходимости. ",
            "В React мемоизация предотвращает ненужные повторные рендеринги. Если входные данные (пропсы) для компонента не меняются, кэшированный результат можно использовать повторно вместо повторного вычисления результата. ",
            "React предоставляет встроенный хук под названием useMemo для реализации мемоизации. useMemo принимает функцию и массив зависимостей в качестве аргументов и возвращает запомненное значение. Функция выполняется повторно, только если одна или несколько зависимостей изменились. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как вы обрабатываете события в React? ",
        answer: [
            "При создании приложения React часто требуется реагировать на действия пользователя, такие как нажатия кнопок, отправка форм и другие события. В React это достигается за счет использования обработчиков событий. ",
            "Обработчик событий — это функция обратного вызова, которая прикрепляется к элементу пользовательского интерфейса и выполняется, когда происходит указанное событие. ",
            "Например, чтобы обработать событие нажатия на кнопку, вы должны определить в своем компоненте React функцию, которая обновляет состояние компонента, а затем прикрепить эту функцию к кнопке в качестве обработчика события onClick  ",
            "Обработчики событий являются ключевой частью системы обработки событий React и используются для добавления интерактивности в ваше приложение. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Обработчик событий",
        answer: [
            "Обработчик событий — это функция обратного вызова, которая прикрепляется к элементу пользовательского интерфейса и выполняется, когда происходит указанное событие. ",
            "Обработчики событий являются ключевой частью системы обработки событий React и используются для добавления интерактивности в ваше приложение. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Каковы различные фазы жизненного цикла компонента React? ",
        answer: [
            "1. 'Initial Rendering' - начальная фаза рендеринга :  это фаза, когда компонент собирается начать свой жизненный путь и пробиться в DOM. ",
            "2. 'Updating' - фаза обновления :  как только компонент добавлен в DOM, он потенциально может обновляться и перерисовываться только тогда, когда происходит изменение свойства или состояния. Это происходит только в этой фазе.",
            "3. 'Unmounting' - фаза размонтирования : это заключительная фаза жизненного цикла компонента, на которой  компонент уничтожается и удаляется из DOM.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Назовите основные этапы жизненного цикла компонента ",
        answer: [
            "componentWillMount (компонент будет монтироваться) - выполняется непосредственно перед рендерингом как на стороне клиента, так и на стороне сервера. В основном для настройки компонента.",
            "render - процесс рендеринга (отдачи). ",
            "componentDidMount (компонент смонтировал) - уведомляет, про то, что компонент соединен с DOM деревом. Выполняется на стороне клиента только после первого рендеринга.",
            "componentWillReceiveProps (компонент получает свойства) - уведомляет, про то, что приходят новые входящие свойства в компонент. Вызывается сразу после получения props от родительского класса и перед вызовом другого рендеринга.",
            "shouldComponentUpdate (следует обновить компонент) - возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг.",
            "componentWillUpdate (компонент будет обновляться) - уведомляет, что компонент будет обновлен. Вызывается непосредственно перед рендерингом в DOM.",
            "componentDidUpdate (компонент сделал обновление) - уведомляет, что компонент был обновлен. Вызывается сразу после выполнения рендеринга.",
            "componentWillUnmount (компонент будет размонтирован) - используется для удаления слушателей и очистки памяти компонента. Вызывается перед удалением компонента, после отключения компонента от DOM.",
        ],
        isParagraph: true
    },
    {
        heading: "Какие методы жизненного цикла компонента существуют в React? ",
        answer: [
            "1. render() — единственный обязательный метод в классовом компоненте. При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null.",
            "2. constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам. Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру. Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().",
            "3. componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.",
            "4. componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().",
            "5. shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.",
            "6. static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.",
            "7. getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().",
            "8. static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().",
            "9. componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "render()",
        answer: [
            "render() — единственный обязательный метод в классовом компоненте.",
            "При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "constructor()",
        answer: [
            "Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам. ",
            "Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру. ",
            "Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState(). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Виртуальный DOM?",
        answer: [
            "Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. ",
            "Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как работает проп children? ",
        answer: [
            "Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод: ",
            "function FancyBorder(props) { ",
            " -  return (",
            " - -  <div className={'FancyBorder FancyBorder-' + props.color}>",
            " - - - {props.children}",
            " - - </div>",
            " - );",
            "} ",
            "------------------------------------------------------------------ ",
            "Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX: ",
            "function WelcomeDialog() { ",
            " - return (",
            " - - <FancyBorder color='blue'>",
            " - - - <h1 className='Dialog-title'>",
            " - - - - Добро пожаловать",
            " - - - </h1>",
            " - - - <p className='Dialog-message'>",
            " - - - - Спасибо, что посетили наш космический корабль!",
            " - - - </p>",
            " - - </FancyBorder>",
            " - );",
            " }",
            "------------------------------------------------------------------ ",
            "Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое порталы в React?",
        answer: [
            "Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. ",
            "ReactDOM.createPortal(child, container) ",
            "Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент. ",
            "Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое React Reconciliation (Cверка) и как он работает? ",
        answer: [
            "Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента. ",
            "При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. ",
            "Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. ",
            "При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. ",
            "По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Можно создавать анимации в React? ",
        answer: [
            "React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Правила использования хуков.",
        answer: [
            "Нельзя вызывать хуки внутри циклов, условных операторов или вложенных функций. ",
            "Хуки нужно вызывать только внутри React-функций, до возврата какого-либо значения из них.",
            "Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами useState и useEffect. ",
            "Нельзя вызывать хуки из обычных js-функций, но можно: ",
            " - - Вызывать хуки из функционального компонента.",
            " - - Вызывать хуки из пользовательского хука.",
            "Следуя этим правилам, можно гарантировать, что вся логика состояния компонента чётко видна из исходного кода.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Преимущества одностраничного приложения SPA.",
        answer: [
            "Вэб страница не перезагружается при навигации по приложению. Реакт, с помощью javascript, просто перерисовывают определённые части страницы.",
            "Моментальная перерисовка элементов вэб страницы. Реакт позволяет перерисовывать только определённые части вэб страницы, при этом оставляя остальные части без изменения. Для пользователей перерисовка происходит, практически, мгновенно, реагируя на действия пользователей.",
            "Легче разворачивать в продакшене, потому, что SPA содержит только несколько статических файлов: один файл HTML, один файл CSS и один файл Javascript. Для публикации SPA достаточно разместить на сервере эти три файла.",
            "Эффективное использование пропускной способности. То есть, клиент скачивает с сервера файлы HTML, CSS и Javascript только один раз, при начальном подключении. После этого, все модификации страницы происходят только на стороне клиента.",
            "Многостраничное приложение будет перезагружаться, заставляя весь пользовательский интерфейс быстро мигать в зависимости от приложения, что происходит из-за обновления сайта. Напротив, SPA плавно отображается всегда , в любой момент, поскольку такое приложение просто показывает доступ к внешнему контенту без обновления страницы веб-сайта в его браузере. ",
        ],
        isParagraph: true
    },
    {
        heading: "Недостатки одностраничного приложения SPA.",
        answer: [
            "Для поисковой оптимизации (SEO) необходимо выполнить дополнительную настройку сервера для кооректного сканирования ботами, такими, как Googlebot.",
            "Время начальной загрузки приложения велико.",
        ],
        isParagraph: true
    },
    {
        heading: "Недостатки многостраничного приложения.",
        answer: [
            "Многостраничное приложение будет перезагружаться, заставляя весь пользовательский интерфейс быстро мигать в зависимости от приложения, что происходит из-за обновления сайта. Напротив, SPA плавно отображается всегда , в любой момент, поскольку такое приложение просто показывает доступ к внешнему контенту без обновления страницы веб-сайта в его браузере. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое состояние приложения?",
        answer: [
            "Всё, что находится в оперативной памяти компьютера и относится к работе программы, можно назвать состоянием приложения.",
            "Приложения могут быть составлены из блоков, модулей и компонентов. У каждого блока может быть своё собственное состояние.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое состояние глобальное состояние приложения.",
        answer: [
            "Глобальное состояние приложения — это часть состояния приложения, которое используется, учитывается и изменяется в разных частях, модулях, компонентах этого приложения. ",
            "Глобальное состояние должно быть доступно из любой части приложения, а при его изменении компоненты приложения должны произвести необходимые вычисления. Следовательно, нам необходимо правильно управлять глобальным состоянием. ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое состояние состояние компонента React.",
        answer: [
            "Состояние — это встроенный объект React, который используется для хранения данных или информации о компоненте. Состояние компонента может меняться со временем; всякий раз, когда он изменяется, компонент перерисовывается.",
            "Рассмотрим три крупных компонента — пост в ленте «Фейсбука»*, блок краткой информации и блок с выводом фотографий. В каждый из них входят более мелкие компоненты. Например, внутри поста есть текст, изображение, аватарка, имя автора, лайки, комментарии, различные информационные элементы. Внутри блока с фотографиями — отдельные фото, а внутри блока с краткой информацией — собственно та самая краткая информация. ",
            "У каждого из этих компонентов есть состояния. Например, блок краткой информации будет по-разному выглядеть в мобильной и десктопной версиях, у сердечка меняется число с лайками или цвет (если вы лайкнули или не лайкнули запись), а пост может обрезать текст, показывать содержимое полностью, меняться в зависимости от содержания. Ведь содержание поста — это тоже его состояние. Именно в этом проявляется гибкость и сила React.js: вы пишете компонент один раз, а потом просто передаёте ему разные состояния. ",
            "В React.js есть собственные средства для управления состояниями, но на практике в средних и крупных проектах чаще используют Redux — сторонний менеджер состояний. Он удобнее и лучше масштабируется. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: " Побочные эффекты в программировании это ",
        answer: [
            "Побочный эффект – то, что делает функция, кроме вычисления возвращаемого значения. Функция с побочными эффектами не только вычисляет значение на основе входных данных, но и выполняет дополнительные дей-ствия. Например, выводит результаты на экран, записывает данные в файл, изменяет таблицы баз данных, реагирует на исключительные си-туации и т.д. Детерминированные функции мо-гут содержать побочные эффекты. ",
            "Побочный эффект функции — возможность в процессе выполнения своих вычислений: читать и модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывать их обработчики. Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются недетерминированными функциями с побочными эффектами. ",
        ],
        isParagraph: true
    },
    {
        heading: "state management - это инструмент для управления состоянием.",
        answer: [
            "Это инструмент, который как-то взаимодействует со state. ",
            "Это механизм, позволяющий создавать реактивные переменные, фиксировать изменения их значений и уведомлять об этом 'заинтересованные' компоненты.  ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Метод рендеринга() React.js. React.js метод render().",
        answer: [
            "Библиотека React.js предназначена для разделения приложения на несколько компонентов. Каждый компонент имеет свой жизненный цикл. React предоставляет нам несколько встроенных методов, которые мы можем переопределить на определенных этапах жизненного цикла компонента. ",
            "В компонентах на основе классов метод render() является единственным обязательным и наиболее важным методом из всех встроенных хуков/методов жизненного цикла. В методе render() мы можем прочитать свойства и состояние и вернуть наш код JSX в корневой компонент нашего приложения. В методе render() мы не можем изменить состояние и не можем вызвать побочные эффекты (например, выполнение HTTP-запроса к веб-серверу). ",
        ],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
];

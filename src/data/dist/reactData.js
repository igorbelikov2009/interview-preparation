"use strict";
exports.__esModule = true;
exports.arrayReact = exports.linksReactPage = void 0;
exports.linksReactPage = [
    {
        href: "https://reactdev.ru/ ",
        title: "Справочник React на русском языке."
    },
    {
        href: "https://reactdev.ru/handbook/tutorial/ ",
        title: "Документация по React (на русском языке). React – это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами»."
    },
    {
        href: "https://reactdev.ru/types/ ",
        title: "React и Typescript (на русском языке). Типизация библиотеки React с помощью Typescript: Типизированный React, Функциональные компоненты, Классовые компоненты, Универсальные компоненты, Типизированные хуки, Контекст (Context), HOC (Higher-Order Components)."
    },
    {
        href: "https://reactdev.ru/libs/cra/",
        title: "Create React App (CRA на русском языке) - это интерфейс командной строки (command line interface, CLI), позволяющий создавать предварительно настроенные React-проекты. Предварительная настройка включает в себя, но не исчерпывается, настройкой Webpack и Babel."
    },
    {
        href: "https://reactdev.ru/graphql/ ",
        title: "GraphQL (на русском языке) — это язык запросов к API и среда выполнения этих запросов с имеющимися данными. GraphQL обеспечивает полное и понятное описание данных в вашем API, дает клиентам возможность запрашивать именно то, что им нужно, упрощает обновление API-интерфейсов и предоставляет мощные инструменты для разработчиков "
    },
    {
        href: "https://reactdev.ru/questions/#shouldcomponentupdate",
        title: "Вопросы про React на собеседовании. Частые вопросы и ответы про React, задаваемые на собеседованиях "
    },
    {
        href: "https://reactdev.ru/libs/react-router/",
        title: "Справочник React на русском языке. React Router DOM. React Router. Маршрутизатор"
    },
    {
        href: "https://reactdev.ru/libs/redux/ ",
        title: "Redux. Библиотека управления состоянием. Документация redux (на русском языке)."
    },
    {
        href: "https://reactdev.ru/libs/redux-toolkit/",
        title: "Redux Toolkit. Пакет (на русском языке), облегчающий работу с Redux "
    },
    {
        href: "https://reactdev.ru/libs/recoil/",
        title: "Recoil - это новый инструмент (на русском языке) для управления состоянием в React-приложениях "
    },
    {
        href: "https://reactdev.ru/libs/react-query/",
        title: "React Query. Библиотека (на русском языке) для получения, кэширования, синхронизации и обновления 'серверного' состояния в React-приложениях "
    },
    {
        href: "https://reactdev.ru/libs/react-spring/",
        title: "React Spring. Библиотека для анимации интерфейсов (на русском языке)"
    },
    {
        href: "https://reactdev.ru/libs/styled-components/#_1",
        title: "Styled Components. Шпаргалка по библиотеке стилизации (на русском языке)"
    },
    {
        href: "https://reactdev.ru/libs/xstate/",
        title: "XState. Библиотека для управления конечными автоматами (на русском языке):  Базовая библиотека конечных автоматов и диаграмм состояний + интерпретатор, Минимальная библиотека конечных автоматов, Утилиты обхода графа для XState, React xуки и утилиты для использования XState в приложениях React, Функции композиции и утилиты Vue для использования XState в приложениях Vue, Утилиты Svelte для использования XState в приложениях Svelte, Утилиты Model-Based-Testing (с использованием XState) для тестирования любого программного обеспечения, Утилиты разработчика (проверки) для XState."
    },
    {
        href: "https://react-hook-form.com/",
        title: "React Hook Form. Валидация форм."
    },
    {
        href: "https://www.youtube.com/watch?v=Jxfun6Jnt5Q",
        title: "Валидация форм с react-hook-form в React-приложениях. Михаил Непомнящий. "
    },
    {
        href: "https://www.youtube.com/watch?v=Nicadhseqos&t=82s",
        title: "Zod для валидации API и форм. Михаил Непомнящий."
    },
    {
        href: "https://mobx.js.org/react-integration.html",
        title: "MobX and React"
    },
    {
        href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
        title: "Использование Axios с React"
    },
    {
        href: "https://ru.reactjs.org/docs/hooks-reference.html",
        title: "Справочник API хуков React"
    },
    {
        href: "https://fettblog.eu/typescript-react/hooks/",
        title: "TypeScript и React: хуки"
    },
    {
        href: "https://create-react-app.dev/docs/adding-typescript/",
        title: "npx create-react-app my-app --template typescript"
    },
    {
        href: "https://reactcommunity.org/react-transition-group/transition-group",
        title: "React Transition Group"
    },
    {
        href: "https://www.npmjs.com/package/react-transition-group?activeTab=versions",
        title: "npm i react-transition-group"
    },
    {
        href: "https://www.npmjs.com/package/react-router-dom",
        title: "npm i react-router-dom (6.9.0)"
    },
    {
        href: "https://www.npmjs.com/package/react-router-dom/v/5.3.3",
        title: "npm i react-router-dom@5.3.3"
    },
    {
        href: "https://habr.com/ru/company/kts/blog/598835/",
        title: "Что нового в react-router v6"
    },
    {
        href: "https://www.youtube.com/playlist?list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE",
        title: "React Router v6. Михаил Непомнящий. 10 видео "
    },
    {
        href: "https://www.npmjs.com/package/@types/react-router-dom",
        title: "npm i @types/react-router-dom  npm install --save @types/react-router-dom (types)"
    },
    {
        href: "https://betterprogramming.pub/12-react-hooks-every-react-developer-should-know-9c6352b81329",
        title: "12 хуков React, которые должен знать каждый разработчик React"
    },
    {
        href: " ",
        title: " "
    },
    {
        href: " ",
        title: " "
    },
    {
        href: " ",
        title: " "
    },
];
exports.arrayReact = [
    {
        heading: "Что такое React? ",
        answer: [
            "React - это интерфейсная библиотека JavaScript, разработанная Facebook в 2011 году",
            "В нем используется компонентный подход, который помогает в создании повторно используемых компонентов пользовательского интерфейса.",
            "Он используется для разработки сложных и интерактивных веб-и мобильных интерфейсов.",
            "Несмотря на то, что он был доступен с открытым исходным кодом только в 2015 году, его поддерживает одно из крупнейших сообществ.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Реальный DOM.",
        answer: [
            "1. Обновляется медленно.",
            "2. Можно напрямую обновлять HTML.",
            "3. Создает новый DOM, если элемент обновляется. ",
            "4. Манипуляции с DOM очень дороги.",
            "5. Слишком много потерь памяти. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Виртуальный DOM.",
        answer: [
            "Virtual DOM - легковесный JavaScript объект, который представляет копию реального DOM дерева. Нужен для оптимизации взаимодействия с DOM",
            "1. Обновляется быстрее. ",
            "2. Невозможно напрямую обновить HTML. ",
            "3. Обновляет элемент JSX, если обновляется. ",
            "4. Манипулировать DOM очень просто. ",
            "5. Отсутствие потерь памяти.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что вы понимаете под виртуальным DOM? Объясните его работу. ",
        answer: [
            "Виртуальный DOM - это облегченный объект JavaScript, который изначально является просто копией реального DOM. ",
            "Этот виртуальный DOM работает в три простых шага: ",
            "1. Всякий раз, когда какие-либо базовые данные изменяются, весь пользовательский интерфейс повторно отображается в виртуальном представлении DOM. ",
            "2. Затем вычисляется разница между предыдущим представлением DOM и новым.",
            "3. Как только расчеты будут выполнены, реальный DOM будет обновлен только теми вещами, которые действительно изменились.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Каковы особенности React? ",
        answer: [
            "React использует виртуальный DOM вместо реального DOM.",
            "React использует рендеринг на стороне сервера. ",
            "Это следует за однонаправленным потоком данных или привязкой данных. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие основные преимущества есть в React?",
        answer: [
            "Увеличивает производительность отрисовки приложений.",
            "Может использоваться и на клиенте и на сервере. ",
            "Из-за JSX читаемость кода увеличивается. ",
            "Легко интегрировать с другими фреймворками. ",
            "Легко писать unit тесты",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие есть ограничения в React?",
        answer: [
            "React - это просто библиотека, а не полноценный фреймворк. ",
            "Его библиотека очень большая, и для ее понимания требуется время. ",
            "Начинающим программистам может быть немного сложно понять.",
            "Кодирование становится сложным, поскольку в нем используются встроенные шаблоны и JSX.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое JSX?",
        answer: [
            "JSX - это сокращение от JavaScript XML.",
            "Это специальный синтаксис, который расширяет JavaScript возможностью писать HTML внутри. ",
            "Это позволяет интегрировать шаблоны компонентов прямо в JavaScript, что делает разработку проще. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Почему браузеры не могут читать JSX? ",
        answer: [
            "Браузеры могут читать только объекты JavaScript, но JSX не в обычном объекте JavaScript. ",
            "Таким образом, чтобы браузер мог читать JSX, сначала нам нужно преобразовать файл JSX в объект JavaScript с помощью JSX-трансформеров, таких как Babel, а затем передать его браузеру. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое компонент в React и каковы два основных способа их определения??",
        answer: [
            "Компоненты - это независимые, многоразовые строительные блоки пользовательского интерфейса приложения React. Компоненты независимы друг от друга, не влияют на остальную часть пользовательского интерфейса.",
            "Классовый компонент: компонент, реализованный с использованием классов ES6, расширяющих React.Component.",
            "Функциональный компонент: компонент, реализованный функцией JS, которая принимает аргумент props и возвращает элемент React.",
            "Функциональные компоненты, в большинстве случаев, заменяют классовые компоненты с помощью React Hooks.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Когда следует использовать классовые компоненты, а когда функциональные? ",
        answer: [
            "Если нужны жизненные этапы компонента - используем class компоненты. ",
            "Иначе для оптимизации лучше функциональные ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Недостатки функциональных компонентов.",
        answer: [
            "Нет эквивалентов - хуков для жизненных циклов: getSnapshotBeforeUpdate (получить снимок перед обновлением) и componentDidCatch (компонент поймал) ",
            "Старые сторонние библиотеки могут быть несовместимы с хуками.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Недостатки компонентов класса.",
        answer: [
            "Классы добавляют ненужную путаницу ради синтаксического сахара. ",
            "Классы приводят к громоздкому иерархическому дереву, особенно во время повторного использования кода, что приводит к снижению производительности и сложности тестирования. ",
            "Методы жизненного цикла класса разделяют связанные фрагменты кода. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Назовите разницу между контролируемым (управляемым) и неконтролируемым (неуправляемым) компонентом ",
        answer: [
            " Оба являются способами реализации элементов управления формы в React.",
            " Контролируемый компонент обладает своим стейтом. Данные формы обрабатываются компонентом React. Контролируемые компоненты являются рекомендуемым способом реализации форм.",
            " Неконтролируемые компоненты обладают внутренним стейтом (как пример значение тега textarea). Данные формы обрабатываются самим DOM. Неконтролируемые компоненты являются опцией при преобразовании устаревших баз кода в React или интеграции с не-React библиотекой¹",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между контролируемым и неконтролируемым компонентом в React? ",
        answer: [
            "В React контролируемый компонент - это компонент, состояние которого контролируется родительским компонентом. Родительский компонент передает состояние в качестве реквизита (props) контролируемому компоненту, а также обрабатывает любые изменения состояния с помощью функций обратного вызова. Контролируемый компонент отображает только полученные реквизиты и не имеет собственного состояния. ",
            "С другой стороны, неконтролируемый компонент поддерживает свое собственное внутреннее состояние и обновляет его с помощью событий DOM. Компонент напрямую обновляет DOM и не полагается на родительский компонент для передачи и обновления состояния. ",
            "Примером контролируемого компонента является ввод формы, который получает свое значение от родительского компонента в качестве реквизита и обновляет состояние родительского компонента с помощью функции обратного вызова при изменении ввода. Неконтролируемым компонентом будет ввод формы, который поддерживает свое собственное внутреннее состояние и обновляет значение непосредственно при изменении ввода, без необходимости в функции обратного вызова. ",
            "В целом, контролируемые компоненты считаются более предсказуемыми и их легче отлаживать, чем неконтролируемые компоненты. Они также упрощают реализацию комплексной проверки и обработки ошибок. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Назовите разницу между Презентационным и Контейнер компонентом?",
        answer: [
            "Презентационный - “как вещи выглядят”. Нужен для создания интерфейса. Работает на входящих параметрах ",
            "Контейнер - “как вещи работают”. Обладают состоянием, подключены к Flux или Redux",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое props? ",
        answer: [
            "Props - это сокращение от Properties.",
            "Props - набор конфигураций, поступающий от родительского компонента в дочерний компонент.",
            "Всегда идут от родителя к ребенку.",
            "Они доступны только для чтения и их нельзя менять.",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое state? ",
        answer: [
            "state - это обычный объект JavaScript, управляемый внутри компонента. ",
            "state - источник (структура) данных, который определяет отображение и поведение компонента, изменения и отслеживания пользовательских действий.",
            "В отличие от props, state можно изменять.",
            "Изменение state вызывает обновления для запуска повторного рендеринга.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем разница между state и props? ",
        answer: [
            "state - структура данных, необходимая для изменения и отслеживания пользовательских действий.",
            "props - набор конфигурации, поступающий от родительского элемента. Их нельзя изменять. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что вызывает обновление компонента?",
        answer: [
            "Повторный рендеринг родителя, который может повлечь за собой новые props ",
            "SetState () ",
            "(B) forceUpdate () (и этого следует избегать!) ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое refs в React? Перечислите некоторые случаи, когда вам следует использовать refs.",
        answer: [
            "Сокращенно от References. Специальный атрибут, позволяющий получить доступ до конкретного узла DOM или элемента React. ",
            "Нужен для: ",
            "Возможных измерений DOM элемента, его координат.",
            "Вызова анимаций.",
            "Для задания фокуса или выделения текста.",
            "Взаимодействия со сторонними библиотеками, для добавления методов к компонентам.",
            "Можно возвращать ссылки на определенный элемент или компонент, возвращаемый render().",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое JEST?",
        answer: [
            "JavaScript фреймворк, для юнит тестирования на основе Jasmine. Разработал Facebook. Очень удобен именно для React. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что делает setState() и как это работает? ",
        answer: [
            "Вначале React соединяет объект стейта с измененными полями.",
            "Когда состояние изменяется, компонент отвечает повторным рендерингом.",
            "На основе нового состояния строит новое дерево React элементов и выясняет, какие именно части приложения должны быть изменены. ",
            "Это нужно для наиболее производительного обновления интерфейса.",
            "Вызовы setState() являются асинхронными и могут быть пакетными. ",
            "Обновления state не отражают новое значение сразу после вызова setState(). Нужен useEffect(). ",
            "Из-за своей асинхронной природы вызов метода setState () путем передачи объекта, содержащего значение текущего состояния, может привести к неожиданному поведению.",
            "Передача setState () функции, а не объекта, позволяет получить доступ к значению текущего состояния, избегая потенциально непредвиденного поведения, вызванного асинхронностью.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Когда следует делать асинхронные запросы на сервер в React? ",
        answer: ["Для этого служит метод componentDidMount. ", "Или useEffect с пустым набором зависимостей.", " "],
        isParagraph: true
    },
    {
        heading: "В чем смысл специального атрибута key?",
        answer: [
            "Атрибут позволяет React понимать, какие именно элементы в списке были модифицированы или удалены, что увеличивает производительность рендеринга.",
            "Лучше всего использовать уникальные значения, такие как ID. Индексы рекомендуется использовать только в тех случаях, когда точно не будет удалений этих элементов и нет возможности использовать id. ",
            "Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в DOM. Эти ключи должны быть уникальным номером или строкой, с помощью которых React просто переупорядочивает элементы, а не перерисовывает их. Это приводит к увеличению производительности приложения. ",
        ],
        isParagraph: true
    },
    {
        heading: "Основная задача React",
        answer: [
            "Основная задача React — выяснить, как изменить DOM, чтобы он соответствовал тому, что компоненты хотят отображать на экране. ",
            "React делает это путем «монтирования» (добавления узлов в DOM), «размонтирования» (удаления их из DOM) и «обновления» (внесения изменений в узлы, уже находящиеся в DOM). ",
            "То, как узел React представлен как узел DOM, а также где и когда он появляется в дереве DOM, управляется API верхнего уровня. ",
            "Процесс создания экземпляров и узлов DOM, соответствующих компонентам React, и вставки их в DOM называется монтированием. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что значит компонент mounted?",
        answer: ["Компонент смонтирован, выводится, рендерится. Шаблон компонента соединен с DOM деревом", " "],
        isParagraph: true
    },
    {
        heading: "Что такое фрагменты?",
        answer: [
            "Специальный элемент в React позволяющий возвращать группу элементов без дополнительного родительского DOM элемента.",
            "<></> ",
            "<React.Fragment></React.Fragment>",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое событие в React? ",
        answer: [
            "В React события - это срабатывающие реакции на определенные действия, такие как наведение курсора мыши, щелчок мышью, нажатие клавиши и т. д. ",
            "Обработка этих событий аналогична обработке событий в элементах DOM. Но есть некоторые синтаксические различия, такие как:",
            "События называются с использованием верблюжьего регистра, а не просто с использованием нижнего регистра. ",
            "События передаются как функции, а не строки.",
            "Аргумент event содержит набор свойств, специфичных для события. Каждый тип события содержит свои собственные свойства и поведение, доступ к которым возможен только через его обработчик событий. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как React обрабатывает пользовательские события?",
        answer: [
            "Добавляет один обработчик события на корневой элемент.",
            "Объект события оборачивает в свою обертку - SyntheticEvent для кроссбраузерности.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Назовите основные этапы жизненного цикла компонента ",
        answer: [
            "componentWillMount (компонент будет монтироваться) - выполняется непосредственно перед рендерингом как на стороне клиента, так и на стороне сервера. В основном для настройки компонента.",
            "render - процесс рендеринга (отдачи). ",
            "componentDidMount (компонент смонтировал) - уведомляет, про то, что компонент соединен с DOM деревом. Выполняется на стороне клиента только после первого рендеринга.",
            "componentWillReceiveProps (компонент получает свойства) - уведомляет, про то, что приходят новые входящие свойства в компонент. Вызывается сразу после получения props от родительского класса и перед вызовом другого рендеринга.",
            "shouldComponentUpdate (следует обновить компонент) - возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг.",
            "componentWillUpdate (компонент будет обновляться) - уведомляет, что компонент будет обновлен. Вызывается непосредственно перед рендерингом в DOM.",
            "componentDidUpdate (компонент сделал обновление) - уведомляет, что компонент был обновлен. Вызывается сразу после выполнения рендеринга.",
            "componentWillUnmount (компонент будет размонтирован) - используется для удаления слушателей и очистки памяти компонента. Вызывается перед удалением компонента, после отключения компонента от DOM.",
        ],
        isParagraph: true
    },
    {
        heading: "В setState можно передавать объект или функцию. В чем разница и что лучше использовать? ",
        answer: [
            "props и state могут изменяться асинхронно. ",
            "Если мы передадим функцию, то мы точно будет знать, что стейт основывается на предыдущем состоянии.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Context? ",
        answer: [
            "Context - позволяет передавать свойства от родителя к ребенку, избегая промежуточных компонентов.",
            "Контекст в React — это концепция, которая позволяет вам снабжать дочерние компоненты глобальными данными, независимо от того, насколько глубоко они находятся в дереве компонентов.",
            "Для использования контекста требуется 3 шага: создание, предоставление и использование контекста. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Higher-Order компоненты?",
        answer: [
            "Компонент высшего порядка.",
            "Higher-order component (HOC) - функции, у которых входящий параметр компонент. Возвращают новый компонент с добавленным поведением.",
            "Могут быть использованы в следующих случаях: ",
            "1. Переиспользование кода. ",
            "2. Слой абстракции для state и взаимодействия с ним.",
            "3. Управление props",
            "Компонент более высокого порядка - это усовершенствованный способ повторного использования логики компонента. По сути, это шаблон, который вытекает из композиционной природы React. HOC - это пользовательские компоненты, которые включают в себя другой компонент. Они могут принимать любой динамически предоставляемый дочерний компонент, но они не будут изменять или копировать какое-либо поведение своих входных компонентов. Можно сказать, что HOC - это 'чистые' компоненты. ",
        ],
        isParagraph: true
    },
    {
        heading: " Что вы можете сделать с HOC?",
        answer: [
            "HOC можно использовать для многих задач, таких как:",
            "1. Повторное использование кода, логика и абстракция начальной загрузки. ",
            "2. Рендеринг с высоким коэффициентом.",
            "3. Абстракция состояния и манипулирование.",
            "4. Манипуляции со свойствами (пропсами).",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что делает shouldComponentUpdate (следует обновить компонент) и почему он важен? ",
        answer: [
            "Этап жизненного цикла, который решает, будет ли ре-рендер, или нет.",
            "Позволяет оптимизировать приложение",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое Redux?",
        answer: [
            "Библиотека для работы с потоком данных в JavaScript.",
            "Позволяет добавить дополнительный слой для приложения, где состояние описано в JavaScript объекте.  ",
            "Нужно для более удобного написания кода ",
            "Приложения, разработанные с помощью Redux, легко тестируются и могут работать в различных средах, демонстрируя согласованное поведение. ",
        ],
        isParagraph: true
    },
    {
        heading: "Каким трем принципам следует Redux? ",
        answer: [
            "1. Единый источник истины: состояние всего приложения хранится в дереве объектов / состояний в одном хранилище. Единое дерево состояний упрощает отслеживание изменений с течением времени и отладку или проверку приложения.",
            "2. Доступно только для чтения: Состояние Единственный способ изменить состояние - запустить действие. Действие - это простой JS-объект, описывающий изменение. Точно так же, как состояние - это минимальное представление данных, действие - это минимальное представление изменений в этих данных.",
            "3. Изменения вносятся с помощью чистых функций: чтобы указать, как дерево состояний преобразуется действиями, вам нужны чистые функции. Чистые функции - это те, возвращаемое значение которых зависит исключительно от значений их аргументов.",
        ],
        isParagraph: true
    },
    {
        heading: "Что вы понимаете под “внутренним источником правды”? ",
        answer: [
            "Redux использует ‘Хранилище’ для хранения всего состояния приложения в одном месте. Таким образом, все состояния компонентов хранятся в хранилище, и они получают обновления из самого хранилища. Единое дерево состояний упрощает отслеживание изменений с течением времени и отладку или проверку приложения.",
        ],
        isParagraph: true
    },
    {
        heading: "Перечислите компоненты Redux.",
        answer: [
            "Redux состоит из следующих компонентов: ",
            "1. Action - это объект, который описывает то, что произошло.",
            "2. Reducer - это место, где можно определить, как изменится состояние.",
            "3. Store — дерево состояний/объектов всего приложения сохраняется в Store (хранилище).",
            "4. View (просмотр) - просто отображает данные, предоставленные Store.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое action в Redux?",
        answer: [
            "Объект, который обязательно должен содержать ключ type. С помощью него Redux понимает, что именно нужно сделать со state.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Объясните роль Reducer. ",
        answer: [
            "Reducer - это чистые функции, которые определяют, как изменяется состояние приложения в ответ на action. Редукторы работают, принимая предыдущее state и action, а затем возвращают новый state. Он определяет, какое обновление необходимо выполнить, в зависимости от типа action, а затем возвращает новые значения. Он возвращает предыдущее состояние как есть, если не нужно выполнять никакой работы.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что такое store в Redux? ",
        answer: [
            "JavaScript объект, в котором содержится состояние приложения. Дополнительно отвечает за следующее:",
            "1. state может быть получен через getState(). ",
            "2. Изменять state можно через dispatch(action). ",
            "3. Регистрировать изменения через subscribe(listener).",
            "Хранилище - это объект JavaScript, который может хранить состояние приложения и предоставлять несколько вспомогательных методов для доступа к состоянию, отправки действий и регистрации слушателей. Все дерево состояний / объектов приложения сохраняется в одном хранилище. В результате этого Redux очень прост и предсказуем. Мы можем передать промежуточное программное обеспечение в хранилище для обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. Все действия возвращают новое состояние через редукторы. ",
        ],
        isParagraph: true
    },
    {
        heading: " Каковы преимущества Redux?",
        answer: [
            "Преимущества Redux перечислены ниже: ",
            "1. Предсказуемость результата - поскольку всегда есть один источник истины, то есть store, нет путаницы в том, как синхронизировать текущее состояние с actions и другими частями приложения. ",
            "2. Ремонтопригодность – код становится легче поддерживать с предсказуемым результатом и строгой структурой.",
            "3. Рендеринг на стороне сервера – вам просто нужно передать хранилище, созданное на сервере, на сторону клиента. Это очень полезно для первоначального рендеринга и обеспечивает лучший пользовательский интерфейс, поскольку оптимизирует производительность приложения.",
            "4. Инструменты разработчика - от действий до изменений состояния, разработчики могут отслеживать все, что происходит в приложении в режиме реального времени.",
            "5. Сообщество и экосистема - за Redux стоит огромное сообщество, что делает его еще более увлекательным в использовании. Большое сообщество талантливых людей вносит свой вклад в улучшение библиотеки и разрабатывает с ее помощью различные приложения.",
            "6. Простота тестирования - код Redux в основном состоит из небольших, чистых и изолированных функций. Это делает код тестируемым и независимым.",
            "7. Организация - Redux точно определяет, как должен быть организован код, это делает код более последовательным и простым, когда с ним работает команда.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Что нельзя делать в методе render?",
        answer: [
            "Нельзя изменять состояние компонента (например вызывать setState). ",
            "Должен быть чистой (pure) функцией. ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Какие типы middleware есть в redux для работы с асинхронностью?",
        answer: ["1. Redux Thunk.", "2. Redux Promise. ", "3. Redux Saga. ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: "Что такое Pure Components? ",
        answer: [
            "Тоже самое, что и Component, кроме того, что автоматически за вас реализует метод shouldComponentUpdate (следует обновить компонент). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Почему не стоит изменять state напрямую?",
        answer: [
            "Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. ",
            "Корректно использовать метод setState(). ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Как изменить state используя динамический ключ? ",
        answer: ["inputChangeHandler(event) {", "setState({", "[event.target.name]: event.target.value  ", "}) ", " ", " "],
        isParagraph: true
    },
    {
        heading: "Что такое React Hooks?",
        answer: [
            "Функционал, добавленный в React 16.8. С помощью хуков, можно писать приложения, используя только функциональные компоненты, без классов. ",
            "С помощью хуков можно следить за стейтом, эмулировать жизненные этапы компонента, работа с ссылками и многое другое.",
        ],
        isParagraph: true
    },
    {
        heading: "useState()",
        answer: [
            "const [ state, setState ] = useState( initialState ); ",
            "Возвращает значение с состоянием (state) и функцию для его обновления (setState). ",
            "Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState). ",
            "Функция setState используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента: setState(newState);",
            " ",
            "Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым последним состоянием после применения обновлений. ",
            "Использование в setState объекта: ",
            "setState( initialState ) ",
            "-- ",
            "Использование в setState функции: ",
            "1. setState(( prev) => !prev ) ",
            "2. setState(( prev) => prev + 1 ) ",
            "3. setState(( prev) => prev - 1) ",
            "- ",
            "useState не объединяет объекты обновления автоматически. Вы можете повторить это поведение, комбинируя форму функции обновления с синтаксисом расширения объекта: ",
            "const [state, setState] = useState({}); ",
            "setState(prevState => { ",
            " - // Object.assign также будет работать",
            " - return {...prevState, ...updatedValues};",
            "}); ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useEffect()",
        answer: [
            "useEffect(() => { функция }, [ массив зависимостей ]) ",
            "Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране. ",
            "По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Очистка эффекта (компонента).",
        answer: [
            "Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку, идентификатор таймера или прослушиватель событий. Чтобы сделать это, функция переданная в useEffect, может вернуть функцию очистки. Например, чтобы создать / удалить прослушиватель событий: ",
            "useEffect(() => { ",
            " - // Добавляем прослушиватель событий",
            " - document.addEventListener('scroll', scrollHandler);",
            " - return function () {",
            " - - // Очищаем компнонент перед тем, как он покинет экран: удаляем прослушиватель событий",
            " - - document.removeEventListener('scroll', scrollHandler);",
            " - };",
            "}, [top]); ",
            "-- ",
            "Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта. В нашем примере это означает, что прослушиватель событий создаётся при каждом обновлении и удаляется перед закрытием.  ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "Условное срабатывание эффекта, массив зависимостей хуков.",
        answer: [
            "По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда пересоздаётся, если значение какой-то из зависимости изменилось. ",
            "Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп source.",
            "Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом зависимостей, от которых зависит эффект. Наш обновлённый пример теперь выглядит так: ",
            "useEffect( ",
            " - () => {",
            " - - const subscription = props.source.subscribe();",
            " - - return () => {",
            " - - - subscription.unsubscribe();",
            " - - };",
            " - }, [props.source],",
            "); ",
            "Теперь подписка будет создана повторно только при изменении props.source. ",
            "-- ",
            "Примечание: ",
            "Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом. В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров. Отдельные страницы документации рассказывают о том, как поступить с функциями и что делать с часто изменяющимися массивами. ",
            "Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ([]) вторым аргументом. React посчитает, что ваш эффект не зависит от каких-либо значений из пропсов или состояния и поэтому не будет выполнять повторных запусков эффекта. ",
            "Если вы передадите пустой массив ([]), пропсы и состояние внутри эффекта всегда будут иметь значения, присвоенные им изначально.",
            "Не забывайте, что React откладывает выполнение useEffect, пока браузер не отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой.",
            "Массив зависимостей не передаётся в качестве аргументов функции эффекта. Тем не менее, в теории вот что происходит: каждое значение, на которое ссылается функция эффекта, должно также появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создать этот массив автоматически.",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useContext()",
        answer: [
            "const value = useContext( MyContext );",
            "Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве. ",
            "Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext. Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext. ",
            "Запомните, аргументом для useContext должен быть непосредственно сам объект контекста: ",
            " - Правильно: useContext( MyContext )",
            " - Неправильно: useContext(MyContext.Consumer)",
            " - Неправильно: useContext(MyContext.Provider)",
            "Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации. ",
            "useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста. ",
            "Соединим все вместе с Context.Provider: ",
            "------------------------------------------ ",
            "-- Создадим файл context/index.ts -- ",
            "import { createContext } from 'react'; ",
            "-- ",
            "interface IAuthContext { ",
            " - isAuth: boolean;",
            " - setAuth: React.Dispatch< React.SetStateAction < boolean >>;",
            "} ",
            "-- ",
            "export const AuthContext = createContext< IAuthContext > ({ ",
            " - isAuth: false,",
            " - setAuth: () => {},",
            "}); ",
            "------------------------------------------ ",
            "-- функциональный компонент App -- ",
            "import React, { FC, useState } from 'react'; ",
            "import AppRouter from '../AppRouter'; ",
            "import { AuthContext } from '../../context/index'; ",
            "-- ",
            "const App: FC = () => { ",
            " - const [ isAuth, setAuth ] = useState< boolean >( false ); ",
            "-- ",
            "- return ( ",
            " - - <div>",
            " - - - <AuthContext.Provider value = {{ isAuth, setAuth }} >",
            " - - - - <AppRouter />",
            " - - - </AuthContext.Provider>",
            " - - </div>",
            " - );",
            "}; ",
            "export default App; ",
            "------------------------------------------ ",
            "-- функциональный компонент TopMenu -- ",
            "import React, { FC, useContext } from 'react'; ",
            "- ",
            "const TopMenu: FC = () => { ",
            " - const { isAuth, setAuth } = useContext( AuthContext ); ",
            " - const openAdminLogin = () => { setAuth ( true ) }",
            " - const closeAdminLogin = () => { setAuth ( false ) }",
            " ",
            " - return ( ",
            " - - // .... ",
            " - )",
            "export default TopMenu; ",
            "------------------------------------------ ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useMemo()",
        answer: [
            "const memoizedValue = useMemo(() => { computeExpensiveValue ( a, b ) }, [ a, b ] ",
            "Возвращает мемоизированное значение. ",
            "Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. ",
            "Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo. ",
            "Если массив не был передан, новое значение будет вычисляться при каждом рендере. ",
            "Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана.",
            "Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.",
            "-- ",
            "Без useMemo: ",
            "const newsFilteredByYear = [ ...news ].filter(( item ) => {",
            " - return new Date( item.date ).getFullYear() === Number( selectedYear );",
            " - });",
            "-- ",
            "С добавлением useMemo: ",
            "const newsFilteredByYear = useMemo( () => { ",
            " - return [ ...news ].filter(( item ) => {",
            " - - return new Date( item.date ).getFullYear() === Number( selectedYear );",
            " });",
            "}, [ news, selectedYear ]); ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "useRef()",
        answer: [
            "import React, { FC, useRef } from 'react'; ",
            "-- ",
            "В функциональном компоненте: ",
            "const refColumn = useRef< HTMLDivElement > ( null ); ",
            "-- ",
            "useEffect(() => { ",
            "if ( refColumn.current ) { ",
            "emitWidthColumn ( refColumn.current?.offsetWidth ); ",
            "} ",
            "}, [ emitWidthColumn ]); ",
            "-- ",
            "В jsx: ",
            " return ( ",
            " - <div ref = { refColumn }> ",
            " - - - <div> {title} </div>",
            " - </div> ",
            "); ",
            " ",
            " ",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
    {
        heading: " ",
        answer: [" ", " ", " ", " ", " ", " "],
        isParagraph: true
    },
];

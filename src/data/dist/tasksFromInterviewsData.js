"use strict";
/* eslint-disable no-useless-escape */
/* eslint-disable no-template-curly-in-string */
exports.__esModule = true;
exports.arrayTasks = void 0;
exports.arrayTasks = [
    {
        heading: "Удалить пробелы из строки. Метод string.replace() с регулярным выражением внутри.",
        href: "https://www.youtube.com/watch?v=awtOmYDEMY8&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=4",
        taskCode: [
            "const [ str, setStr ] = useState(' ftu ft ggwr '); ",
            "const [ strNoSpace, setStrNoSpace ] = useState(''); ",
            "- ",
            "function noSpace(x: string) { ",
            "         return x.replace(/s/g, ''''); ",
            "} ",
            "useEffect(() => {",
            "         setStrNoSpace(noSpace(str)); ",
            "}, [ str ]); ",
            "- ",
            "   console.log(str); // ' ftu ft ggwr ' ",
            "   console.log(strNoSpace); // ftuftggwr ",
            "-*- ",
        ]
    },
    {
        heading: "Очистить строку от числовых символов. Метод string.replaceAll() с регулярным выражением внутри. ",
        href: "https://www.youtube.com/watch?v=oQ-0bm9-_yA&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=6",
        taskCode: [
            "const [ elem ] = useState( 'This looks5 grea8te' ); ",
            "const [ elemClear, setElemClear ] = useState( '' );",
            "- ",
            "function stringCleaner( s: string ) { ",
            "      return s.replaceAll( /d/g, '''' );",
            "} ",
            "useEffect(() => { ",
            "      setElemClear( stringCleaner( elem )); ",
            "}, [ elem ]); ",
            "- ",
            "   console.log( elem ); // 'This looks5 grea8te' ",
            "   console.log( elemClear ); // This looks greate ",
            "-*- ",
        ]
    },
    {
        heading: "Чётное или нечётное? ",
        href: "https://www.youtube.com/watch?v=KwU3wq5DT90&t=77s",
        taskCode: [
            "const number = 1263; ",
            "const number2 = 1264; ",
            "- ",
            "function even_or_odd(number: number) { ",
            "      return number % 2 === 0 ? 'чётное' : 'нечётное'; ",
            "}",
            "- ",
            "   console.log(even_or_odd(number)); // нечётное ",
            "   console.log(even_or_odd(number2)); // чётное ",
            "-*- ",
        ]
    },
    {
        heading: "Вывод пользователей, которые лайкнули публикацию. Используем switch. ",
        href: "https://www.youtube.com/watch?v=XoKmzVPoQ_0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=1&t=20s",
        taskCode: [
            "Дан массив пользователей, которые лайкнули публикацию. Необходимо вывести имена этих пользователей строкой. Используем конструкцию switch.",
            "const printPeopleLiked = (names: string[]) => { ",
            "  switch (names.length) { ",
            "     case 0:",
            "       return 'Нет лайков';",
            "     case 1:",
            "       return `${names[0]} поставил лайк`;",
            "     case 2:",
            "       return `${names[0]} и ${names[1]} поставили лайк`;",
            "     case 3:",
            "       return `${names[0]}, ${names[1]} и ${names[2]} поставили лайк`;",
            "     default:",
            "       return `${names[0]}, ${names[1]} и ещё ${names.length - 2} поставили лайк`;",
            "  } ",
            "}; ",
            "console.log(printPeopleLiked([])); // Нет лайков ",
            "console.log(printPeopleLiked(['Max'])); // Max поставил лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy'])); // Max и Asy поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb'])); // Max, Asy и Gleb поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika'])); // Max, Asy и ещё 2 поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika', 'Boris', 'Andrey'])); // Max, Asy и ещё 4 поставили лайк ",
        ]
    },
    {
        heading: "Нужно найти сумму всех чисел, кратных 3 или 5.",
        href: "https://www.youtube.com/watch?v=WCIpXcwvXpw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=2",
        taskCode: [
            "Нужно найти сумму всех чисел, кратных 3 или 5, меньше переданного числа. Например, переданное число 16. Находим все числа, кратные 3 или 5, суммируем их и получаем результат.  ",
            "",
            "16 => 3 + 5 + 6 + 9 + 10 + 12 + 15 => 60. ",
            "- ",
            "const sum35 = ( n: number ) => { ",
            "    let sum = 0; ",
            "    for ( let i = 3; i < n; i++ ) { ",
            "        if ( i % 3 === 0 || i % 5 === 0 ) { ",
            "          sum += i; ",
            "        } ",
            "    } ",
            "    return sum;",
            "}; ",
            "- ",
            "console.log( sum35( 16 )); // 60 ",
            "console.log( sum35( 25 )); // 143 ",
            "-*- ",
        ]
    },
    {
        heading: "Разность массивов. Исключить из массива группу элементов другого массива. ",
        href: "https://www.youtube.com/watch?v=qSCy7RaJ6bg&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=3",
        taskCode: [
            "Как исключить из массива группу элементов из другого массива, например: ",
            "arrayDiff = ( [ 1, 2, 8, 2, 7, 3 ], [ 7, 2 ] ) => [ 1, 8, 3 ] ",
            "const arrayDiff = (source: number[], diff: number[]) => { ",
            "    // Метод filter отсечёт ненужные элементы по условию. Оставим в ",
            "    // результате только такие элементы, которые не входят в массив diff. ",
            "    return source.filter((item) => !diff.includes(item)); ",
            " }; ",
            "- ",
            "useEffect(() => { ",
            "    console.log(arrayDiff([2, 3, 4, 5, 6, 7, 8], [7, 2])); // (5) [3, 4, 5, 6, 8]",
            "  }, []); ",
            "-*- ",
        ]
    },
    {
        heading: "Как отформатировать строку и превратить её в телефонный номер. ",
        href: "https://www.youtube.com/watch?v=JbaVl29kVbI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=4",
        taskCode: [
            "Дана строка '1234567890'. Нужно первые три символа обернуть в скобки, потом пробел, потом три символа, дефис и ещё четыре символа: (123) 456-7890.",
            "Для подобных задач пригодятся регулярные выражения, а точнее, скобочные выражения для нахождения подстрок и метод replace().  ",
            "    // Первым аргументом в методе: поиск совпадений в строке. В нашем случае нужно запомнить первые три числовые символа (/d{3}).  (Здесь должен быть обратный слэш.) ",
            "    // Подобным образом запомним следующие 3 числа (/d{3}) и 4 после (/d{4}). (Здесь должен быть обратный слэш.) ",
            "    // Для замены текста используем обозначение '($1) $2-$3': ($1 оборачиваем в скобки - пробел, $2 - дефис, $3)",
            "- ",
            "const createPhoneNumber = (str: string) => { ",
            "    return str.replace(/(/d{3})(/d{3})(/d{4})/, '($1) $2-$3'); // (Здесь должен быть обратный слэш.)  ",
            "}; ",
            "- ",
            "useEffect(() => { ",
            "    console.log(createPhoneNumber('1234567890')); // (123) 456-7890 ",
            "}, []); ",
            "-*-",
        ]
    },
    {
        heading: "Перевести буквы в числа по их позиции в алфавите. ",
        href: "https://www.youtube.com/watch?v=_HmpuK3ori0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=5",
        taskCode: [
            "Как перевести слово в группу чисел, где каждое число - позиция буквы в алфавите. Если слово 'Азбука', то нужно превратить его в '1 8 2 20 11 1' .",
            "Для начала стандартной операции для преобразования строки, приведём её к нижнему регистру (toLowerCase()), разделим посимвольно (split('')) и будем использовать метод map(), который будет трансформировать каждый элемент массива в коллбэк внутри с одним аргументом (char => charCodeAt()). Метод charCodeAt() возвращает числовое значение юниткода для символа по указанному индексу.",
            "'Азбука'.charCodAt(0) // 1040. То есть заглавная русская буква А хранится в юникод под номером 1040. ",
            "'азбука'.charCodAt(0) // 1072. Маленькая русская буква 'а' хранится в юникод под номером 1072.",
            "  Значит, вычитая из результата число 1071, мы будем получать позицию каждой буквы в алфавите.",
            "console.log('азбука'.charCodeAt(0) - 1071); // 1 ",
            "console.log('азбука'.charCodeAt(1) - 1071); // 8 ",
            "console.log('азбука'.charCodeAt(2) - 1071); // 2 ",
            "console.log('азбука'.charCodeAt(3) - 1071); // 20 ",
            "console.log('азбука'.charCodeAt(4) - 1071); // 11 ",
            "console.log('азбука'.charCodeAt(5) - 1071); // 1 ",
            "-",
            "Наша общая функция будет выглядеть так: ",
            "const alphabetPosition = (str: string) => { ",
            "    return str ",
            "        .toLowerCase() ",
            "        .split('') // по пустому разделителю",
            "        .map((char) => char.charCodeAt(0) - 1071)",
            "        .join(' '); // по пробелу",
            "}; ",
            "console.log(alphabetPosition('Азбука')); // 1 8 2 20 11 1 ",
            "-*-",
        ]
    },
    {
        heading: "Схлопнуть соседние элементы. ",
        href: "https://www.youtube.com/watch?v=hnmmm9iOAUo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=6",
        taskCode: [
            "Напишите функцию, которая принимает последовательность (это может быть массив или строка) и возвращает массив, где повторяющиеся сосоедние элементы схлопнулись до одного. Исходный порядок элементов нужно сохранить. ",
            "Решим эту задачу через фильтр. Для этого развернём нашу последовательность на входе ( iterable ) => [ ...iterable ]. Мы получим массив, даже если заспредим строку. Затем отфильтруем элементы этого массива таким образом, чтобы в новый массив попали только те элементы, которые не равны элементу из последовательности по индексу и -1",
            "Наша функция будет выглядеть так:",
            "function uniqueInOrder(iterable: string | string[] | number[]) { ",
            "    return [...iterable].filter((el, index) => el !== iterable[index - 1]); ",
            "} ",
            "- ",
            "console.log(uniqueInOrder('AAAABBBCCDAABBB')); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
            "console.log(uniqueInOrder('ABBCcAD')); // ['A', 'B', 'C', 'c', 'A', 'D'] ",
            "console.log(uniqueInOrder(['A', 'A', 'A', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B'])); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
            "console.log(uniqueInOrder([1, 1, 2, 2, 2, 3, 3, 4, 4])); // [1, 2, 3, 4] ",
            "-*-",
        ]
    },
    {
        heading: "Написать функцию по выявлению пагнрамм.",
        href: "https://www.youtube.com/watch?v=wE3YcgtTZlo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=7",
        taskCode: [
            "Написать функцию по выявлению пагнрамм - фраз, содержащих в себе все буквы алфавита. ",
            "Вычислить панграмму в JS просто: нужно занести в Set- коллекцию нашу преобразованную строку. Как её преобразовать: сначала приводим все буквы к нижнему регистру, а затем, с помощью регулярного выражения оставим только буквы русского алфавита. Используем буквы от 'а' до 'я' начала строки и букву 'ё', потому, что она не включается стандартно и глобально. Всё это заменяем на пустую строку replace(/[^а-яё]/g, '')",
            "Set- коллекция исключит из массива повторяющиеся элементы, оставит только уникальные, и у это коллекции есть метод size. Если size === 33 (количество букв в алфавите), то значит это фраза - паграмма   ",
            "- ",
            "const isPangram = (str: string) => { ",
            "    const set = new Set([...str.toLowerCase().replace(/[^а-яё/]/g, '')]); ",
            "    return set.size === 33; ",
            "}; ",
            "Эта фраза не является панграммой: ",
            "    console.log(isPangram('Мама мыла раму')); // false ",
            "Эта фраза - панграмма:",
            "    console.log(isPangram('Съешь ещё этих мягких французских булочек, да выпей же чаю')); // true ",
            "-*- ",
        ]
    },
    {
        heading: "Нарисуй ёлку из символов, например, из звёзд. ",
        href: "https://www.youtube.com/watch?v=DZ4oAPBmvDI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=8",
        taskCode: [
            "На вход поступает высота ёлки. Ёлка симметрична, поэтому нужно понять, сколько пробелов должно быть в ряду, с обоих сторон от звёзд. С самими звёздами всё ясно, их в ряду будет: 1, 3, 5, 7, 9. Для высоты = 5 будет 9 звёзд в нижнем ряду и 0 пробелов. Значит в первом ряду будет 4 пробела, 1 звезда и опять 4 пробела.",
            "const drawChristmasTree = (n: any) => { ",
            "    let tree = '\n'; ",
            "    for (let i = 0; i < n; i++) { ",
            "        const space = ' '.repeat(n - i - 1); ",
            "        tree += space + '*'.repeat(i + i + 1) + space + '\n'; ",
            "    } ",
            "    return tree; ",
            " }; ",
            "console.log(drawChristmasTree(5)); ",
            "    * ",
            "   *** ",
            "  ***** ",
            " ******* ",
            "********* ",
            "console.log(drawChristmasTree(6)); ",
            "     * ",
            "    *** ",
            "   ***** ",
            "  ******* ",
            " ********* ",
            "*********** ",
            "-*- ",
        ]
    },
    {
        heading: "Валидация строк со скобками. ",
        href: "https://www.youtube.com/watch?v=cNPsxKh4s5U&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=9",
        taskCode: [
            "-*- У меня это решение вызывает ошибку-*-",
            "Напиши валидацию строк с круглыми, квадратными и фигурными скобками. Считаем, что результат правильный, если все скобки открываются и закрываются в нужном порядке. ",
            "Например: ",
            "isValidBraces('(){}[]') // true ",
            "isValidBraces('({[]})') // true ",
            "isValidBraces('(}')     // false ",
            "isValidBraces('[(])')   // false ",
            "isValidBraces('[({}(]') // false ",
            "Стек - это структура данных, представляющие собой список элементов, организованных по принципу: последним зашёл - первым вышел.  ",
            "Мы будем идти по каждому символу в строке и класть в стек открывающиеся скобки. А если будем видеть закрывающую скобку, то будем проверять, соответсвует ли её тип с типом последней последней скобки в стеке. Если они не одного и того же типа, то можно сразу возвращать ложь, не дожидаясь завершения цикла. Если мы вышли из цикла без подобных остановок, то осталось проверить размер стека. Если он равен нулю, то это значит, что в нём не осталось открытых скобок. А значит входная строка валидна. Если хотя бы один элемент в стеке есть, то значит строка не валидна.   ",
            "const isValidBraces = (str: string) => { ",
            "    const braces = { '{': '}', '(': ')', '[': ']' }; ",
            "    const stack = []; ",
            "    for (let i = 0; i < str.length; i++) { ",
            "       const currentBrace = str[i] as keyof typeof braces;",
            "       if (braces[currentBrace]) { ",
            "           stack.push(currentBrace); ",
            "       } else if (currentBrace !== braces[stack.pop()]) { // ts(2538)",
            "       // Тип 'undefined' невозможно использовать как тип индекса.ts(2538)",
            "       // (method) Array<string>.pop(): string | undefined",
            "           return false; ",
            "       } ",
            "    } ",
            "    return stack.length === 0; ",
            "}; ",
            "-*- ",
            "У меня это решение вызывает ошибку. ",
        ]
    },
    {
        heading: "Пересечения массивов",
        href: "https://www.youtube.com/watch?v=APuD-xNMBGc&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=10",
        taskCode: [
            "Нужно написать функцию, которая принимает два массива и возвращает массив с их пересечениями - элементы должны присутствовать и в первом, и во втором массиве. Причём, элемент должен повториться в массиве два и более раза. ",
            "Для начала выбираем только повторяющие числа, для этого создадим Set- коллекцию уникальных элементов, в которой будут лежат элементы, которые хотя бы раз встречались в массиве. А в объекте pick будем собирать числа, которые повторились два или более раз.    ",
            "Пройдём по перому массиву методом forEach(), проверим для каждого числа в массиве условие: если в Set- коллекции нет текущего числа (has()), то занесём его в коллекцию. Иначе, число уже встречалось в массиве, а значит оно повторяющееся. Положим повторяющееся число в объект pick, ключём станет станет само повторяющее число из первого массива, а значением 0 - количество будущих повторений во втором массиве. Получили объект, где ключи - повторяющиеся числа из первого массива, а значения - количество повторений уже во втором массиве. Осталось только преобразовать этот объект в массив, в котором будут лежать только ключи.       ",
            "Проверим, что всё получилось так, как надо. ",
            "Так же проходим по второму массиву, если число из второго массива является ключём в объекте pick, то увеличим его значение на 1.    ",
            "const intersectNubmers = (a: number[], b: number[]) => { ",
            "    const set = new Set(); ",
            "    const pick: any = {};",
            "    // ",
            "    a.forEach((n: number) => {",
            "      if (!set.has(n)) {",
            "        set.add(n); ",
            "      } else {",
            "        pick[n] = 0;",
            "      }",
            "    }); ",
            "    // return pick; // {1: 0, 17: 0, 56: 0} // результат проверки первого массива",
            "    // Проверяем второй массив",
            "    b.forEach((n: number) => {",
            "      if (n in pick) {",
            "        pick[n] = pick[n] + 1;",
            "      }",
            "    });",
            "    // return pick; // {1: 3, 17: 2, 56: 1} // результат проверки обоих массивов",
            "    // Преобразуем объект в массив, в котором будут лежать только ключи",
            "    return Object.entries(pick).reduce((result, [n, count]) => {",
            "      if ((count as number) > 1) {",
            "        result.push(+n);",
            "      }",
            "      return result;",
            "    });",
            "}; ",
            "console.log(intersectNubmers([7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1])); ",
            "-*-",
        ]
    },
    {
        heading: "Представление числа в расширенной нотации.",
        href: "https://www.youtube.com/watch?v=ukx4y4HjhtI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=11",
        taskCode: [
            "Вернуть заданное число в виде строки в расширенной форме. Все числа будут целыми числами больше нуля. ",
            "Что такое расширенная анотация - это когда число представляется в виде суммы каждой цифры, умноженное на соответствующее значение её разряда. Например:   ",
            "expandedForm(12); // => '10 + 2' ",
            "expandedForm(42); // => '40 + 2' ",
            "expandedForm(70304); // => '70000 + 300 + 4' ",
            "--",
            "Наша функция: ",
            "const expandedForm =  ( num: number ) => {   // на входе num = 70304",
            "    return ( ",
            "        String( num ) // Переводим число в строку '70304' ",
            "            .split( '' ) // Разбиваем эту строку посимвольно [ '7', '0', '3', '0', '4' ] ",
            "            // К каждому символу прибавляем определённое количество нулей: ",
            "            .map(( n, i, arr ) => n + '0'.repeat( arr.length - i - 1 )) // [ '70000', '0000', '300', '00', '4' ] ",
            "            // Отфильтруем, оставим всё, что не равно нулю ",
            "            .filter(( n ) => Number( n ) !== 0 ) // [ '70000', '300', '4' ] ",
            "            // Объеденим элементы массива в строку, поставив между ними знак '+'",
            "            .join(' + ') // 70000 + 300 + 4",
            "     ); ",
            "}; ",
            "console.log(expandedForm(12)); // 10 + 2 ",
            "console.log(expandedForm(42)); // 40 + 2 ",
            "console.log(expandedForm(70304)); // 70000 + 300 + 4 ",
            "-*- ",
        ]
    },
    {
        heading: "Получить из массива строк те, которые являются подстроками второго массива  ",
        href: "https://www.youtube.com/watch?v=F2eYgsFuuJ0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=12",
        taskCode: [
            "Даны два массива строк a и b. Возвратить массив, в котором элементы из массива a являются подстроками строк b.",
            "const inArray = ( a: string[], b: string[] ) => { ",
            "    // Отфильтруем массив a по условию: в массиве b есть хотя бы одна срока (метод b.some( str )), ",
            "    // которая содержит в себе такую подстроку ( метод str.includes( sub ) ):",
            "    return a.filter(( sub ) => b.some(( str ) => str.includes( sub )));",
            "}; ",
            "console.log(inArray([ 'ля', 'ты', 'редис' ], [ 'коты', 'цапля', 'крысолов' ])); // [ 'ля', 'ты' ]",
            "-*-",
        ]
    },
    {
        heading: "Разбить прямоугольник на группу квадратов.",
        href: "https://www.youtube.com/watch?v=rJw30E-9kC4&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=13",
        taskCode: [
            "Нужно представить прямоугольник в виде группы квадратов. Есть прямоугольник размерами 3 * 5, мы его делим на квадраты: 3 * 3, 2 * 2, 1 * 1, 1 * 1. ",
            "Алгоритм:  ",
            "1. Нужно выбрать в нашем прямоугольнике меньшую сторону, в нашем случае - это сторона 3. Вырезаем из нашего прямоугольника квадрат 3 * 3. В остатке у нас прямоугольник 2 * 3.",
            "2. Производим точно такие операции с остаточным прямоугольником 2 * 3. Меньшая сторона равна 2, вырезаем квадарт 2 * 2. В остатке у нас прямоугольник 1 * 2.",
            "3. Продолжаем в том же духе.",
            "-*-",
            "Напишем функцию, у нас есть сторона a и сторона b. ",
            "const sqInRect = ( a: number, b: number ): number[] => {",
            "    // База рекурсии: если сторона a строго равна стороне b, то возвращаем массив из стороны a. ",
            "    if ( a === b ) return [ a ]; ",
            "    //",
            "    // Иначе, заводим константу, в которой лежат большая и меньшая стороны,",
            "    // и проверим какая сторона больше. Меньшую сторону заносим в min, большую - в max.",
            "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
            "    //",
            "    // Мы определились, какая сторона наименьшая, а какая наибольшая и остаётся одна операция с рекурсией.",
            "    // Возвратим массив, в котором будет лежать наша минимальная сторона,",
            "    // воспользуемся спред- оператором, потому, что мы каждый раз будем возвращать массив.",
            "    // Используем функцию sqInRect(), внутри которой у нас разность сторон",
            "    // и минимальная сторона - размеры остаточного прямоугольника.",
            "    return [ min, ...sqInRect( max - min, min )];",
            "}; ",
            "-*-",
            "Функция в чистом виде: ",
            "const sqInRect = ( a: number, b: number ): number[] => { ",
            "    if ( a === b ) return [ a ]; ",
            "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
            "    return [ min, ...sqInRect( max - min, min )];",
            "}; ",
            "console.log(sqInRect(5, 3));    // [ 3, 2, 1, 1 ] ",
            "console.log(sqInRect(3, 5));    // [ 3, 2, 1, 1 ] ",
            "console.log(sqInRect(7, 5));    // [ 5, 2, 2, 1, 1 ] ",
            "console.log(sqInRect(20, 14));  // [ 14, 6, 6, 2, 2, 2 ] ",
            "-*-",
        ]
    },
    {
        heading: "Валидация IP-адреса ",
        href: "https://www.youtube.com/watch?v=_d3Q2xStf8E&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=14",
        taskCode: [
            "Нужно свалидировать IP-адрес. Адрес следует считать действительным, если он состоит из четырёх групп чисел со значением от 0 до 255 включительно. ",
            "Примеры допустимых входных данных: ",
            "// 1.2.3.4 ",
            "// 123.45.67.89 ",
            "Недопустимые примеры ввода: ",
            "// 1.2.3 ",
            "// 1.2.3.4.5",
            "// 123.456.78.90 ",
            "// 123.045.067.089 ",
            "-*-",
            "const isValid = (str: string) => { ",
            "    // На входе строка '12.255.56.1'. Для начала выделяем группы чисел, разделяем ",
            "    // строчку посимвольно методом split() с разделитетелем точка '.'",
            "    const numbers = str.split('.'); // ['12', '255', '56', '1']",
            "    //",
            "    // Сраниваем получившиеся количество групп с заданным числом: numbers.length === 4",
            "    // В filter((n) => +n) приводим строку к числу (+n) и проверяем это число",
            "    // на соответствие интервалу от 0 до 255",
            "    // String(+n).length <= таким образом мы обрабатываем такой IP: 'n1.2.3.4'",
            "    //",
            "    return (",
            "        numbers.length === 4 ",
            "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
            "            && n.length === String(+n).length).length === 4",
            "    );",
            "}; ",
            "-*- ",
            "Пишем нашу функцию в чистом виде: ",
            "const isValid = ( str: string ) => { ",
            "    const numbers = str.split('.');",
            "    return (",
            "        numbers.length === 4 ",
            "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
            "            && n.length === String(+n).length).length === 4",
            "    );",
            "}; ",
            "-*-",
            "console.log(isValid( '0.0.0.0' ));         // [ '0', '0', '0', '0' ]        // true ",
            "console.log(isValid( '12.255.56.1' ));     // [ '12', '255', '56', '1' ]    // true ",
            "console.log(isValid( '137.255.1.100' ));   // [ '137', '255', '1', '100' ]  // true ",
            "console.log(isValid( '123.456.789.0' ));   // [ '123', '0' ]                // false ",
            "console.log(isValid( 'abc.def.ghi.jkl' )); // []                            // false ",
            "console.log(isValid( 'n1.2.3.4' ));        // [ '2', '3', '4' ]             // false ",
            "console.log(isValid( '' ));                // false                         // false ",
            "-*-",
        ]
    },
    {
        heading: "Сколько ещё в очереди стоять? ",
        href: "https://www.youtube.com/watch?v=YLc1G12T_jY&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=15",
        taskCode: [
            "В супермаркете очередь к кассам самообслуживания. Нужно написать функцию для расчёта общего времени, необходимого всем покупателям для оформления заказов. Несколько уточнений:",
            "    - существует только ОДНА очередь, обслуживающая множество касс;",
            "    - порядок очереди НИКОГДА не меняется и первый человек в очереди (то есть первый элемент в массиве) проходит к кассе, как только она освобождается. ",
            "Аргументы функции: ",
            "    'customers'- клиенты: массив положительных целых чисел - людей, представляющих очередь. Каждое целое число (каждый элемент массива) представляет покупателя, а его значение - количество времени, которое ему требуется для оформления заказа.",
            "    'n' - количество касс: положительное целое число. ",
            " Выход: функция должна возвращать целое число - общее требуемое время. ",
            "Примеры:  ",
            "const queueTime = (customers, n) => {} // наша функция",
            "1. queueTime([ 2, 3, 4 ], 1)  // => 9",
            "    // Когда есть только одна касса, то общее время - это сумма времени,  ",
            "    //  потраченного на каждого покупателя.",
            "2. queueTime([ 2, 3, 8 ], 2)  // => 10",
            "    // Первый и второй покупатели идут по разным кассам,",
            "    // третий ждёт и подходит к первой освободившейся.",
            "3. queueTime([ 11, 2, 3, 3 ], 2)  // => 11",
            "    // Две кассы. Пока первый покупатель стоит на свой кассе 11 едениц времени,",
            "    // за это время 2-й, 3-й и 4-й покупатели уже расплатились.",
            "-*-",
            "Создадим нашу функцию:",
            "const queueTime = (customers: number[], n: number) => { ",
            "    // Если количество покупателей равно количеству касс.",
            "    if (customers.length === 0) return 0;",
            "    .",
            "    // Если количество покупателей меньше количества касс.",
            "    if (customers.length <= n) return Math.max(...customers);",
            "    .",
            "    // Если количество покупателей больше количества касс, например ([ 2, 3, 8 ], 2 ).",
            "    // Введём новую переменную queues (массив очередей - количество сумм времени",
            "    // в этих очередях), в нём будет n - элементов (количество касс), значение",
            "    // которых определим равными нулю fill( 0 ). То есть, мы создали очереди к кассам:",
            "    // к первой кассе стоит первый клиент, ко второй - второй клиент. Если какая-то",
            "    // касса освобождается, то к ней подходит очередной клиент.",
            "    // 1-й элемент массива будет принимать время первого человека,",
            "    // второй - время второго человека. Изначальное время для всех задали равное нулю.",
            "    .",
            "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
            "    .",
            "    // Пройдём по массиву покупателей",
            "    for ( const time of customers ) {",
            "        // Будем находить индекс у массива очередей. Мы берём самое меньшее число в очередях,",
            "        // и находим его индекс. Так мы получаем самую свободную на данный момент кассу",
            "        // - индекс кассы. ",
            "        const index = queues.indexOf( Math.min( ...queues ));",
            "        //",
            "        // У нас есть список очередей, есть индекс, и мы прибавляем к тому что есть там",
            "        // определённое время - значение элемента массива покупателей customers.",
            "        // Фактически, мы заполняем наш массив очередей.",
            "        queues[index] += time; // Array [ (2 + 8), 3 ] =  [ 10, 3 ]",
            "    } ",
            "    // Нам в конце остаётся только возвратить самое большое число из массива очередей. ",
            "    return Math.max(...queues); // 10",
            "}; ",
            "-*-",
            "Пишем нашу функцию в чистом виде: ",
            "const queueTime = ( customers: number[], n: number ) => {  ",
            "    if ( customers.length === 0 ) return 0; ",
            "    if ( customers.length <= n ) return Math.max( ...customers ); ",
            ". ",
            "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
            "    for (const time of customers) {",
            "        const index = queues.indexOf(Math.min( ...queues ));",
            "        queues[ index ] += time;",
            "    } ",
            "    return Math.max( ...queues ); ",
            "};",
            "-*-",
            "console.log(queueTime([ 2, 3, 4 ], 1 )); // 9 ",
            "console.log(queueTime([ 2, 3, 8 ], 2 )); // 10 ",
            "console.log(queueTime([ 11, 2, 3, 3 ], 2 )); // 11 ",
            "-*-",
        ]
    },
    {
        heading: "Нарисовать таблицу умножения ",
        href: "https://www.youtube.com/watch?v=Hnlf8W04vfk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=16",
        taskCode: [
            "Надо написать функцию, которая возвращает таблицу умножения размерами N * N. Даётся сам размер, например тройка, и мы должны вывести массив, в котором лежат другие массивы, обозначающие строки в нашей результирующей таблице умножения. Стандартный вид таблицы умножения - это когда первые строки по вертикали и по горизонтали содержат цифры от единицы до самого числа size, а внутри перемножение этих чисел.         ",
            "Напимер: ",
            "const multiplicationTable = (size: number) => {}  ",
            "multiplicationTable(3) // => [[1, 2, 3], [2, 4, 6], [3, 6, 9]] ",
            "//  [1, 2, 3] ",
            "//  [2, 4, 6] ",
            "//  [3, 6, 9] ",
            "Пишем функцию: ",
            "const multiplicationTable = (size: number) => { ",
            "    const table: number[][] = []; ",
            "    .",
            "    for (let i = 0; i < size; i++) {",
            "        table[i] = [];",
            "        for (let j = 0; j < size; j++) {",
            "            table[i][j] = (i + 1) * (j + 1);",
            "        } ",
            "    }",
            "    . ",
            "    return table;",
            "}; ",
            "-*-",
            "console.log(multiplicationTable(3)); // [Array(3), Array(3), Array(3)] ",
            "    //  [1, 2, 3] ",
            "    //  [2, 4, 6]",
            "    //  [3, 6, 9] ",
            "console.log(multiplicationTable(10)); ",
            "    // [Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10)] ",
            "    // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            "    // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]",
            "    // [3, 6, 9, 12, 15, 18, 21, 24, 27, 30] ",
            "    // [4, 8, 12, 16, 20, 24, 28, 32, 36, 40] ",
            "    // [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] ",
            "    // [6, 12, 18, 24, 30, 36, 42, 48, 54, 60] ",
            "    // [7, 14, 21, 28, 35, 42, 49, 56, 63, 70] ",
            "    // [8, 16, 24, 32, 40, 48, 56, 64, 72, 80] ",
            "    // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] ",
            "    // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] ",
            "-*-",
        ]
    },
    {
        heading: "Пропущенное число в прогрессии. Выводим формулу разности прогрессии?",
        href: "https://www.youtube.com/watch?v=c1GnHM2cHjo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=17",
        taskCode: [
            "Задача от FaceBook. Дан массив последовательных элементов арифметической прогрессии, в котором отсутствует ровно одно число. Нужно написать функцию, которая возвратит отсутствующий элемент (он никогда не будет ни первым, ни последним, а массив будет состоять из трёх или более чисел). ",
            "Арифметическая прогрессия - последовательность чисел, в которой каждый следующий элемент можно найти, прибавив к предыдущему число d (delta - разность прогрессии) ",
            "const findMissing = (list) => {} ",
            "findMissing([1, 3, 5, 9, 11]) // => 7",
            "Разность прогрессии d вычисляется по формуле: d = (An - A1) / (n - 1) // это из математики.",
            "-*-",
            "const findMissing = (list: number[]) => { ",
            "    // Сначала найдём то самое n. У нас в заданной прогрессии пропущен один элемент, ",
            "    // этот пропущенный элемент мы и прибавляем к длине данного массива. ",
            "    const n = list.length + 1; ",
            "    .",
            "    // Напишем формулу для вычисления разности прогрессии",
            "    // list[list.length] - это последний элемент в арифметической прогрессии.",
            "    // list[list.length - 1] это последний элемент в заданном массиве, где пропущен один элемент. ",
            "    // Для сокращения памяти выражение (n - 1) заменим на list.length, так это однозначно.",
            "    .",
            "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
            "    // const d = (list[list.length - 1] - list[0]) / list.length;",
            "    .",
            "    for (let i = 0; i < list.length; i++) {",
            "        // предположительное следующее число",
            "        .",
            "        const estimatedNextNumbers = list[i] + d;",
            "        // Сравним предположительное следующее число со следующим элементом, который уже лежит в массиве.",
            "        if (estimatedNextNumbers !== list[i + 1]) {",
            "            return estimatedNextNumbers;",
            "        } ",
            "    } ",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const findMissing = (list: number[]) => { ",
            "    const n = list.length + 1; ",
            "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
            "    .",
            "    for (let i = 0; i < list.length; i++) {",
            "        const estimatedNextNumbers = list[i] + d;",
            "        .",
            "        if (estimatedNextNumbers !== list[i + 1]) { ",
            "            return estimatedNextNumbers;",
            "        } ",
            "    } ",
            "}; ",
            "-*-",
            "console.log(findMissing([1, 3, 5, 9, 11]));            //   7 ",
            "console.log(findMissing([1, 3, 5, 7, 9, 13]));         // 11 ",
            "console.log(findMissing([1, 4, 7, 10, 16, 19]));     // 13 ",
            "-*-",
        ]
    },
    {
        heading: "Решётка заменила Backspace",
        href: "https://www.youtube.com/watch?v=dT7hc6lqyn0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=18",
        taskCode: [
            "Напишите логику, подобную клавише 'Backspace'. Функция будет принимать строку вида 'a#bc#d' и возвращать 'bd'. То есть каждый символ '#' будет как бы стирать последний элемент в строке. ",
            "Напишем нашу функцию: ",
            "const cleanString = (s: string) => {",
            "    // Разбиваем нашу строку посимвольно. После этого воспользуемся функцией высшего порядка ",
            "    // reduce(result, symbol), где result - аккумулятор, а symbol - наш текущий символ строки.",
            "    // Начальное значение result - пустая строка '', мы её будем возвращать в итоге.",
            "    // Если наш символ равен symbol === '#', то мы от result будем срезать последний элемент: ",
            "    // result.slice(0, -1). Иначе к result будем прибавлять очередной символ: result + symbol.",
            "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const cleanString = (s: string) => { ",
            "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
            "}; ",
            "-*-",
            "console.log(cleanString('a#bc#d')); // bd ",
            "console.log(cleanString('abc#d##c')); // ac ",
            "console.log(cleanString('abc##d#####')); // '' ",
            "console.log(cleanString('#####')); // '' ",
            "console.log(cleanString('')); // '' ",
            "-*- ",
        ]
    },
    {
        heading: "Свернуть массив N раз.",
        href: "https://www.youtube.com/watch?v=0XwAo_P49V8&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=19",
        taskCode: [
            "Нужно свернуть массив целых чисел N раз.  ",
            "const foldArray = ( array: number[], runs: number ): number[] => { ",
            "    if ( runs === 0 ) return array; // Это база рекурсии ",
            "    . ",
            "    const result: number[] = []; // Это будет результирующий массив ",
            "    .",
            "    // Мы будем идти от нулевого индекса до середины массива,",
            "    // если середина не целое число, то ничего страшного.",
            "    for ( let i = 0; i < array.length / 2; i++ ) {",
            "        // Создадим переменную зеркальный индекс:",
            "        const mirrorIndex = array.length - i - 1;            // Почему  arr.length - i - 1 ?",
            "        .",
            "        // Зеркальный индекс - индекс элемента, который находится симметрично относительно",
            "        // центра массива. Например, если массив имеет элементы [ 1, 2, 3, 4, 5 ], то зеркальным",
            "        // для элемента 1 будет элемент 5, для элемента 2 - элемент 4.",
            "       .",
            "        // Формула arr.length - i - 1 основана на том факте, что зеркальный индекс элемента",
            "        // находится на расстоянии, равном разности текущего индекса и позиции центрального",
            "        // элемента.",
            "       .",
            "        // Для определения зеркального индекса элемента с индексом i необходимо вычислить",
            "        // разность между позицией центрального элемента и текущим индексом i, а затем",
            "        // вычесть единицу.",
            "        .",
            "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
            "    }",
            "    return foldArray( result, runs - 1 );",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const foldArray = ( array: number[], runs: number ): number[] => { ",
            "    if ( runs === 0 ) return array; ",
            "    .",
            "    const result: number[] = [];",
            "    for ( let i = 0; i < array.length / 2; i++ ) {",
            "        const mirrorIndex = array.length - i - 1;",
            "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
            "    }",
            "    return foldArray( result, runs - 1 );",
            "}; ",
            "-*-",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 1 ));             // [ 6, 6, 3 ] ",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 2 ));             // [ 9, 6 ] ",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 3 ));             // [ 15 ] ",
            "console.log(foldArray([ -9, 9, -8, 8, 66, 23 ], 1 ));  // [ 14, 75, 0 ] ",
            "-*-",
        ]
    },
    {
        heading: "Вывести большее из самых повторяющихся чисел в массиве.",
        href: "https://www.youtube.com/watch?v=sB4CA7tyRJI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=20",
        taskCode: [
            "Напишите функцию, которая возвращает самое встречающееся число в заданном массиве. При ничьей, между двух и более чисел, вернуть наибольшее число среди них.",
            "К примеру: ",
            "const hignestRank = (arr: number[]) => {}; // наша будущая функция ",
            ". ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));           // --> 12 ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8])); // --> 12 ",
            "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));      // --> 3",
            "-*-",
            "Напишем нашу функцию: ",
            "const hignestRank = (arr: number[]) => { ",
            "    // Введём переменную для объекта, где будут лежать ключи - числа массива, ",
            "    // а их значение - количество их повторений.",
            "    const map: any = {};",
            "    .",
            "    // Введём переменную в которой мы будем считать максимальное количество повторений",
            "    // любых чисел. Грубо говоря это будет счётчик максимального количества повторений",
            "    // в нашем массиве. ",
            "    let maxRepeat = 0;",
            "    .",
            "    // Пройдёмся по массиву: какое число нужно присвоить map[n]? Либо 1, если map[n] не",
            "    // существует, либо map[n] + 1, как раз для подсчёта повторений.",
            "    arr.forEach((n) => {",
            "        // Оператор ~~ используется для округления числа с плавающей запятой в меньшую сторону:",
            "        // но самое главное: оператор ~~ приводит undefined к нулю. Что нам в принципе и нужно:",
            "        // для map[n], которого ещё нет, мы скажем ноль плюс 1. Фактически, в для map[n] будут",
            "        // всегда лежать корректные данные.",
            "        map[n] = ~~map[n] + 1;",
            "        .",
            "        if (map[n] > maxRepeat) { ",
            "            // если условие выполняется, то максимальное повторение map[n] заносим в maxRepeat",
            "            maxRepeat = map[n];",
            "        }",
            "    });",
            "    .",
            "    return Object.entries(map).reduce(",
            "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
            "        -Infinity",
            "    );",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const hignestRank = (arr: number[]) => { ",
            "    const map: any = {}; ",
            "    let maxRepeat = 0;",
            "    .",
            "    arr.forEach((n) => { ",
            "        map[n] = ~~map[n] + 1;",
            "        .",
            "        if (map[n] > maxRepeat) {",
            "            maxRepeat = map[n];",
            "        }",
            "    });",
            "    .",
            "    return Object.entries(map).reduce(",
            "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
            "        -Infinity ",
            "    ); ",
            "}; ",
            "-*-",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));             // 12 ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8]));   // 12 ",
            "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));        // 3 ",
            "-*-",
        ]
    },
    {
        heading: "Сложение матриц",
        href: "https://www.youtube.com/watch?v=e9MvJCkhBjk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=21",
        taskCode: [
            "Нужно написать функцию, которая принимает две матрицы (массивы массивов) и возвращает их сумму.",
            "const matrixAddition = (a: number[ ][ ], b: number[ ][ ]) => { ",
            "    return a.map(( row, i ) => row.map(( _, j ) => a[ i ][ j ] + b[ i ][ j ])); ",
            "}; ",
            "-*-",
            "console.log( ",
            "    matrixAddition( ",
            "        [",
            "            [ 1, 2, 3 ], ",
            "            [ 3, 2, 1 ],",
            "            [ 1, 1, 1 ],",
            "        ],                        // [ 3, 4, 4 ]",
            "        //    +                 // [ 6, 4, 4 ]",
            "        [                         // [ 2, 2, 4 ]",
            "            [ 2, 2, 1 ],",
            "            [ 3, 2, 3 ],",
            "            [ 1, 1, 3 ],",
            "        ]",
            "    ) ",
            "); ",
            "-*-",
        ]
    },
    {
        heading: "Количество нажатий для ввода текста на старом телефоне.",
        href: "https://www.youtube.com/watch?v=KxUiRrzVH6o&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=22",
        taskCode: [
            "Сколько раз нужно нажать на кнопки на старых телефонах без Т9, чтобы набрать заданный текст? ",
            "-*-",
            "const presses = (str: string): number => { ",
            "    // Создадим переменную, в которой будут лежать наши числа и буквы, они будут ключами,",
            "    // а значением выступит количество их повторений - сколько раз нужно нажать на кнопку. ",
            "    // На старом телефоне, чтобы вывести букву С, нужно три раза нажать на кнопку (2abc).",
            "    const numbers: any = {",
            "        // По сути это клавиатура старого телефона",
            "        '1': 1,",
            "         a: 1, ",
            "         b: 2,",
            "         c: 3,",
            "        '2': 4,",
            "         d: 1,",
            "         e: 2,",
            "         f: 3,",
            "        '3': 4,",
            "         g: 1,",
            "         h: 2,",
            "         i: 3,",
            "        '4': 4,",
            "         j: 1,",
            "         k: 2,",
            "         l: 3,",
            "        '5': 4,",
            "         m: 1, ",
            "         n: 2,",
            "         o: 3,",
            "        '6': 4,",
            "         p: 1,",
            "         q: 2, ",
            "         r: 3,",
            "         s: 4,",
            "        '7': 5, ",
            "         t: 1, ",
            "         u: 2,",
            "         v: 3, ",
            "        '8': 4,",
            "         w: 1, ",
            "         x: 2,",
            "         y: 3,",
            "         z: 4, ",
            "        '9': 5,",
            "        ' ': 1,",
            "        '0': 2,",
            "    }; ",
            "    return str.split('').reduce((sum: number, char: string) => sum + numbers[char.toLowerCase()], 0);",
            "}; ",
            "-*-",
            "console.log(presses('LOL')); // 9 ",
            "console.log(presses('WHERE DO U WANT 2 MEET L8R')); // 47 ",
            "console.log(presses('')); // 0 ",
            "-*-",
        ]
    },
    {
        heading: "Расширение встроенных классов",
        href: "https://www.youtube.com/watch?v=C6b9pR9lEDM",
        taskCode: [
            "Умеете ли вы расширять фунциональность встроенных классов? Нужно расширить всторенный класс Array методами: ",
            "    square() - должен вернуть копию массива, содержащую все значения в квадрате.",
            "    cube() - должен возвращать копию массива, содержащую все значения в кубе. ",
            "    average() - должен возвращать среднее значение всех значений массива; при пустом - NaN. ",
            "    sum() - должен возвращать сумму всех значений массива.",
            "    even() - должен возвращать массив всех чётных чисел.",
            "    odd() - должен возвращать массив всех нечётных чисел. ",
            " ",
            "Примечание: исходный массив ни в коем случае не должен быть изменён!",
            "-*-",
            "Object.assign() метод копирует все перечисляемые собственные свойства из одного или нескольких исходных объектов в целевой объект. Он возвращает измененный целевой объект.",
            "Object.assign() метод в javascript, который используется для копирования одного или нескольких объектов в целевой объект. Он принимает несколько исходных объектов и присваивает их ключи и значения целевому объекту, перезаписывая предыдущие значения, если они существуют. По сути он позволяет объединять объекты в один, добавляя свойства нескольких объектов в один объект.",
            "-*- Не смог типизировать это расширение -*-",
            "Object.assign(Array.prototype, { ",
            "    square(): number[] { return this.map((n: number) => n * n) }, ",
            "    cube(): number[] { return this.map((n: number) => n * n * n) }, ",
            "    average(): number {",
            "        return this.reduce((sum: number, n: number) => sum + n, 0) / this.length;",
            "    },",
            "    sum(): number { return this.reduce((sum: number, n: number) => sum + n, 0) },",
            "    even(): number[] { return this.filter((n: number) => !(n % 2)) },",
            "    odd(): number[] { return this.filter((n: number) => n % 2) },",
            "}); ",
            " ",
            "const numbers = [1, 2, 3, 4, 5]; ",
            " ",
            "console.log(numbers.square()); // [1, 4, 9, 16, 25] ",
            "console.log(numbers.cube()); // [1, 8, 27, 64, 125] ",
            "console.log(numbers.average()); // 3 ",
            "console.log(numbers.sum()); // 15 ",
            "console.log(numbers.even()); // [2, 4] ",
            "console.log(numbers.odd()); // [1, 3, 5] ",
            "-*-",
        ]
    },
    {
        heading: "Что такое обратная польская нотация и как написать специфичный калькулятор?",
        href: "https://www.youtube.com/watch?v=_OzKGJZ_Ye4",
        taskCode: [
            "Нужно создать калькулятор, работающий с выражениями в обратной польской нотации (+, -, *, / ). Операторы и операнды разделены между собой пробелами. Пустое выражение должно быть равно нулю, обрабатывать исключения не нужно (деления на ноль и прочее не будет). ",
        ]
    },
    {
        heading: "Отображение даты и чисел для разных стран",
        href: "https://www.youtube.com/watch?v=Lf_RJgkww5Y",
        taskCode: ["В разных странах по разному записывают время и числа, "]
    },
    {
        heading: "Перемножить элементы массива, используя метод array.reduce(). ",
        href: "https://www.youtube.com/watch?v=NZP3o0xnT9o",
        taskCode: [
            "Дан непустой массив из целых чисел, нужно возвратить число, равное умножению всех элементов массива.",
            "    const array = [1, 2, 3, 4, 5];      // 1 * 2 * 3 * 4 * 5",
            "    const array2 = [2, 4, 6, 8, 10];  // 2 * 4 * 6 * 8 * 10",
            " ",
            "const multipliedElements = (arr: number[]): number => { ",
            "    return arr.reduce((acc, next) => acc * next, 1); ",
            "}; ",
            " ",
            "console.log(multipliedElements(array)); // 120 ",
            "console.log(multipliedElements(array2)); // 3840 ",
        ]
    },
    {
        heading: "Объединить два массива и найти сумму их элементов. Метод array.concat() и ...spread ",
        href: "https://www.youtube.com/watch?v=3ICqfxnfSAY",
        taskCode: [
            "Объединить два массива и найти сумму их элементов: ",
            "    const array1 = [1, 2, 3, 4, 5]; ",
            "    const array2 = [2, 4, 6, 8, 10];",
            " ",
            "    const arrayA = ['H', 'E', 'L', 'L', 'O', ','];",
            "    const arrayB = ['F', 'R', 'I', 'E', 'N', 'D', '!'];",
            " ",
            "1. Объединим два массива с помощью метода array.concat(): ",
            "function unionOfArrays<T>(arr1: T[], arr2: T[]) {  ",
            "    return arr1.concat(arr2); ",
            "} ",
            " ",
            "let arrayNumeric: number[] = unionOfArrays(array1, array2); ",
            "console.log(arrayNumeric); ",
            "    // [1, 2, 3, 4, 5, 2, 4, 6, 8, 10] ",
            " ",
            "let arrayString: string[] = unionOfArrays(arrayA, arrayB); ",
            "console.log(arrayString); ",
            "    // ['H', 'E', 'L', 'L', 'O', ',' 'F', 'R', 'I', 'E', 'N', 'D', '!'] ",
            " ",
            "2. Найдём сумму числовых элементов массива arrayNumeric:",
            "function sumOfArrayElements(arrNum: number[]) { ",
            "    return arrNum.reduce((acc, next) => acc + next, 0); ",
            "} ",
            " ",
            "console.log(sumOfArrayElements(arrayNumeric)); // 45 ",
            " ",
            "3. Объединим два массива через ...spread: ",
            "function unionOfArrays<T>(arr1: T[], arr2: T[]) { ",
            "    return [...arr1, ...arr2]; ",
            "} ",
            " ",
            "let arrayNumeric: number[] = unionOfArrays(array1, array2); ",
            "console.log(arrayNumeric); ",
            "    // [1, 2, 3, 4, 5, 2, 4, 6, 8, 10] ",
            " ",
            "let arrayString: string[] = unionOfArrays(arrayA, arrayB); ",
            "console.log(arrayString); ",
            "    // ['H', 'E', 'L', 'L', 'O', ',' 'F', 'R', 'I', 'E', 'N', 'D', '!'] ",
            " ",
        ]
    },
    {
        heading: "Найти минимум и максимум. Math.min() и Math.max() ",
        href: "https://www.youtube.com/watch?v=MlVCNJynN9Q",
        taskCode: [
            "Имеем массивы: ",
            "const array1 = [1, 2, 3, 4, 5]; ",
            "const array2 = [2, 4, 6, 8, 10]; ",
            " ",
            "1. Находим min: ",
            "List обязательно разворачиваем: ...list, иначе работать не будет. Этим мы из массива сделаем просто список, то что нам нужно для Math.min():",
            " ",
            "function minOfTheArray(list: number[]) { ",
            "    return Math.min(...list); ",
            "} ",
            "console.log(minOfTheArray(array1)); // 1 ",
            "console.log(minOfTheArray(array2)); // 2 ",
            " ",
            "2. Находим max: ",
            "List обязательно разворачиваем: ...list, иначе работать не будет. Этим мы из массива сделаем просто список, то что нам нужно для Math.min():",
            " ",
            "function maxOfTheArray(list: number[]) { ",
            "    return Math.max(...list); ",
            "} ",
            " ",
            "console.log(maxOfTheArray(array1)); //  5 ",
            "console.log(maxOfTheArray(array2)); // 10 ",
        ]
    },
    {
        heading: "Когда бегуны встретятся на старте кругов разной длины? ",
        href: "https://www.youtube.com/watch?v=DJt12of3OIw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=26",
        taskCode: [
            "Два бегуна бегут с одинаковой скоростью. Круги разной длины, но с одним местом старта. Через сколько кругов они встретятся в начальной точке?",
            "Функция принимает длины a, b и возвращает массив количеств, в котором, сначала лежит, сколько кругов нужно пробежать первому, а потом второму бегуну.",
            "Лучшим решением станет использование наименьшего общего кратного для a и b. Иначе говоря, числа, которое кратно им обоим, делятся на них без остатка. Мы найдём это число, поделим длины кругов и получим ответ. ",
            " ",
            "Как найти общее наименьшее кратное? В цикле мы будем увеличивать HOK каждый раз на +=a, пока остаток деления (HOK % b !==0) ",
            " ",
            "const nbrOfLars = (a: number, b: number) => { ",
            "    let HOK = a; ",
            "    while (HOK % b !== 0) {",
            "        HOK += a;",
            "    }",
            "    return [HOK / a, HOK / b]; ",
            "}; ",
            " ",
            "console.log(nbrOfLars(5, 3)); // [3, 5] ",
            "console.log(nbrOfLars(4, 6)); // [3, 2] ",
            "console.log(nbrOfLars(5, 5)); // [1, 1] ",
        ]
    },
    {
        heading: "wise.js. Найти сумму элементов массива.",
        href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
        taskCode: [
            "Найти сумму элементов массива.",
            " ",
            "1. Самый лёгкий способ сделать это - перебрать массив в цикле: ",
            "const array: number[] = [ 1, 2, 3, 4, 5, 6 ]; ",
            "let sum: number = 0; ",
            "for ( let i = 0; i < array.length; i++ ) { ",
            "    sum += array[ i ]; ",
            "} ",
            "console.log(sum); // 21 ",
            " ",
            "2. Способ посложнее называется reduce(). Методы reduce() и reduceRight() вычисляют одно значение на основе всего массива (суммирование, умножение и т.д...).",
            "const array2 = [1, 2, 2, 4, 5, 6, 6]; ",
            "let sum2: number = array2.reduce((acc, next) => acc + next); ",
            "// acc - аккумулятор ",
            "// next - следующий элемент ",
            "// Последний ноль - изначальное значение аккумулятора. Если массив будет пустой, ",
            "// то отсутствие изначального значения аккумулятора вызовет ошибку. ",
            "console.log(sum2); // 26 ",
        ]
    },
    {
        heading: "wise.js. Найти максимальный или минимальный элемент массива.",
        href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
        taskCode: [
            "У нас есть массив, найдём его максимальное значение. ",
            "1. Воспользуемся циклом for().  Для этого введём переменную max и по дефолту её значение будет первый элемент массива. ",
            "const array = [10, 2, 2, 4, 5, 6, 6, 1]",
            "let max = array[0]; ",
            " ",
            "for (let i = 0; i < array.length; i++) { ",
            "    if (max < array[i]) { ",
            "        max = array[i];",
            "    }",
            "} ",
            "console.log(max); // 12 ",
            " ",
            "2. Воспользуемся циклом for(), но проверку сделаем через тернарный оператор: ",
            "const array = [1, 2, 2, 4, 5, 6, 6, 12]; ",
            "let max = array[0]; ",
            " ",
            "for (let i = 0; i < array.length; i++) { ",
            "    // Если array[i] > max, то переменной max присвоить значение array[i], иначе - max: ",
            "    max = array[i] > max ? array[i] : max;",
            "} ",
            "console.log(max); // 12 ",
            " ",
            "3. Воспользуемся утилитной функцией. ",
            "const array = [1, 2, 2, 4, 5, 6, 6]; ",
            "let max = array[0]; ",
            " ",
            "// То есть нам нужно выбрать максимальное значение из двух доступных: ",
            "for (let i = 0; i < array.length; i++) { ",
            "    max = Math.max(array[i], max); ",
            "} ",
            "console.log(max); // 6 ",
            " ",
            "4. Воспользуемся методом массивов reduce(): ",
            "const array = [1, 2, 2, 4, 5, 6, 6, 12, 14]; ",
            "let max: number = array.reduce((acc, next) => Math.max(acc, next)); ",
            "console.log(max); ",
            " ",
            "5. Воспользуемся методом сортировки sort(). ",
            "const array = [100, 2, 2, 4, 5, 6, 6, 12]; ",
            "    // Отсортируем массив: ",
            "array.sort((a, b) => a - b); // [2, 2, 4, 5, 6, 6, 12, 100] ",
            "    // Достанем из массива последний элемент: ",
            "let max = array[array.length - 1]; ",
            "console.log(max); // 100 ",
            " ",
            "6. Если нам не важна целостность массива, воспользуемся методом pop(). ",
            "const array = [10, 20, 20, 40, 55, 66, 69, 12]; ",
            "    // Отсортируем массив: ",
            "array.sort((a, b) => a - b);",
            "console.log(array);  // [10, 12, 20, 20, 40, 55, 66, 69]; ",
            "    // Достанем последний элемент из массива: ",
            "let max = array.pop(); ",
            "console.log(max); // 69 ",
            " ",
            "7. Самый читерский способ получить максимальный или минимальный элемент массива - это воспользоваться деструктуризацией и утилитным методом Math.max().",
            "const array = [20, 40, 55, 66, 69, 88]; ",
            "// let max = Math.max(...array); ",
            "let max = Math.max.apply(null, array); // для ES6 ",
            " ",
            "console.log(max); // 88 ",
        ]
    },
    {
        heading: "wise.js. Сортировка элементов массива.",
        href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
        taskCode: [
            "1. Сортировка чисел в массиве.",
            "const array = [10, 2, 2, 4, 5, 6, 6, 1];",
            "    // Сортируем массив:",
            "array.sort((a: number, b: number): number => a - b); ",
            "    // Получаем массив: ",
            "array = [1, 2, 2, 4, 5, 6, 6, 10] ",
            " ",
            "2. Сортировка строк в массиве независимо от регистра символов. ",
            "const array = ['dfa', 'ghdfg', 'Fjrytnd', 'Dhsghsfg', 'agfa']; ",
            "    // Сортируем массив:",
            "array.sort((a, b) => a.localeCompare(b)); ",
            "    // Получаем массив: ",
            "array = ['agfa', 'dfa', 'Dhsghsfg', 'Fjrytnd', 'ghdfg'] ",
            " ",
            "3. Необходимо отсортировать массив, элементы которого являются объектами. ",
            "const users = [ ",
            "    { name: 'John Doe', age: 20 }, ",
            "    { name: 'Alex Moren', age: 30 },",
            "    { name: 'Jane Moren', age: 25 }, ",
            "]; ",
            "3.1. Сортируем по полю name (по строкам): ",
            "users.sort((u1, u2) => { ",
            "    return u1.name.localeCompare(u2.name); ",
            "}); ",
            "    // users [",
            "    //     { name: 'Alex Moren', age: 30},",
            "    //     { name: 'Jane Moren', age: 25 },",
            "    //     { name: 'John Doe', age: 20},",
            "    // ]",
            " ",
            "3.2. Сортируем по полю age (по числам):",
            "users.sort((a, b) => a.age - b.age); ",
            "    // users [",
            "    //     { name: 'John Doe', age: 20},",
            "    //     { name: 'Jane Moren', age: 25 },",
            "    //     { name: 'Alex Moren', age: 30},",
            "    // ]",
        ]
    },
    {
        heading: "wise.js. Поменять порядок элементов на противоположный - перевернуть массив.",
        href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
        taskCode: [
            "Нам даны массивы чисел и массивы строк: ",
            "    const array1 = [1, 2, 3, 4, 5]; ",
            "    const array2 = [2, 4, 6, 8, 10];",
            " ",
            "    const arrayA = ['H', 'E', 'L', 'L', 'O', ','];",
            "    const arrayB = ['F', 'R', 'I', 'E', 'N', 'D', '!'];",
            " ",
            "1. Перевернём элементы массива методом arr.reverse():",
            "function reverseArray<T>(arr: T[]) { ",
            "    return arr.reverse(); ",
            "} ",
            "console.log(reverseArray(array1)); // [5, 4, 3, 2, 1] ",
            "console.log(reverseArray(array2)); // [10, 8, 6, 4, 2] ",
            "console.log(reverseArray(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
            "console.log(reverseArray(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
            " ",
            "2. Можем создать новый массив reversed и перебрать его с конца. ",
            "function reverseArr<T>(arr: T[]) { ",
            "    const reversed = []; ",
            " ",
            "    for (let i = arr.length - 1; i >= 0; i--) { ",
            "        reversed.push(arr[i]); ",
            "    } ",
            "    return reversed; ",
            "} ",
            "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
            "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
            "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
            "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
            " ",
            "3. Воспользуемся методом array.map() ",
            "function reverseArr<T>(arr: T[]) { ",
            "    // На первой итерации мы берём последний элемент, на следующей - предпоследний ",
            "    // и так далее, пока не дойдём до последнего элемента массива.",
            "    const reversed = arr.map((el, index, arr) => arr[arr.length - index - 1]);",
            " ",
            "    return reversed; ",
            "} ",
            "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
            "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
            "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
            "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
            " ",
            "4. Метод ...spread, map(arr.pop): ",
            "function reverseArr<T>(arr: T[]) { ",
            "    return [...arr].map(arr.pop, arr); ",
            "} ",
            "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
            "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
            "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
            "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
        ]
    },
    {
        heading: "wise.js. Отфильтровать false - значения в массиве.",
        href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
        taskCode: [
            "const arr = [7, 'correct', false, 9, NaN, '']; ",
            " ",
            " 1. С помощью цикла for() приведём к булевому типу (!!) значения array[i] и проверим их на соотношение к true. Если эти значения правдивы, то пушим их в новый массив:",
            "function notFalseValue(array: any) { ",
            "    const notFalse: any = []; ",
            "    for (let i = 0; i < array.length; i++) { ",
            "        if (!!array[i]) { ",
            "            notFalse.push(array[i]);",
            "        } ",
            "    } ",
            "    return notFalse; ",
            "} ",
            "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
            " ",
            "2.1. Воспользуемся методом array.filter(), чтобы не делать цикл: ",
            "function notFalseValue(array: any) { ",
            "    return array.filter((n: any) => !!n); ",
            "} ",
            "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
            " ",
            "2.2. Воспользуемся методом array.filter() и фунцией Boolean(n): ",
            "function notFalseValue(array: any) { ",
            "    return array.filter((n: any) => Boolean(n)); ",
            "} ",
            "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
            " ",
            "2.3. Воспользуемся методом array.filter() и фунцией Boolean(n): ",
            "function notFalseValue(array: any) { ",
            "    return array.filter(Boolean); ",
            "}",
            "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
        ]
    },
    {
        heading: "Отформатировать и отсортировать заказы без сортировки ",
        href: "https://www.youtube.com/watch?v=nXT1LnINXIk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=27",
        taskCode: [
            "После закрытия самой популярной бургерной, на смену пришёл другой бренд, в котором практически нет системы. Кассиры записывают заказы в одну строку. А кухонный персонал угрожает уйти из-за того, что трудно читать заказы. Они предлагают читаемый вариант с заглавными буквами и разделителями. На кухне ожидают, что блюда будут расположены в том же порядке, в котором они указаны в меню. В названиях пунктов нет дублирований:",
            "// Бургер ",
            "// Картошка ",
            "// Крылышки ",
            "// Ролл ",
            "// Пирожок ",
            "// Печенье ",
            "// Коктейль ",
            "// Кола ",
            " ",
            "const str = 'коктейльпирожокбургербургерколакартошкароллколапирожоккрылышкикола'; ",
            " ",
            "function getOrder(input: string) { ",
            "    const ordered: string[] = []; ",
            "    const menu: any = { ",
            "        Бургер: 0,",
            "        Картошка: 1,",
            "        Крылышки: 2, ",
            "        Ролл: 3,",
            "        Пирожок: 4, ",
            "        Печенье: 5, ",
            "        Коктейль: 6, ",
            "        Кола: 7, ",
            "    }; ",
            " ",
            "    // блюда в заказе ",
            "    let item = ''; ",
            "    // Добавляй в item буквы, пока они не сложатся в слово, которое уже есть в объекте menu.",
            "    for (let i = 0; i < input.length; i++) {",
            "        // Для начала ложим заглавную букву ",
            "        item += item ? input[i] : input[i].toUpperCase(); ",
            " ",
            "        // Если в объекте есть блюда, то индекс будет равен от 0 и до 7. Иначе - undefined. ",
            "        const index = menu[item]; ",
            "        if (index > -1) { ",
            "            ordered[index] = ordered[index] ? `${ordered[index]} ${item}` : item; ",
            "            // После, затри item ",
            "            item = '';",
            "        }",
            "    } ",
            "    return ordered.reduce((result, str) => { ",
            "        if (str) return result ? `${result} ${str}` : str;",
            "        return result;",
            "    }, '');",
            "} ",
            " ",
            "console.log(getOrder(str)); ",
            "// Бургер Бургер Картошка Крылышки Ролл Пирожок Пирожок Коктейль Кола Кола Кола ",
        ]
    },
    {
        heading: "Каждую цифру в числе возвести в квадрат ",
        href: "https://www.youtube.com/watch?v=xa0Pv74CxlM&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=1&t=7s",
        taskCode: [
            "В этой задаче необходимо исходное число разделить посимвольно и каждый символ - число преобразовать в числовое значение и возвести в квадрат. Получившееся количество вычислений сконкантенировать в отдельное число и вывести его.",
            " ",
            "const numeric = 91736491; ",
            " ",
            "function squareDigits(num: number) { ",
            "    // Исходное число переводим в строку, // 91736491 ",
            "    // разделяем посимвольно в массив,    // ['9', '1', '7', '3', '6', '4', '9', '1'] ",
            "    // мапим в новый массив, переводя в число и возведя в квадрат: // [81, 1, 49, 9, 36, 16, 81, 1] ",
            "    // Всё это джойним слитно. // 8114993616811",
            "    return num.toString().split('').map((n) => Number(n) * Number(n)).join('');",
            "} ",
            " ",
            "console.log(squareDigits(numeric)); ",
        ]
    },
    {
        heading: "Посчитать количество гласных в строке. Методы .reduce() .filter() .includes() ",
        href: "https://www.youtube.com/watch?v=qwJKLSTyZPk&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=2",
        taskCode: [
            "Глассными у нас будут: a, e, i, o, u. Не считать глассной 'y'. Во входящей строке будут только буквы в нижнем регистре и пробелы.  ",
            " ",
            "const str = 'asgg sgdsfgh hello dfgadf gfdd qwert'; ",
            " ",
            "function getCount(str: string) { ",
            "    return str.split('').reduce((sum: any, char: string) => { ",
            "        if ('aeiou'.includes(char)) {",
            "            sum += 1;",
            "        }",
            " ",
            "        return sum; ",
            "    }, 0); // Если здесь забудем написать нолик, то функция у нас работать не будет ",
            "} ",
            " ",
            "console.log(getCount(str)); // 5",
        ]
    },
    {
        heading: "Реализовать функцию, которая будет сумировать числа и выводить в логи.",
        href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
        taskCode: [
            "Реализовать функцию, которая будет сумировать числа и выводить в логи. Особенность задачи состоит в том, что мы каждый раз добавляем вызов функции, который передаём число. И это число должно прибавляться к результату, вычисленную в предыдущем вызове.  ",
            "",
            "function sum(n: number) { ",
            "    console.log(n); ",
            "    return function (a: number) { ",
            "        return sum(a + n); ",
            "    }; ",
            "} ",
            "sum(5);           // 5 ",
            "sum(5)(4);       // 9 ",
            "sum(5)(4)(11); // 20 ",
            "-*- ",
        ]
    },
    {
        heading: "Функция принимает два объекта с разными ключами",
        href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
        taskCode: [
            "Функция принимает два объекта с разными ключами, некоторые из которых могут пересекаться. Необходимо вернуть первый объект с обновлёнными значениями из второго объекта (только те, которые совпадают). 1.58 мин ",
            " ",
            "type Obj1  = { foo: string; bar: string }; ",
            "type Obj2 = { bar: string; some: string }; ",
            " ",
            "const object1: Obj1 = { foo: 'foo', bar: 'bar' }; ",
            "const object2: Obj2 = { bar: 'foo', some: 'some' }; ",
            " ",
            "1-ый вариант: ",
            "const mergeSameKeysOfObject = (obj1: any, obj2: any) => { ",
            "    let keysOfObj1 = Object.keys(obj1); ",
            "    let keysOfObj2 = Object.keys(obj2); ",
            "    // console.log(keysOfObj1, keysOfObj2); // ['foo', 'bar'] (2)['bar', 'some'] ",
            " ",
            "    // Объекты из первого цикла будем сравнивать с объектами из второго цикла ",
            "    for (let i = 0; i < keysOfObj1.length; i++) { ",
            "        let key1 = keysOfObj1[i]; ",
            " ",
            "        for (let j = 0; j < keysOfObj2.length; j++) { ",
            "            let key2 = keysOfObj2[j];",
            " ",
            "            if (key1 === key2) { ",
            "                // Если условие выполняется, то мы должны заменить повторяющиеся поля в первом объекте.",
            "                // По ключу обращаемся к этому полю, и меняем значение на то,  ",
            "                // которое мы получаем по ключу из второго объекта. ",
            "                obj1[key1] = obj2[key2]; ",
            "            } ",
            "        } ",
            "    } ",
            "    console.log(obj1); // {foo: 'foo', bar: 'foo'} ",
            "}; ",
            "mergeSameKeysOfObject(object1, object2); ",
            "-*-",
            "2-ой вариант: ",
            "const mergeSameKeysOfObject = (obj1: any, obj2: any) => { ",
            "    for (const key in obj1) { ",
            "        if (obj2.hasOwnProperty(key)) {",
            "            obj1[key] = obj2[key];",
            "        } ",
            "    } ",
            " ",
            "    console.log(obj1); // {foo: 'foo', bar: 'foo'} ",
            "}; ",
            " ",
            "mergeSameKeysOfObject(object1, object2); ",
            "-*-",
        ]
    },
    {
        heading: "Реализовать функцию с ключами объектов. 5.07",
        href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
        taskCode: [
            "Реализовать функцию, которая принимает два параметра:  ",
            "    *  массив значений ",
            "    *  колбэк, по результату которого будут групироваться значения",
            "Функция должна возвращать составной совокупный объект, где ключи - это названия групп, а значения - сами группы. ",
            "const groupBy = (arr: number[], callbackFunction: any) => { ",
            "   const result: any = {}; ",
            " ",
            "       // Проитерируемся по массиву, каждый момент итерации - item. И каждый момент  ",
            "       // итерации нам надо прогнать через функцию, которая передаётся вторым параметром. ",
            "       arr.forEach((item) => { ",
            "           let resultAfterCallback: any = callbackFunction(item);",
            "           result[resultAfterCallback] ",
            "               ? result[resultAfterCallback].push(item)  ",
            "               : (result[resultAfterCallback] = [item]);",
            "       }); ",
            "       console.log(result); ",
            "}; ",
            " ",
            "groupBy(array, Math.floor); // { [4.2], [6.1, 6.3] } ",
            "-*-",
        ]
    },
    {
        heading: "Расширение Function.prototype и типизация этого. ",
        href: "https://www.youtube.com/watch?v=kOTD3gndink&t=97s",
        taskCode: [
            "Нам необходимо расширить интерфейс Function, который находится в стандартной библиотеке typescript, для того, чтобы функция delay() была доступна для каждой функции. ",
            "В стандартной библиотеке typescript есть интерфейс Function, в котором объявлены члены объектов Function. Нам нужно будет ГЛОБАЛЬНО, НА ВЕРХНЕМ УРОВНЕ, объявить 'delay' как член этого интерфейса с нашим собственным дополнением, как показано ниже. Без «объявления глобального» это не работает.",
            "// типизация расширения прототипа функции: ",
            "declare global { ",
            "    interface Function { ",
            "        delay(ms: number): any; ",
            "    } ",
            "} ",
            " ",
            "// время старта функции. ",
            "const START = Date.now(); ",
            " ",
            "// Функция someFn(), которой мы хотим добавить функцию delay():  ",
            "function someFn() { ",
            "    console.log('time', Date.now() - START); // разница времени от старта функции до текущего момента. ",
            "    console.log('args', arguments); // просто выводим в логи. ",
            "} ",
            " ",
            "// Для того, чтобы функция delay() была доступна для каждой функции, объявим её в прототипе функции, тем самым расширим прототип функции. В самом верху описана типизация расширения интерфейса Function. ",
            "Function.prototype.delay = function (ms) { ",
            "    setTimeout(() => { ",
            "        this.call(this, arguments); ",
            "    }, ms); ",
            "}; ",
            " ",
            "// Запустим нашу функцию с расширением delay():",
            "const f = someFn.delay(500); ",
            "// В консоли будет следующее: ",
            "    // time 505 ",
            "    // args  ",
            "    //      Arguments [500, callee: (...), Symbol(Symbol.iterator): ƒ] ",
            "-*-",
        ]
    },
    {
        heading: "Найти сумму объектов в массиве. ",
        href: "https://www.youtube.com/watch?v=kOTD3gndink&t=97s",
        taskCode: [
            "У нас есть дерево, в котором каждый узел может содержать неограниченное количество детей. Суть задачи состоит в том, чтобы обойти всё дерево и просуммировать значения, которые лежат в каждой из вершин. ",
            " ",
            "Наше дерево - это массив, состоящий из объектов. Каждый объект - это узел, у которого есть два поля: ",
            "    -  это v - value (какое-то значение), ",
            "    -  и с - child (потомки).",
            "    const arrayTree = [ ",
            "        { ",
            "            v: 5, ",
            "            c: [",
            "                { v: 18, c: [{ v: 11 }] }, ",
            "                { v: 7, c: [{ v: 5, c: [{ v: 1 }] }] },",
            "                { v: 5, c: [{ v: 18 }, { v: 15 }] }, ",
            "            ],",
            "        }, ",
            "    ]; ",
            " ",
            "1. Решение задачи с помощью рекурсии.",
            "const recursive = ( tree: any ) => { ",
            "    let sum = 0; ",
            "    // Проитерируемся по объектам массива tree: ",
            "    tree.forEach(( node: any ) => { ",
            "        // К сумме прибавим значение этого узла ( node ) ",
            "        sum += node.v; ",
            "        // И поскольку у каждого узла (node) так же есть дети, которые являются являются деревьями,",
            "        // мы можем эту же функцию рекурсивно вызвать и для каждого поддерева. ",
            "        // Параметром передаём массив детей:",
            "        if (!node.c) { ",
            "            return node.v; ",
            "        } ",
            "        sum += recursive(node.c);",
            "    }); ",
            "    // По итогу возвращаем эту сумму: ",
            "    return sum; ",
            "}; ",
            "console.log(recursive(arrayTree)); // 85 ",
            " ",
            "Рекурсивные функции помещаются в стек вызовов и выполняются сверху вниз. И получается, что функция, которая была вызвана самой первой, то есть для всего дерева, будет как раз хранить значение суммы всех элементов. Здесь важно понимать, что эта сумма будет считаться для каждого поддерева и по итогу это всё сложится в одну общую сумму первоначальной функции. ",
            "Каждая рекурсивная функция должна иметь условия выхода из этой рекурсии. У нас база рекурсии - отсутствие детей в некоторых случаях. Поэтому в цикле, для каждого узла делаем проверку: if (!node.c) {}.",
            " ",
            "2. Решение задачи с помощью цикла (итерацией).",
            "Стэк - это такая структура данных, в которой объекты помещаются в конец и в первую же очередь с этого конца забираются. Можно представить пирамиду из кубиков, из которых мы не можем взять и вытащить кубик из середины. Мы можем взять его только сверху. И вот такая структура данных называется стэком. ",
            " ",
            "const iteration = (tree: any) => { ",
            "    // Если дерево пустое, тогда возвращаем ноль ",
            "    if (!tree.length) { ",
            "        return 0; ",
            "    } ",
            " ",
            "    // Без рекурсии с использованием стэка. ",
            "    const stack: any[] = []; ",
            "    let sum = 0; ",
            " ",
            "    tree.forEach((node: any) => {",
            "        // Каждый узел (node) добавляем в стэк:",
            "        stack.push(node); ",
            "        // По окончании этой функции, в стэке будут только вершины дерева.",
            "    }); ",
            " ",
            "    // Делаем бесконечный цикл, которой будет крутиться, пока стэк не пустой: ",
            "    while (stack.length) { ",
            "        // На каждой итерации цикла достаём один из узлов и суммируем его значение: ",
            "        const node = stack.pop();",
            "        sum += node.v; ",
            "        // Если у узла, который мы вытащили на этой итерации, есть дети (проверим это) ",
            "        if (node.c) { ",
            "            // то пробегаемся уже по детям узла:",
            "            node.c.forEach((n: any) => {",
            "                // Каждого ребенка этого узла мы опять добавляем в стэк:",
            "                stack.push(n);",
            "            }); ",
            "        }",
            "    } ",
            "    // По итогу возвращаем сумму: ",
            "    return sum;",
            "}; ",
            "console.log(iteration(arrayTree)); // 85 ",
            " ",
            "Мы создали стэк, добавили в него все вершины, потом в цикле мы эти вершины вытаскиваем, суммируем и добавляем в стэк уже детей этой вершины. Этот цикл будет крутиться до тех пор, пока стэк не пустой.",
        ]
    },
    {
        heading: "Привести все буквы в верхний регистр (сделать заглавными) .toUpperCase()",
        href: "https://www.youtube.com/watch?v=G199yFaBhHI",
        taskCode: [
            "      function makeUpperCase(str: string) { ",
            "            return str.toUpperCase(); ",
            "      }",
            " ",
            "      console.log(makeUpperCase('hello, my friend!')); // HELLO, MY FRIEND! ",
        ]
    },
    {
        heading: "Удвоить каждый элемент массива.",
        href: "https://www.youtube.com/watch?v=08BbEju_Lls&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=2",
        taskCode: [
            "Удвоить каждый элемент массива, используем метод массивов map(). ",
            "      function maps(arrNum1: number[]): number[] { ",
            "            let arrNum2 = arrNum1.map((num) => num * 2);",
            "            return arrNum2;",
            "      } ",
            " ",
            "      console.log(maps([1, 2, 3, 4, 5])); // [2, 4, 6, 8, 10] ",
        ]
    },
    {
        heading: "Сумма всех положительных чисел из массива всех чисел. ",
        href: "https://www.youtube.com/watch?v=2iowo8oucTw&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=8",
        taskCode: [
            "Сумма всех положительных чисел из массива всех чисел. Воспользуемся методом массивов reduce(). ",
            " ",
            "      function posititiveSum(arr: number[]) {",
            "            return arr.reduce((sum, number) => (number > 0 ? sum + number : sum), 0);",
            "      } ",
            " ",
            "      console.log(posititiveSum([1, -4, 7, -5, 12])); // 20 ",
        ]
    },
    {
        heading: "Возврат отрицательного числа.",
        href: "https://www.youtube.com/watch?v=G_cmqJhSGCY&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=9",
        taskCode: [
            "Нам даётся число, мы должны сделать его отрицательным. Если число уже отрицательное, оставляем его таким без изменений.",
            " ",
            "      function makeNegative(num: number) { ",
            "            return num < 0 ? num : 0 - num;",
            "      } ",
            " ",
            "      console.log(makeNegative(2)); // -2 ",
            "      console.log(makeNegative(-2)); // -2 ",
        ]
    },
    {
        heading: "Вывод противоположного числа",
        href: "https://www.youtube.com/watch?v=vh8muDSRioA&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=10",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: "Удалить первый и последний символы строки. Отличие методов .slice() и .substring()",
        href: "https://www.youtube.com/watch?v=Yod5t2ycJ70&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=11",
        taskCode: [
            "Удалить первый и последний символ в строке.",
            "1-ый вариант: ",
            "      function removeChar(str: string) { ",
            "            return str.slice(1, str.length - 1);",
            "      } ",
            " ",
            "      console.log(removeChar('evolution')); // volutio ",
            " ",
            "2-ой вариант: ",
            "      function removeChar2(str: string) { ",
            "            return str.substring(1, str.length - 1);",
            "      } ",
            " ",
            "      console.log(removeChar2('evolution')); // volutio ",
        ]
    },
    {
        heading: "Перевести булевое значение в 'Да' или 'Нет'. Тернарный оператор",
        href: "https://www.youtube.com/watch?v=au7MOneLMcc&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=12",
        taskCode: [
            " ",
            "      type BoolToWord = string | number | boolean; ",
            " ",
            "      function boolToWord(bool: BoolToWord) {",
            "            return bool ? 'Yes' : 'No';",
            "      } ",
            " ",
            "      console.log(boolToWord(true));   // Yes ",
            "      console.log(boolToWord(false));  // No ",
            "      console.log(boolToWord(''));        // No ",
            "      console.log(boolToWord('str'));    // Yes ",
            "      console.log(boolToWord(123));    // Yes ",
            "      console.log(boolToWord(0));        // No ",
        ]
    },
    {
        heading: "Перевернуть строку",
        href: "https://www.youtube.com/watch?v=jifxjuvm7UM&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=13",
        taskCode: [
            "1-ый вариант: ",
            "",
            "      function reversedString(str: string) { ",
            "            return str.toLowerCase().split('').reverse().join(''); ",
            "      } ",
            "",
            "console.log(reversedString('Container')); // reniatnoc ",
            "console.log(reversedString('reniatnoc')); // container ",
            " ",
            "2-ой вариант: ",
            "",
            "      function reversedString2(str: string) { ",
            "            return [...str].reverse().join('');",
            "      } ",
            "",
            "console.log(reversedString2('container')); // reniatnoc ",
            "console.log(reversedString2('reniatnoc')); // container ",
        ]
    },
    {
        heading: "Перевод числа в строку. Отличие .toString() и String() ",
        href: "https://www.youtube.com/watch?v=_-RlTF1nzAc",
        taskCode: [
            "1. Метод String() - это встроенный в JS глобальный объект (доступ к которому можно получить везде), который принимает параметр и преобразует его в строку.",
            "Поскольку String является независимым объектом, а не методом, унаследованным от прототипа, то его можно использовать с объектами, у которых нет метода toString().  ",
            "Одна особенность String(x) заключается в том, что он сначала вызывает toString(), а затем пытается использовать возвращаемое значение. ",
            "",
            "      console.log(String(null)); // 'null'",
            "      console.log(String(undefined)); // 'undefined'",
            " ",
            "      function numString(num: any) { ",
            "            return String(num); ",
            "      } ",
            " ",
            "      console.log(numString(123)); // '123' ",
            "      console.log(numString(null)); // 'null' ",
            "      console.log(numString(undefined)); // 'undefined' ",
            "      console.log(numString(true)); // 'true' ",
            " ",
            "      console.log(typeof numString(123)); // string ",
            "      console.log(typeof numString(null)); // string ",
            "      console.log(typeof numString(undefined)); // string ",
            "      console.log(typeof numString(true)); // string ",
            " ",
            "2. Метод toString() - это метод класса. Он будет работать только в том случае, если его реализует класс объекта, над которым вы работаете. Значение должно существовать, undefined или null приведет к ошибке. ",
            "",
            "      function numToString(num: any) { ",
            "            if (num) {",
            "                  return num.toString();",
            "            }",
            "      } ",
            " ",
            "      console.log(numToString(456)); // '456' ",
            "      console.log(numToString(true)); // 'true' ",
            "      console.log(numToString(null)); // undefined ",
            "      console.log(numToString(undefined)); // undefined ",
            " ",
            "      console.log(typeof numToString(456)); // string ",
            "      console.log(typeof numToString(true)); // string ",
            "      console.log(typeof numToString(null)); // undefined ",
            "      console.log(typeof numToString(undefined)); // undefined ",
        ]
    },
    {
        heading: "Сумма чисел от 1 до N. Цикл for(); Array.from() и reduce(); метод Гаусса.",
        href: "https://www.youtube.com/watch?v=-1ydPfASVRM",
        taskCode: [
            "1-ый вариант: ",
            "      function summation(num: number) { ",
            "            let newNumber = 0; ",
            "            for (let i = 0; i <= num; i++) {",
            "                  newNumber += i;",
            "            }",
            "            return newNumber;",
            "      } ",
            " ",
            "      console.log(summation(8)); // 36 ",
            " ",
            "2-ой вариант: методы Array.from() и reduce().",
            "      const summation = (num: number) => { ",
            "            return Array.from({ length: num }).reduce((sum: number, _, i) => sum + i + 1, 0);",
            "      }; ",
            " ",
            "      console.log(summation(2)); // 3 ",
            "      console.log(summation(8)); // 36 ",
            "3-ий вариант: метод Гаусса. ",
            "      const summation = (num: number) => { ",
            "            return ((num + 1) * num) / 2;",
            "      }; ",
            " ",
            "      console.log(summation(2)); // 3 ",
            "      console.log(summation(8)); // 36 ",
        ]
    },
    {
        heading: "Считаем овец. Вывод количества элементов, равных true. .filter() и Boolean()",
        href: "https://www.youtube.com/watch?v=lobpZHT0P5g&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=17",
        taskCode: [
            "Нам даны массивы, состоящие из true и false; null и undefined. Необходимо сделать проверку элементов массива на null и undefined, посчитать количество true - элементов.",
            "      const arrBool: boolean[] = [true, true, false, true, false, false, true, true, false]; ",
            "      const arrNull: null[] = [null, null, null]; ",
            "      const arrUndefined: undefined[] = [undefined, undefined, undefined]; ",
            " ",
            "1-ый вариант: ",
            "      function checkTrue<T>(arr: T[]) { ",
            "            let sum = 0;",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  if (arr[i] === null || arr[i] === undefined) {",
            "                        return sum;",
            "                  } else if (arr[i] === true) {",
            "                        sum += 1;",
            "                  }",
            "            }",
            "            return sum;",
            "      } ",
            " ",
            "console.log(checkTrue(arrBool)); // 5 ",
            "console.log(checkTrue(arrNull)); // 0 ",
            "console.log(checkTrue(arrUndefined)); // 0 ",
            " ",
            "2-ой и 3-ий варианты: ",
            "      function checkTrue<T>(arr: T[]) { ",
            "            // return arr.filter((sheep) => sheep === true).length; // 2-ый вариант",
            "            return arr.filter(Boolean).length; // 3-ий вариант:",
            "      } ",
            " ",
            "console.log(checkTrue(arrBool)); // 5 ",
            "console.log(checkTrue(arrNull)); // 0 ",
            "console.log(checkTrue(arrUndefined)); // 0 ",
        ]
    },
    {
        heading: "Сумма квадратов из чисел в массиве. .reduce() и Math.pow()",
        href: "https://www.youtube.com/watch?v=ekJTm-UKGDc&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=18",
        taskCode: [
            "Нам дан массив. Необходимо возвести каждый его элемент в квадрат и просумировать их.",
            "1-ый вариант, через цикл for(): ",
            "      const arrNum: number[] = [1, 2, 3, 4, 5]; ",
            " ",
            "      function summation(arr: number[]) { ",
            "            let sum = 0;",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  sum += arr[i] ** 2;",
            "            }",
            "            return sum;",
            "      } ",
            " ",
            "      console.log(summation(arrNum)); // 55 ",
            " ",
            "2-ой вариант, через цикл for() и Math.pow(base, exponent): ",
            "      const arrNum: number[] = [1, 2, 3, 4, 5]; ",
            " ",
            "      function summation(arr: number[]) { ",
            "            let sum = 0;",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  sum += Math.pow(arr[i], 2);",
            "            }",
            "            return sum;",
            "      } ",
            " ",
            "      console.log(summation(arrNum)); // 55 ",
            " ",
            "3-ий вариант, методы reduce() и Math.pow(base, exponent): ",
            "const arrNum: number[] = [1, 2, 3, 4, 5]; ",
            " ",
            "      function summation(arr: number[]) { ",
            "            return arr.reduce((sum, el, _) => sum + Math.pow(el, 2), 0);",
            "      } ",
            " ",
            "      console.log(summation(arrNum)); ",
        ]
    },
    {
        heading: "Найти наименьшее число в массиве. Math.min()",
        href: "https://www.youtube.com/watch?v=VEHnTnYjOA0&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=19",
        taskCode: [
            "Найти наименьшее число в массиве: ",
            "1-ый вариант, через цикл for(): ",
            "      const arrNum: number[] = [34, 15, 88, 2]; ",
            "      const arrNum2: number[] = [34, -35, -1, 100]; ",
            " ",
            "      function smallestNumber(arr: number[]) { ",
            "            let small: number = arr[0];",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  if (arr[i] < small) {",
            "                        small = arr[i];",
            "                  }",
            "            }",
            "            return small;",
            "      } ",
            "",
            "      console.log(smallestNumber(arrNum)); // 2 ",
            "      console.log(smallestNumber(arrNum2)); // -35 ",
            " ",
            "2-ой вариант, используя Math.min(...arr): ",
            "      const arrNum: number[] = [34, 15, 88, 2]; ",
            "      const arrNum2: number[] = [34, -35, -1, 100]; ",
            " ",
            "      function smallestNumber(arr: number[]) { ",
            "            return Math.min(...arr);",
            "      } ",
            "      console.log(smallestNumber(arrNum)); // 2 ",
            "      console.log(smallestNumber(arrNum2)); // -35 ",
            " ",
            "3-ий вариант, метод reduce(): ",
            "      const arrNum: number[] = [34, 15, 88, 2]; ",
            "      const arrNum2: number[] = [34, -35, -1, 100]; ",
            " ",
            "      function smallestNumber(arr: number[]) { ",
            "            return arr.reduce((prev, cur) => (prev < cur ? prev : cur));",
            "      } ",
            "      console.log(smallestNumber(arrNum)); // 2 ",
            "      console.log(smallestNumber(arrNum2)); // -35 ",
            " ",
            "4-ый вариант, метод sort(): ",
            "      const arrNum: number[] = [34, 15, 88, 2, 0]; ",
            "      const arrNum2: number[] = [34, -345, -1, 100]; ",
            " ",
            "      function smallestNumber(arr: number[]) { ",
            "            arr.sort((a, b) => a - b);",
            "            return arr[0];",
            "      } ",
            "      console.log(smallestNumber(arrNum)); // 0 ",
            "      console.log(smallestNumber(arrNum2)); // -345 ",
        ]
    },
    {
        heading: "Остаток от деления. Оператор %",
        href: "https://www.youtube.com/watch?v=2bJnE81LdgI",
        taskCode: [
            "Определить: делится ли число n на 2 числа: x и y. Все входные значения должны быть положительными и не нулями.",
            "      function isDivisible(n: number, x: number, y: number): boolean { ",
            "            return n % x === 0 && n % y === 0;",
            "      } ",
            " ",
            "      console.log(isDivisible(3, 3, 4)); // false ",
            "      console.log(isDivisible(12, 3, 4)); // true ",
            "      console.log(isDivisible(24, 3, 4)); // true ",
        ]
    },
    {
        heading: "Перевести год в век. Math.ceil() — ближайшее большее целое",
        href: "https://www.youtube.com/watch?v=Z-syFjeCuH4&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=21",
        taskCode: [
            "Нам дан год, нужно указать его век. 1-ый век начинается с 0 до 100 лет. 2-ой век начинаетя со 101 до 200 лет",
            "      function defineСentury(age: number): number { ",
            "            return Math.ceil(age / 100);",
            "      } ",
            " ",
            "      console.log(defineСentury(55));      // 1 ",
            "      console.log(defineСentury(155));    // 2 ",
            "      console.log(defineСentury(555));    // 6 ",
            "      console.log(defineСentury(1555));  // 16 ",
        ]
    },
    {
        heading: "Иголка в стоге сена. .indexOf() и интерполяция",
        href: "https://www.youtube.com/watch?v=TPPB45-8fvI&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=22",
        taskCode: [
            "Исходные данные - массив строк. В массиве надо найти слово 'needle' и его позицию.  ",
            "1-ый вариант: ",
            "      const initialArray = ['tailor', 'looking', 'for, 'a', 'needle']; ",
            "      const initialArray2 = [tailor', 'looking', 'for, 'a'];",
            " ",
            "      function findNeedle(arr: string[]) { ",
            "            const index = arr.indexOf('needle');",
            "            let str: string;",
            "            if (index === -1) {",
            "                  str = 'Слово needle в текущем массиве отсутствует';",
            "            } else {",
            "                  str = `Нашел слово needle в массиве по индексу: ${index}`;",
            "            }",
            "            return str;",
            "      } ",
            " ",
            "      console.log(findNeedle(initialArray)); ",
            "      // Нашел слово needle в массиве по индексу: 4",
            " ",
            "      console.log(findNeedle(initialArray2));",
            "      // Слово needle в текущем массиве отсутствует",
        ]
    },
    {
        heading: "Аббревиатура из имени и фамилии. .toUpperCase() и деструктуризация",
        href: "https://www.youtube.com/watch?v=UHt0_FadXGI&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=23",
        taskCode: [
            "Нам даётся имя и фамилия. Мы должны взять первую букву у имени, поставить точку. После берём первую букву у фамилии, точку не ставим. ",
            "      const nameSam = 'Sam Harris'; ",
            "      const nameSam2 = 'mama mia'; ",
            " ",
            "      function abbrevName(name: string) { ",
            "            const [first, last] = name.split(' ');",
            "            return `${first[0].toUpperCase()}.${last[0].toUpperCase()}`;",
            "      } ",
            " ",
            "      console.log(abbrevName(nameSam)); // S.H ",
            "      console.log(abbrevName(nameSam2)); // M.M ",
        ]
    },
    {
        heading: "Перевести строку в число. parseInt() / Number() / +",
        href: "https://www.youtube.com/watch?v=CCd1I44fiO8",
        taskCode: [
            "1-ый вариант, используем метод глобального объекта: ",
            "      const stringToNumber = function (str: string | boolean) { ",
            "            return Number(str);",
            "      }; ",
            " ",
            "      console.log(stringToNumber('1234'));   // 1234 ",
            "      console.log(stringToNumber('605'));     // 605 ",
            "      console.log(stringToNumber('-605'));    // -605 ",
            "      console.log(stringToNumber(true));      // 1 ",
            "      console.log(stringToNumber(false));     // 0 ",
            "      console.log(stringToNumber('stroka'));  // NaN ",
            " ",
            "2-ой вариант ' + ': ",
            "      const stringToNumber = function (str: string | boolean) { ",
            "            return +str;",
            "      }; ",
            " ",
            "      console.log(stringToNumber('1234'));   // 1234 ",
            "      console.log(stringToNumber('605'));     // 605 ",
            "      console.log(stringToNumber('-605'));    // -605 ",
            "      console.log(stringToNumber(true));      // 1 ",
            "      console.log(stringToNumber(false));     // 0 ",
            "      console.log(stringToNumber('stroka'));  // NaN ",
            " ",
            "3-ий вариант, используем метод parseInt(). Примечание, метод работает только для параметра типа string: ",
            "      const stringToNumber = function (str: string) { ",
            "            return parseInt(str);",
            "      }; ",
            " ",
            "      console.log(stringToNumber('1234'));   // 1234 ",
            "      console.log(stringToNumber('605'));     // 605 ",
            "      console.log(stringToNumber('-605'));    // -605 ",
            "      console.log(stringToNumber('stroka'));  // NaN ",
        ]
    },
    {
        heading: "Перевести часы, минуты и секунды в миллисекунды",
        href: "https://www.youtube.com/watch?v=lp0ylcF63x0&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=25",
        taskCode: [
            "Написать функцию, которая на входе получает часы, минуты, секунды, на выходе выдает миллисекунды. ",
            "      function past(h: number, m: number, s: number) { ",
            "            return ((h * 60 + m) * 60 + s) * 1000;",
            "      } ",
            " ",
            "      console.log(past(0, 1, 1)); // 61000 ",
        ]
    },
    {
        heading: "Посчитать количество положительных и сумму отрицательных чисел в массиве.",
        href: "https://www.youtube.com/watch?v=QXrW0xESQLQ&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=26",
        taskCode: [
            "const input: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1, -12, -13, -14, -15]; ",
            " ",
            "      function countNumbers(arr: number[]) { ",
            "            return input.reduce(",
            "                  (acc, current) => {",
            "                        current >= 0 ? (acc[0] = acc[0] + 1) : (acc[1] = acc[1] + current);",
            "                        return acc;",
            "                  },",
            "                  [0, 0]",
            "            );",
            "      } ",
            " ",
            "console.log(countNumbers(input)); // [10, -55] ",
        ]
    },
    {
        heading: "Есть ли элемент в массиве? Методы arr.includes(), arr.indexOf(), arr.some().",
        href: "https://www.youtube.com/watch?v=1uopK6kF54U&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=27",
        taskCode: [
            "Нам даны массив a и значение x. Необходимо провести проверку: есть ли в массиве это значение.",
            "      const input: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1, -12, -13, -14, -15]; ",
            "      const val1 = 9; ",
            "      const val2 = 19; ",
            " ",
            "1. Метод arr.includes() ",
            "      function checkValue<T>(arr: T[], x: T) { ",
            "            return arr.includes(x);",
            "      } ",
            "      console.log(checkValue(input, val1)); // true ",
            "      console.log(checkValue(input, val2)); // false ",
            " ",
            "2. Метод arr.indexOf() ",
            "      function checkValue<T>(arr: T[], x: T) { ",
            "            const index = arr.indexOf(x);",
            "            if (index === -1) {",
            "                  return false;",
            "            } else {",
            "                  return true;",
            "            }",
            "      } ",
            " ",
            "      console.log(checkValue(input, val1)); // true ",
            "      console.log(checkValue(input, val2)); // false ",
            " ",
            "2. Метод arr.some() ",
            "Метод some() проверяет, проходит ли хотя бы один элемент в массиве проверку, реализованную предоставленной функцией. Он возвращает true, если в массиве находит элемент, для которого предоставленная функция возвращает true; в противном случае возвращается ложь. Он не изменяет массив. ",
            "      function checkValue<T>(arr: T[], x: T) { ",
            "            return arr.some((elem) => elem === x);",
            "      } ",
            " ",
            "      console.log(checkValue(input, val1)); // true ",
            "      console.log(checkValue(input, val2)); // false ",
        ]
    },
    {
        heading: "Вычислить среднее. for() vs .reduce()",
        href: "https://www.youtube.com/watch?v=pBAq9jFac5k&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=28",
        taskCode: [
            "Написать функцию, которая бы вычисляла среднее значение из чисел, которые даны нам в списке. Примечание: пустой массив должен вернуть ноль.",
            " ",
            "      const input1: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; ",
            "      const input2: number[] = [1, 2, 3, 4, 5, 6]; ",
            "      const input3: number[] = [];",
            " ",
            "1. Через цикл for(). ",
            "      function find_average(arr: number[]) { ",
            "            let sum = 0;",
            "            let average = 0;",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  sum = sum += arr[i];",
            "            }",
            "            average = sum / arr.length;",
            "            if (isNaN(average)) {",
            "                  return 0;",
            "            }",
            "            return average;",
            "      } ",
            " ",
            "console.log(find_average(input1)); // 5.5 ",
            "console.log(find_average(input2)); // 3.5 ",
            "console.log(find_average(input3)); // 0 ",
            " ",
            "2. Используем метод arr.reduce() ",
            "      function find_average(arr: number[]) { ",
            "            let sum = arr.reduce((acc, elem, _) => acc + elem, 0);",
            "            let average = sum / arr.length;",
            "            if (isNaN(average)) {",
            "                  return 0;",
            "            }",
            "                  return average;",
            "      } ",
            " ",
            "console.log(find_average(input1)); // 5.5 ",
            "console.log(find_average(input2)); // 3.5 ",
            "console.log(find_average(input3)); // 0 ",
            " ",
            "3. Используем метод arr.reduce() и тернарный оператор: ",
            "      function find_average(arr: number[]) { ",
            "            return arr.length === 0 ? 0 : arr.reduce((acc, elem, _) => acc + elem, 0) / arr.length;",
            "      } ",
            " ",
            "console.log(find_average(input1)); // 5.5 ",
            "console.log(find_average(input2)); // 3.5 ",
            "console.log(find_average(input3)); // 0 ",
        ]
    },
    {
        heading: " Необходимо рассчитать среднее значение всех чисел массива и сравнить с заданным числом.",
        href: "https://www.youtube.com/watch?v=V1f58Qnbibw&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=29",
        taskCode: [
            "Дан массив с числами и определённое число n. Необходимо рассчитать среднее значение всех чисел массива и сравнить с заданным числом. Вернуть true, если заданное число больше среднего значения, в противном случае вернуть false. Примечание: заданное для сравнения число не входит в исходный массив.",
            "      const input1: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; ",
            "      const input2: number[] = [1, 2, 3, 4, 5, 6]; ",
            "      const x = 5; ",
            " ",
            "      function betterThenAverage(arr: number[], n: number) { ",
            "            // let average = arr.reduce((acc, elem, _) => acc + elem, 0) / arr.length;",
            "            // return n > average ? true : false;",
            "            return n > arr.reduce((acc, elem, _) => acc + elem, 0) / arr.length;",
            "      } ",
            " ",
            "console.log(betterThenAverage(input1, x)); // false ",
            "console.log(betterThenAverage(input2, x)); // true ",
        ]
    },
    {
        heading: "Написать функцию: 'Hello, Sam!' 'Hello, my love!'",
        href: "https://www.youtube.com/watch?v=oH1APCZOxAU&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=30",
        taskCode: [
            "      function greet(name: string) { ",
            "            let str = 'Hello, ' + name + '!'; ",
            "            if (name === 'Johnny') { ",
            "                  str = 'Hello, my love!';",
            "            }",
            "            return str;",
            "      } ",
            " ",
            "console.log(greet('Sam')); // Hello, Sam! ",
            "console.log(greet('Johnny')); // Hello, my love! ",
        ]
    },
    {
        heading: "Фейковый бинарник. .split().map().join() vs .replace()",
        href: "https://www.youtube.com/watch?v=I9lwG4jBatE&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=31",
        taskCode: [
            "Дана строка чисел, нужно заменить каждое число, если оно меньше 5 нулём, иначе еденичкой. Возвратить результирующую строку.  ",
            "      const str1 = '5234785210398176791'; ",
            "      const str2 = '5743873468343567356'; ",
            "      const str3 = '7617345713490523409'; ",
            " ",
            "1. Цикл for(), методы split() и join(): ",
            "",
            "      function fakeBin(str: string) { ",
            "            let arr = str.split('');",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  if (Number(arr[i]) < 5) {",
            "                        arr[i] = '0';",
            "                  } else {",
            "                        arr[i] = '1';",
            "                  }",
            "            }",
            "            return arr.join('');",
            "      } ",
            " ",
            "console.log(fakeBin(str1)); // 1000111000011011110 ",
            "console.log(fakeBin(str2)); // 1100110011000111011 ",
            "console.log(fakeBin(str3)); // 1101001100010100001 ",
            " ",
            "2. Используем методы split(), map(), join() и тернарный оператор: ",
            "      function fakeBin(str: string) { ",
            "            return str",
            "                  .split('')",
            "                  .map((char) => (Number(char) < 5 ? '0' : '1'))",
            "                  .join('');",
            "      } ",
            " ",
            "console.log(fakeBin(str1)); // 1000111000011011110 ",
            "console.log(fakeBin(str2)); // 1100110011000111011 ",
            "console.log(fakeBin(str3)); // 1101001100010100001 ",
        ]
    },
    {
        heading: "Найти наименьшее и наибольшее число в строке",
        href: "https://www.youtube.com/watch?v=cJIr_zUElMc&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=4",
        taskCode: [
            "Дана строка, в ней лежат числа, разделённые пробелами. Нужно возвратить наименьшее или наибольшее число.",
            "      const str1 = '12358524'; ",
            "      const str2 = '45690234579'; ",
            "      const str3 = '364567'; ",
            " ",
            "      function maxAndMin(str: string) { ",
            "            const arrayOfNumbers = str.split('').map((n) => Number(n));",
            "            return `${Math.max(...arrayOfNumbers)} ${Math.min(...arrayOfNumbers)}`;",
            "            return arrayOfNumbers;",
            "      } ",
            " ",
            "console.log(maxAndMin(str1)); // Максимум: 8, минимум: 1 ",
            "console.log(maxAndMin(str2)); // Максимум: 9, минимум: 0",
            "console.log(maxAndMin(str3)); // Максимум: 7, минимум: 3",
        ]
    },
    {
        heading: "Перемешать элементы массива случайным образом — JS в одну строку",
        href: "https://www.youtube.com/watch?v=GZCLweorMAo",
        taskCode: [
            "const PLAYLIST: string[] = ['ACDC', 'YEE', 'CLEVERCAT', 'BTS', 'PUGACHEVA']; ",
            " ",
            "      function shuffle(arr: string[]) { ",
            "            return arr.sort(() => 0.5 - Math.random());",
            "      } ",
            " ",
            "console.log(shuffle(PLAYLIST)); // ['BTS', 'CLEVERCAT', 'YEE', 'PUGACHEVA', 'ACDC'] ",
            "console.log(shuffle(PLAYLIST)); // ['ACDC', 'YEE', 'CLEVERCAT', 'PUGACHEVA', 'BTS'] ",
            "console.log(shuffle(PLAYLIST)); // ['BTS', 'YEE', 'PUGACHEVA', 'CLEVERCAT', 'ACDC'] ",
            "console.log(shuffle(PLAYLIST)); // ['ACDC', 'YEE', 'CLEVERCAT', 'BTS', 'PUGACHEVA'] ",
        ]
    },
    {
        heading: "Сортировка массива строк по возрастанию, случайным образом.",
        href: "",
        taskCode: [
            "const str1: string[] = ['BTS', 'CLEVERCAT', 'YEE', 'PUGACHEVA', 'ACDC']; ",
            "const str2: string[] = ['ACDC', 'YEE', 'CLEVERCAT', 'PUGACHEVA', 'BTS']; ",
            "const str3: string[] = ['BTS', 'YEE', 'PUGACHEVA', 'CLEVERCAT', 'ACDC']; ",
            "const str4: string[] = ['ACDC', 'YEE', 'CLEVERCAT', 'BTS', 'PUGACHEV']; ",
            " ",
            "1. Сортировка масссива строк по возрастанию.",
            " ",
            "      function sortData(arr: string[]) { ",
            "            return arr.sort();",
            "      } ",
            " ",
            "console.log(sortData(str1)); // ['ACDC', 'BTS', 'CLEVERCAT', 'PUGACHEVA', 'YEE'] ",
            "console.log(sortData(str2)); // ['ACDC', 'BTS', 'CLEVERCAT', 'PUGACHEVA', 'YEE'] ",
            "console.log(sortData(str3)); // ['ACDC', 'BTS', 'CLEVERCAT', 'PUGACHEVA', 'YEE'] ",
            "console.log(sortData(str4)); // ['ACDC', 'BTS', 'CLEVERCAT', 'PUGACHEVA', 'YEE'] ",
            " ",
            "2. Сортировка масссива строк случайным образом.",
            " ",
            "      function mixData(arr: string[]) { ",
            "            return arr.sort(() => 0.5 - Math.random());",
            "      } ",
            " ",
            "console.log(mixData(str1)); // ['PUGACHEVA', 'YEE', 'CLEVERCAT', 'ACDC', 'BTS'] ",
            "console.log(mixData(str2)); // ['PUGACHEVA', 'CLEVERCAT', 'YEE', 'BTS', 'ACDC'] ",
            "console.log(mixData(str3)); // ['CLEVERCAT', 'BTS', 'YEE', 'ACDC', 'PUGACHEVA'] ",
            "console.log(mixData(str4)); // ['BTS', 'CLEVERCAT', 'YEE', 'ACDC', 'PUGACHEVA'] ",
        ]
    },
    {
        heading: "Сортировка массива чисел по возрастанию, убыванию, случайным образом. ",
        href: "https://www.youtube.com/watch?v=5GJ3Fh0ao9Y",
        taskCode: [
            "const num1: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; ",
            "const num2: number[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]; ",
            "const num3: number[] = [7, 1, 10, 2, 6, 3, 5, 4, 9, 8]; ",
            "const num4: number[] = [9, 8, 5, 7, 10, 3, 4, 1, 6, 2]; ",
            " ",
            "1. Сортировка массива чисел по возрастанию.",
            " ",
            "      function mixData1(arr: number[]) { ",
            "            return arr.sort((a, b) => a - b);",
            "      } ",
            " ",
            "console.log(mixData1(num1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            "console.log(mixData1(num2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            "console.log(mixData1(num3)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            "console.log(mixData1(num4)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            " ",
            "2. Сортировка массива чисел по убыванию.",
            " ",
            "      function mixData0(arr: number[]) { ",
            "            return arr.sort((a, b) => b - a);",
            "      } ",
            " ",
            "console.log(mixData0(num1)); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ",
            "console.log(mixData0(num2)); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ",
            "console.log(mixData0(num3)); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ",
            "console.log(mixData0(num4)); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ",
            " ",
            "3. Сортировка массива чисел случайным образом.",
            " ",
            "      function mixData05(arr: number[]) { ",
            "            return arr.sort(() => 0.5 - Math.random());",
            "      } ",
            " ",
            "console.log(mixData05(num1)); // [8, 9, 1, 6, 10, 2, 7, 3, 5, 4] ",
            "console.log(mixData05(num2)); // [2, 10, 7, 6, 5, 9, 4, 8, 3, 1] ",
            "console.log(mixData05(num3)); // [7, 2, 4, 6, 1, 10, 5, 9, 8, 3] ",
            "console.log(mixData05(num4)); // [2, 9, 7, 4, 3, 6, 1, 8, 5, 10] ",
        ]
    },
    {
        heading: "Отсортировать цифры в многозначном числе.",
        href: "https://www.youtube.com/watch?v=PYWkB2tOX6w&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=5",
        taskCode: [
            "Необходимо написать функцию, которая принимает на вход число, а на выходе отдаёт преобразованное, в котором слева направо расположены цифры от большего к меньшему. ",
            "      const num1 = 42156384; ",
            "      const num2 = 19384673; ",
            "      const num3 = 65779256; ",
            " ",
            "      function descendingOrder(num: number) { ",
            "            return String(num)",
            "                  .split('')",
            "                  .sort((a, b) => Number(b) - Number(a))",
            "                  .join('');",
            "      } ",
            " ",
            "console.log(descendingOrder(num1)); // 86544321 ",
            "console.log(descendingOrder(num2)); // 98764331 ",
            "console.log(descendingOrder(num3)); // 97766552 ",
        ]
    },
    {
        heading: "Мамблинг? ",
        href: "https://www.youtube.com/watch?v=_9OOYBVfXjQ&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=6",
        taskCode: [
            "Надо из строки сделать мамблинг: ",
            "      ('abcd') -> 'A-Bb-Ccc-Dddd' ",
            " ",
            "      function mumbling(str: string) { ",
            "            return str",
            "                  .split('')",
            "                  .map((char, index) => char.toUpperCase() + char.toLowerCase().repeat(index))",
            "                  .join('-');",
            "            }",
            " ",
            "      console.log(mumbling('abcd'));       // A-Bb-Ccc-Dddd ",
            "      console.log(mumbling('RqaEzty'));  // R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy ",
            "      console.log(mumbling('cwAt'));       // C-Ww-Aaa-Tttt ",
        ]
    },
    {
        heading: "Оставить в массиве только числа",
        href: "https://www.youtube.com/watch?v=IVZIuWgSP6s&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=7",
        taskCode: [
            "Нам необходимо написать функцию, которая принимает список неотрицательных чисел и строк, и возвращает новый отфильтрованный список в котором нет строк. Например:",
            "      list [1, 2, 'a', 'b']; -> [1, 2].",
            " ",
            "      function filterList(arr: (string | number)[]) { ",
            "            // return arr.filter((char) => typeof char === 'number');",
            "            return arr.filter((char) => Number.isInteger(char));",
            "      } ",
            " ",
            "console.log(filterList([1, 2, 'a', 'b'])); // [1, 2] ",
            "console.log(filterList([1, 'a', 'b', 0, 15])); // [1, 0, 15] ",
            "console.log(filterList([1, 2, 'aasf', '1', '123', 123])); // [1, 2, 123] ",
        ]
    },
    {
        heading: "Является ли число идеальным квадратом (имеет ли квадратный корень)?",
        href: "https://www.youtube.com/watch?v=6cKGc9LBdsQ&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=8",
        taskCode: [
            "Совершенным квадратом в математике называют целое число, которое является квадратом другого целого числа. Например число 4 является идеальным квадратом двойки. Нам надо написать функцию, которая проверяла бы, имеет ли переданное число целочисленный квадратный корень или нет.",
            " ",
            "      let isSquare = function (n: number) { ",
            "            return Math.pow(n, 1 / 2) % 1 === 0;",
            "      }; ",
            " ",
            "console.log(isSquare(4)); // true ",
            "console.log(isSquare(9)); // true ",
            "console.log(isSquare(10)); // false ",
            "console.log(isSquare(15)); // false ",
            "console.log(isSquare(16)); // true ",
        ]
    },
    {
        heading: "Изограмма. Не повторяются ли буквы в строке? Используем объект Set.",
        href: "https://www.youtube.com/watch?v=yzMejGUiStY&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=9",
        taskCode: [
            "Изограммой называется слово, в котором не повторяются буквы. Нам нужно напсать функцию, которая проверяла бы, является ли входная строка изограммой или нет, возвращая true или false соответственно.",
            "Будем использовать set, которая возвращает коллекцию уникальных элементов (букв) в заданной строке. ",
            " ",
            "      function isIsogram(str: string) { ",
            "            return new Set(str.toLowerCase()).size === str.length;",
            "      } ",
            " ",
            "console.log(isIsogram('Dermatoglyphics')); // true ",
            "console.log(isIsogram('moos')); // false ",
            "console.log(isIsogram('aba')); // false ",
        ]
    },
    {
        heading: "Считаем количество использования определенной буквы в строке. Использум метод Match() с регулярным выражением.",
        href: "https://www.youtube.com/watch?v=EeTa8TEnfgQ&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=10",
        taskCode: [
            "Совпадает ли количество букв Х с количеством букв О, причем регистр не важен. Если их равное количество, то возвратим true, если нет - false.",
            "XO('ooxx) => true; ",
            "XO('xooxx') => false; ",
            " ",
            "      function XO(str: string) { ",
            "            return str.match(/x/gi)?.length === str.match(/o/gi)?.length;",
            "      } ",
            " ",
            "console.log(XO('xxoo')); // true ",
            "console.log(XO('xooxx')); // false ",
            "console.log(XO('ooxXm')); // true ",
            "console.log(XO('zpzpzpp')); // true ",
            "console.log(XO('zzoo')); // false ",
        ]
    },
    {
        heading: "Найти длину самого короткого слова. Используем Math.min(). ",
        href: "https://www.youtube.com/watch?v=4nPeoE38HTQ&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=11",
        taskCode: [
            "Нам дано предложение, а мы должны найти в этом предложении самое короткое слово и вывести его длину. Для этого будем использовать Math.min(). ",
            " ",
            "      function findShort(str: string) { ",
            "            return Math.min(...str.split(' ').map((word) => word.length));",
            "      } ",
            " ",
            "console.log(findShort('thwrthw wrtodo pafgrr dogs')); // 4 ",
            "console.log(findShort('static method returns the smallest the numbers')); // 3 ",
            "console.log(findShort('if there are no parameters')); // 2 ",
        ]
    },
    {
        heading: "Каждое слово с заглавной.",
        href: "https://www.youtube.com/watch?v=rHRIXkV9HQ0&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=12",
        taskCode: [
            "const text1 = 'В ближайшее время перестановка военачальников завершится окончательно.'; ",
            "const text2 = 'Static method returns the smallest the numbers'; ",
            "const text3 = 'If there are no parameters'; ",
            " ",
            "      function toJadenCase(str: string) { ",
            "            return str",
            "                  .split(' ')",
            "                  .map((word) => word[0].toUpperCase() + word.slice(1))",
            "                  .join(' ');",
            "      } ",
            " ",
            "console.log(toJadenCase(text1));  ",
            "            // В Ближайшее Время Перестановка Военачальников Завершится Окончательно. ",
            "console.log(toJadenCase(text2)); ",
            "            // Static Method Returns The Smallest The Numbers ",
            "console.log(toJadenCase(text3));  ",
            "            // If There Are No Parameters ",
        ]
    },
    {
        heading: "Найти сумму чисел между А и В",
        href: "https://www.youtube.com/watch?v=BZTPGEZqYuo&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=15",
        taskCode: [
            "Даны два целых числа, они могут быть положительными или отрицательными. Нужно найти сумму всех целых чисел между ними, включая их самих. Порядок чисел на входе не от меньшего к большему, это тоже стоит учесть.",
            " ",
            "1-ый вариант: ",
            "",
            "      function getSum(a: number, b: number) { ",
            "            // определяем min и max методом дуструктуризации",
            "            const [min, max] = a < b ? [a, b] : [b, a]; ",
            "            return ((min + max) * (max - min + 1)) / 2;",
            "      } ",
            " ",
            "      console.log(getSum(1, 0)); // 1 ",
            "      console.log(getSum(1, 5)); // 15 ",
            "      console.log(getSum(0, 1)); // 1 ",
            "      console.log(getSum(10, -1)); // 54 ",
            "      console.log(getSum(-1, 10)); // 54 ",
            "      console.log(getSum(-1, 2)); // 2 ",
            "      console.log(getSum(15, 8)); // 92",
            " ",
            "2-ой вариант: ",
            "",
            "      const getSum = (a: number, b: number) => { ",
            "            // определяем min и max через глобальный объект Math.min() и Math.max() ",
            "            let min = Math.min(a, b),",
            "                 max = Math.max(a, b);",
            "            return ((min + max) * (max - min + 1)) / 2;",
            "      }; ",
            " ",
            "      console.log(getSum(1, 0)); // 1 ",
            "      console.log(getSum(1, 5)); // 15 ",
            "      console.log(getSum(0, 1)); // 1 ",
            "      console.log(getSum(10, -1)); // 54 ",
            "      console.log(getSum(-1, 10)); // 54 ",
            "      console.log(getSum(-1, 2)); // 2 ",
            "      console.log(getSum(15, 8)); // 92",
        ]
    },
    {
        heading: "Объеденить строки и отсортировать их, используем new Set(), spred(...), .sort(), .join(''). XO + LOL = LOX. ",
        href: "https://www.youtube.com/watch?v=0ow2FySJIfA&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=15",
        taskCode: [
            "Даны две строки, которые состоят только из букв латинского алфавита. Нужно объединить их и вернуть отсортированную строку, в которой буквы не будут повторяться.",
            " ",
            "      const a = 'sruqheruvnasdqergasadfabvd'; ",
            "      const b = 'ojgwerpomvvfdvkmfdvafddoqk'; ",
            " ",
            "      function longest(s1: string, s2: string) { ",
            "            // return new Set(s1 + s2); // так получаем объект",
            "            // return [...new Set(s1 + s2)]; // так получаем массив",
            "            return [...new Set(s1 + s2)].sort().join(''); // получаем, сортируем массив и джойним в строку.",
            "      } ",
            " ",
            "      console.log(longest(a, b));  //  abdefghjkmnopqrsuvw ",
            "      console.log(longest('cde', 'abc')); // abcde ",
        ]
    },
    {
        heading: "Получить имена, состоящие из четырёх букв, используем метод arr.filter().",
        href: "https://www.youtube.com/watch?v=jCrtqV0A7Mo&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=16",
        taskCode: [
            "      function friend(arr: string[]) { ",
            "            return arr.filter((word) => word.length === 4);",
            "      } ",
            " ",
            "      console.log(friend(['Ryan', 'Kieran', 'Mark'])); // ['Ryan', 'Mark'] ",
        ]
    },
    {
        heading: "Найти следующий идеальный квадрат",
        href: "https://www.youtube.com/watch?v=y7FsXcbxOv8&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=16",
        taskCode: [
            "В этой задаче надо найти следующий идеальный квадрат, иначе вывести -1. Примеры:",
            "      121 --> 144 ",
            "      525 --> 676 ",
            "      114 --> -1",
            " ",
            "      function findNextSquare(sq: number) { ",
            "            const source = Math.pow(sq, 1 / 2);",
            "            return source % 1 === 0 ? Math.pow(source + 1, 2) : -1;",
            "      } ",
            " ",
            "      console.log(findNextSquare(121)); // 144 ",
            "      console.log(findNextSquare(114)); // -1 ",
        ]
    },
    {
        heading: "Посчитать количество букв, не входящих в промежуток от А до М",
        href: "https://www.youtube.com/watch?v=7YcBiMC7XJ8&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=17",
        taskCode: [
            "В этой задаче нужно вывести количество букв, не входящих в промежуток от А до М.  ",
            " ",
            "      function printerError(s: string) { ",
            "            return `${s.replace(/a-m/gi, '').length}/${s.length}`;",
            "      } ",
            " ",
            "      console.log(printerError('aaabbbbbhaijjjjm')); // 16/16 ",
            "      console.log(printerError('adm')); // 3/3 ",
        ]
    },
    {
        heading: "Валидация PIN кода",
        href: "https://www.youtube.com/watch?v=TXo6ocN1FZs&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=18",
        taskCode: [
            "Если у пин-кода 4 цифры или 6, то пин-код валидный. Если нет, то не валиден. ",
            " ",
            "      function validationPIN(pin: string) { ",
            "            return pin.length === 4 || pin.length === 6;",
            "      } ",
            " ",
            "      console.log(validationPIN('1234')); // true ",
            "      console.log(validationPIN('12345')); // false ",
            "      console.log(validationPIN('123456')); // true ",
            "      console.log(validationPIN('1234567')); // false ",
        ]
    },
    {
        heading: "Как получить сумму десятичных чисел в двоичном исчислении.",
        href: "https://www.youtube.com/watch?v=yjpRP-Q_B_4&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=19",
        taskCode: [
            "Как получить сумму десятичных чисел в двоичном исчислении.",
            " ",
            "      function addBinary(a: number, b: number) { ",
            "            return (a + b).toString(2);",
            "      } ",
            " ",
            "      console.log(addBinary(1, 1)); // 10 ",
            "      console.log(addBinary(1, 2)); // 11 ",
            "      console.log(addBinary(5, 9)); // 1110 ",
            "      console.log(addBinary(51, 12)); // 111111 ",
        ]
    },
    {
        heading: "Можно ли построить треугольник?",
        href: "https://www.youtube.com/watch?v=gC136VplPvc&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=20",
        taskCode: [
            "Можно ли построить треугольник с длинами рёбер, которые задаются как аргументы функции.",
            "    *  Правило из геометрии: ",
            "Треугольник существует только тогда, когда сумма длин любых его двух сторон больше третьей стороны. Чтобы треугольник существовал, сумма двух сторон треугольника всегда должна быть больше третей стороны. a + b > c, b + c > a, a + c > b. ",
            " ",
            "      function checkTriangle(a: number, b: number, c: number) { ",
            "            return a + b > c && a + c > b && b + c > a ? true : false;",
            "      } ",
            " ",
            "      console.log(checkTriangle(1, 2, 2)); // true ",
            "      console.log(checkTriangle(7, 2, 3)); // false ",
        ]
    },
    {
        heading: "Нечётная пирамида. Сумма чисел в строке N",
        href: "https://www.youtube.com/watch?v=3HHx6t5NqtU&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=21",
        taskCode: [
            "Дан треугольник с нечётными числами, надо вычислить сумму чисел в строке N. ",
            " ",
            "               1                            // 1 = 1 * 1 * 1",
            "             3   5                       //   8 = 2 * 2 * 2",
            "          7   9   11                  //  27 = 3 * 3 * 3",
            "      13  15  17  19              //  64 = 8 * 8 * 8",
            "   21  23  25  27  29          // 125 = 5 * 5 * 5",
            " ",
            "Получается, что нам надо вычислить куб числа N: ",
            "      function rowSumOddNumbers(n: number) { ",
            "            // return n * n * n;",
            "            return Math.pow(n, 3);",
            "      } ",
            " ",
            "      console.log(rowSumOddNumbers(1)); // 1 ",
            "      console.log(rowSumOddNumbers(2)); // 8 ",
            "      console.log(rowSumOddNumbers(3)); // 27 ",
            "      console.log(rowSumOddNumbers(4)); // 64 ",
            "      console.log(rowSumOddNumbers(5)); // 125 ",
            "      console.log(rowSumOddNumbers(6)); // 216 ",
        ]
    },
    {
        heading: "Из двоичной системы счисления в десятичную",
        href: "https://www.youtube.com/watch?v=veppXajCRYg&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=22",
        taskCode: [
            "Дан массив чисел единиц и нулей. Нужно объединить их и перевести в десятичное представление.",
            " ",
            "      function binaryArrayToNumber(arr: number[]) { ",
            "            return parseInt(arr.join(''), 2);",
            "      } ",
            " ",
            "      console.log(binaryArrayToNumber([0, 0, 0, 1])); // 1 ",
            "      console.log(binaryArrayToNumber([0, 0, 1, 0])); // 2 ",
            "      console.log(binaryArrayToNumber([0, 1, 0, 1])); // 5 ",
            "      console.log(binaryArrayToNumber([1, 0, 0, 1])); // 9 ",
            "      console.log(binaryArrayToNumber([0, 1, 1, 0])); // 6 ",
            "      console.log(binaryArrayToNumber([1, 1, 1, 1])); // 15 ",
            "      console.log(binaryArrayToNumber([1, 0, 1, 1])); // 11 ",
        ]
    },
    {
        heading: "Заканчивается ли строка определёнными символами? Метод endsWith().",
        href: "https://www.youtube.com/watch?v=2kMdSVov3sA&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=23",
        taskCode: [
            "Метод endsWith() позволяет определить, заканчивается ли строка символами указанными в скобках, возвращая, соответственно, true или false. ",
            " ",
            "      function solution(str: string, ending: string) { ",
            "            return str.endsWith(ending);",
            "      } ",
            " ",
            "      console.log(solution('abc', 'bc')); // true ",
            "      console.log(solution('abc', 'd')); // false ",
        ]
    },
    {
        heading: "Посчитать пассажиров в автобусе",
        href: "https://www.youtube.com/watch?v=2W5oPNaIZtc&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=24",
        taskCode: [
            "Нужно посчитать количество пассажиров в автобусе на конечной остановке. Сначала он пустой, на каждой остановке в него входят и выходят пассажиры. Дан массив массивов, каждый элемент основного массива - остановка, внутри массив из двух элементов: входящие и выходящие пассажиры. ",
            "// remainder  --> остаток пассажиров в автобусе в начале пути",
            "// entered      --> вошло пассажиров ",
            "// released     --> вышло пассажиров ",
            " ",
            "      const arrArr1 = [ ",
            "            [10, 0],    // [вошло, вышло]",
            "            [3, 5],      // [entered, released],",
            "            [5, 8],",
            "      ]; ",
            " ",
            "      const arrArr2 = [ ",
            "            [3, 0],",
            "            [9, 1],",
            "            [4, 10],",
            "            [12, 2],",
            "            [6, 1],",
            "            [7, 10],",
            "      ]; ",
            " ",
            "      const arrArr3 = [ ",
            "            [3, 0],",
            "            [9, 1],",
            "            [4, 8],",
            "            [12, 2],",
            "            [6, 1],",
            "            [7, 8],      // [entered, released],",
            "      ]; ",
            " ",
            "      const number = function (busStop: number[][]) { ",
            "                                                                 // [entered, released]  делаем деструктуризацию подмассива",
            "            return busStop.reduce((remainder, [entered, released]) => remainder + entered - released, 0); ",
            "      }; ",
            " ",
            "      console.log(number(arrArr1)); // 5 ",
            "      console.log(number(arrArr2)); // 17 ",
            "      console.log(number(arrArr3)); // 21 ",
        ]
    },
    {
        heading: "Чётная или нечётная сумма чисел в массиве",
        href: "https://www.youtube.com/watch?v=5f-6MqSnk-I&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=25",
        taskCode: [
            "Как посчитать числа в массиве и узнать, является эта сумма чётным или нечётным числом.  ",
            " ",
            "      function summation(arr: number[]) { ",
            "            return arr.reduce((sum, el, _) => sum + el, 0) % 2 === 0 ? 'even' : 'odd';",
            "      } ",
            " ",
            "      console.log(summation([0]));              //  even ",
            "      console.log(summation([0, 1, 4]));       //  odd ",
            "      console.log(summation([0, -1, -5]));    //  even ",
            "      console.log(summation([0, 3, 5]));       //  even ",
        ]
    },
    {
        heading: "Все элементы массива подходят под условие? ",
        href: "https://www.youtube.com/watch?v=84uzDcf2OIo&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=26",
        taskCode: [
            "Дан массив чисел и лимит, нужно убедиться, что все значения в массиве ниже или равны этому предельному значению и вернуть true или false соответственно.  ",
            " ",
            "      function smallEnough(arr: Array<number>, limit: number) { ",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  if (arr[i] > limit) return false;",
            "            }",
            "            return true;",
            "      } ",
            " ",
            "      console.log(smallEnough([1, 5, 8, 9, 12], 15));     // true ",
            "      console.log(smallEnough([1, 5, 8, 9, 12], 12));     // true ",
            "      console.log(smallEnough([1, 5, 8, 9, 12], 7));       // false ",
        ]
    },
    {
        heading: "Возвратить индекс среднего числа в массиве из трёх элементов",
        href: "https://www.youtube.com/watch?v=ZZXjyTcSnkA&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=27",
        taskCode: [
            "      function gimme(triplet: number[]) { ",
            "            // Деструктуризацию [...triplet] применяем для того, чтобы не мутировать исходник",
            "            return triplet.indexOf([...triplet].sort((a, b) => a - b)[1]);",
            "      } ",
            " ",
            "      console.log(gimme([2, 3, 1])); // 0",
            "      console.log(gimme([5, 10, 14])); // 1 ",
            "      console.log(gimme([14, 13, 1])); // 1 ",
        ]
    },
    {
        heading: "Анаграмма",
        href: "https://www.youtube.com/watch?v=Y1WzcRO9fNg&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=28",
        taskCode: [
            "Анаграмма-это слово или фраза, образованные путем перестановки букв другого слова или фразы, обычно используя все исходные буквы ровно один раз. ",
            "Нужно вернуть true, если два слова являются анаграммой, false - если не являются.",
            " ",
            "      function isAnagram(test: string, original: string) { ",
            "            // сортируем стандартно, стандартная сортировка работает со строками",
            "            const sortString = (str: string) => str.toLowerCase().split('').sort().join('');",
            "            return sortString(test) === sortString(original);",
            "      } ",
            " ",
            "      console.log(isAnagram('foefet', 'toFfee')); // true ",
            "      console.log(isAnagram('bucKethead', 'deathCubec')); // false ",
        ]
    },
    {
        heading: "Факториал. For(), рекурсия. Обработка допустимых значений",
        href: "https://www.youtube.com/watch?v=VEw4H581h5c&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=29",
        taskCode: [
            "Факториал числа n — это произведение всех натуральных чисел от 1 до n включительно. Обозначается переменной n! (произносится: «эн факториал»). Факторизация — разложение функции на множители. Факториал активно используется в комбинаторике, математическом анализе, теории чисел, функциональном анализе и т.д. В школьном курсе изучается на алгебре. Факториал имеет вид: n != 1 * 2 * 3 * 4 … * n. По конвенции, факториал нуля равен единице.",
            "Написать функцию, которая бы высчитывала факориал и делала исключение для чисел, которые меньше нуля и больше 12: if ( n < 0 || n > 12 ) ",
            " ",
            "1. Через цикл for() ",
            " ",
            "      function factorial(n: number): any { ",
            "            if (n < 0 || n > 12) console.log('Ошибка, число n меньше 0 или больше 12');",
            "            let f = 1;",
            "            for (let i = 1; i <= n; i++) {",
            "                  f *= i;",
            "            }",
            "            return f;",
            "      } ",
            " ",
            "      console.log(factorial(-2)); // Ошибка, число n меньше 0 или больше 12 ",
            "      console.log(factorial(0)); // 1 ",
            "      console.log(factorial(5)); // 120 ",
            "      console.log(factorial(15)); // Ошибка, число n меньше 0 или больше 12 ",
            " ",
            "2. Через рекурсию ",
            " ",
            "      function factorial(n: number): any { ",
            "            if (n < 0 || n > 12) console.log('Ошибка, число n меньше 0 или больше 12');",
            "            return n <= 1 ? 1 : n * factorial(n - 1);",
            "      } ",
            " ",
            "      console.log(factorial(-2)); // Ошибка, число n меньше 0 или больше 12 ",
            "      console.log(factorial(0)); // 1 ",
            "      console.log(factorial(5)); // 120 ",
            "      console.log(factorial(15)); // Ошибка, число n меньше 0 или больше 12 ",
            " ",
        ]
    },
    {
        heading: "Найти индексы заглавных букв.",
        href: "https://www.youtube.com/watch?v=fr2JaGzLpek&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=30",
        taskCode: [
            "Нужно написать фунцию, котрая принимает строку и возвращает индексы заглавных букв. ",
            " ",
            "      function capitals(str: string) { ",
            "            return str.split('').reduce((list: number[], char: string, i: number) => {",
            "                  if (char === char.toUpperCase()) list.push(i);",
            "                  return list;",
            "                  // аккумулятор в нашем случае - пустой массив [].",
            "            }, []);",
            "      } ",
            " ",
            "      console.log(capitals('ЮраБудетДутьДуть')); // [0, 3, 8, 12] ",
        ]
    },
    {
        heading: "Найти индексы прописных букв (нижнего регистра).",
        href: "https://www.youtube.com/watch?v=fr2JaGzLpek&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=30",
        taskCode: [
            "Нужно написать фунцию, котрая принимает строку и возвращает индексы прописных букв.",
            " ",
            "      function capitals(str: string) { ",
            "            return str.split('').reduce((list: number[], char: string, i: number) => {",
            "                  if (char === char.toLowerCase()) list.push(i);",
            "                  return list;",
            "                  // аккумулятор в нашем случае - пустой массив [].",
            "            }, []);",
            "      } ",
            " ",
            "      console.log(capitals('ЮраБудетДутьДуть')); // [1, 2, 4, 5, 6, 7, 9, 10, 11, 13, 14, 15]",
        ]
    },
    {
        heading: "Избавится от подмассивов.  Распакавать (развернуть) и отсортировать вложеные массивы в один массив.",
        href: "https://www.youtube.com/watch?v=3QZFHgCiX70&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=31",
        taskCode: [
            "Метод flat() создает новый массив со всеми элементами подмассива, объединенными в него рекурсивно до указанной глубины. ",
            "Дан массив, в котором лежат другие массивы. Нужно избавиться от подмассивов и отсортировать результат.",
            "      const arrArr = [[3, 2, 1], [4, 6, 5], [[[10, 11]]], [[[[[[[[[12]]]]]]]]], [9, 7, 8]]; ",
            " ",
            "      const flatter = (array: any[]) => { ",
            "            // Используем бесконечный уровень вложенности - Infinity:",
            "            return array.flat(Infinity).sort((a, b) => a - b);",
            "      }; ",
            " ",
            "      console.log(flatter(arrArr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ",
        ]
    },
    {
        heading: "Найти лишнее число в массиве одинаковых элементов. Метод find().",
        href: "https://www.youtube.com/watch?v=1h5Hi677bFE&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=32",
        taskCode: [
            "Найти лишнее число в массиве одинаковых элементов. ",
            "Метод find() возвращает первый элемент предоставленного массива, который удовлетворяет предоставленной функции тестирования. Если никакие значения не удовлетворяют функции тестирования, undefinedвозвращается. ",
            " ",
            "      const source = [17, 3, 17, 17, 17, 17, 17, 17, 17]; ",
            " ",
            "      const stray = (array: number[]) => { ",
            "            const [first, second, third] = array;",
            "            if (first === second) {",
            "                  return array.find((num) => num !== first);",
            "            }",
            "",
            "            return first === third ? second : first;",
            "      }; ",
            " ",
            "      console.log(stray(source)); // 3",
        ]
    },
    {
        heading: "Отсортировать массив объектов",
        href: "https://www.youtube.com/watch?v=yQmomPZgYeM&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=33",
        taskCode: [
            "Статический Object.values() метод возвращает массив собственных перечисляемых значений свойств данного объекта со строковыми ключами. ",
            "      const object1 = { ",
            "            a: 'somestring',",
            "            b: 42,",
            "            c: false",
            "      }; ",
            "      console.log(Object.values(object1)); //  ['somestring', 42, false] ",
            " ",
            "Дан массив объектов, в каждом объекте лежат фрукты. Ключ - это наименование фрукта, значение - это вес фрукта. Нужно отсортировать этот массив по общему весу фруктов.",
            "      const arrFruits = [ ",
            "            { apple: 8, banana: 10, kiwi: 2 },",
            "            { lemon: 2, cherry: 3, apple: 9 },",
            "            { peach: 4, apple: 12, lemon: 8 },",
            "      ]; ",
            " ",
            "      const sortFruits = (arr: any[]) => { ",
            "            const totalWeight = (fruits: object) => {",
            "                  const onlyNumbers = Object.values(fruits);",
            "                  return onlyNumbers.reduce((sum, n, i) => sum + n, 0);",
            "            };",
            "            return arr.sort((a, b) => totalWeight(b) - totalWeight(a));",
            "      }; ",
            " ",
            "console.log(sortFruits(arrFruits)); ",
            "/* ",
            "      [ ",
            "            { peach: 4, apple: 12, lemon: 8 },",
            "            { apple: 8, banana: 10, kiwi: 2 },",
            "            { lemon: 2, cherry: 3, apple: 9 },",
            "      ];",
            "*/ ",
        ]
    },
    {
        heading: "Сколько раз нужно сломать шоколадную плитку N x M? ",
        href: "https://www.youtube.com/watch?v=qqCz0-7yxgc&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=34",
        taskCode: [
            "Сколько раз нужно сломать шоколадную плитку N x M, чтобы остались только единичные дольки? ",
            " ",
            "      const numberOfFaults = (n: number, m: number) => { ",
            "            return n * m - 1;",
            "      }; ",
            " ",
            "      console.log(numberOfFaults(1, 1)); // 0 ",
            "      console.log(numberOfFaults(2, 2)); // 3 ",
            "      console.log(numberOfFaults(2, 3)); // 5 ",
            "      console.log(numberOfFaults(4, 4)); // 15 ",
        ]
    },
    {
        heading: "Каждому элементу массива задать порядковый префикс",
        href: "https://www.youtube.com/watch?v=onczhNMhM6E&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=35",
        taskCode: [
            "      const addPrefix = (array: string[]) => { ",
            "            // return array.map((el, i) => String(i + 1) + ':' + el);",
            "            return array.map((el, i) => `${i + 1}:${el}`);",
            "      }; ",
            " ",
            "      console.log(addPrefix(['a', 'b', 'c'])); // ['1:a', '2:b', '3:c'] ",
        ]
    },
    {
        heading: "Удалить элемент из массива, не мутируя массив.",
        href: "https://www.youtube.com/watch?v=Fg6V6W9jGQs&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=36",
        taskCode: [
            "Нужно удалить наименьший элемент из массива, не мутируя массив. ",
            " ",
            "      const source = [ 9, 1, 8, 7, 6 ];  ",
            " ",
            "      const withoutMin = ( numbers: Array<number> ) => { ",
            "            // Используем ( ...numbers ), чтобы превратить массив в список и применить Math.min",
            "            const minIndex = numbers.indexOf( Math.min( ...numbers ));",
            "            // return [ ...numbers.slice( 0, minIndex ), ...numbers.slice( minIndex + 1 )]; // 1-ый способ",
            "            return [ ...numbers ].filter(( _, i ) => i !== minIndex); // 2-ой способ",
            "      }; ",
            " ",
            "console.log(source);                          // [9, 1, 8, 7, 6] ",
            "console.log(withoutMin(source));     // [9, 8, 7, 6] ",
        ]
    },
    {
        heading: "Как найти индексы двух чисел в массиве, которые вместе дадут заданную сумму?",
        href: "https://www.youtube.com/watch?v=XzeFeUEGY8M",
        taskCode: [
            "1-ый вариант через 2 вложеннных цикла for() ",
            "      const sumOfTwo = (arr: Array<number>, target: number) => { ",
            "            const result: number[] = [];",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  for (let j = i + 1; j < arr.length; j++) {",
            "                        if (arr[i] + arr[j] === target) {",
            "                              result.push(i);",
            "                              result.push(i);",
            "                        }",
            "                  }",
            "            }",
            "            return result;",
            "      } ",
            " ",
            "      console.log(sumOfTwo([2, 7, 11, 15], 22)); // [1, 3] ",
            " ",
            "2-ой вариант через 2 последовательных цикла for() ",
            " ",
            "      interface IMapIndex { ",
            "            [key: string]: number;",
            "      } ",
            " ",
            "      const sumOfTwo = (arr: Array<number>, target: number) => { ",
            "            const numObject: IMapIndex = {}; // получится numObject = { 2: 0, 7: 1, 11: 2, 15: 3 };",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  numObject[arr[i]] = i;",
            "            }",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  const diff = target - arr[i];",
            "                  if (numObject[diff] && numObject[diff] !== i) {",
            "                        return [i, numObject[diff]];",
            "                  }",
            "            }",
            "            return [];",
            "      }; ",
            " ",
            "      console.log(sumOfTwo([2, 7, 11, 15], 9)); // [0, 1] ",
            " ",
            "Если в массиве нет чисел дающих нужную сумму, то возвращаем пустой массив ",
            "      console.log(sumOfTwo([2, 7, 11, 15], 90)); // [] ",
            "      console.log(sumOfTwo([2, 7, 11, 15], 14)); // [] ",
        ]
    },
    {
        heading: "Удалить'якорь' из ссылки ",
        href: "https://www.youtube.com/watch?v=yvs43H1mc70&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=37",
        taskCode: [
            "Нужно очистить строку от того, что идёт после решётки и саму решётку тоже.  ",
            "1. Самый короткий способ: ",
            " ",
            "      const urlWithoutBookMarks = (url: string) => { ",
            "            return url.split('#')[0];",
            "      }; ",
            " ",
            "      console.log(urlWithoutBookMarks('dzen.ru?search=новости#нутакое'));  // dzen.ru?search=новости ",
            " ",
            "2. Через [...arr].filter() ",
            " ",
            "      const urlWithoutBookMarks = (url: string) => { ",
            "            let arr = url.split('#');",
            "            return [...arr].filter((_, i) => i !== 1);",
            "      }; ",
            " ",
            "      console.log(urlWithoutBookMarks('dzen.ru?search=новости#нутакое')); // dzen.ru?search=новости ",
        ]
    },
    {
        heading: "Округлить число до следующего, кратного пяти",
        href: "https://www.youtube.com/watch?v=_pvEu0d5ncw&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=38",
        taskCode: [
            "      -5 => -5 ",
            "      -2 => 0 ",
            "      12 => 15 ",
            "      21 => 25 ",
            " ",
            "      const next5 = (n: number) => { ",
            "            while (n % 5 !== 0) n++;",
            "            return n;",
            "      }; ",
            " ",
            "console.log(next5(-5)); // -5 ",
            "console.log(next5(-2)); // 0 ",
            "console.log(next5(12)); // 15 ",
            "console.log(next5(21)); // 25 ",
        ]
    },
    {
        heading: "Возвратить все делители числа в виде отсортированного массива",
        href: "https://www.youtube.com/watch?v=936_xj4eZcM&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=39",
        taskCode: [
            "1 вариант, для небольшого числа: ",
            "      function getDivisors(n: number) { ",
            "            let divisors: number[] = [];",
            "            for (let i = 2; i < n; i++) {",
            "                  if (n % i === 0) divisors.push(i);",
            "            }",
            "            return divisors.length ? divisors : 'Простое число';",
            "      } ",
            "",
            "      console.log(getDivisors(13)); // Простое число ",
            "      console.log(getDivisors(15)); // [3, 5] ",
            "      console.log(getDivisors(16)); // [2, 4, 8] ",
            " ",
            "2-ой вариант, для миллиарда:  ",
            "      function getDivisors2(n: number) { ",
            "            let divisors: number[] = [];",
            "            const rootSqare = n ** 0.5; // находим квадратный корень числа n",
            "            for (let i = 2; i < rootSqare; i++) {",
            "                  if (n % i === 0) {",
            "                        divisors.push(i, n / i);",
            "                  }",
            "            }",
            "",
            "            if (Number.isInteger(rootSqare)) {",
            "                  divisors.push(rootSqare);",
            "            }",
            "",
            "            divisors.sort((a, b) => a - b);",
            "            return divisors.length ? divisors : 'Простое число';",
            "      } ",
            "      console.log(getDivisors(13)); // Простое число ",
            "      console.log(getDivisors(15)); // [3, 5] ",
            "      console.log(getDivisors(16)); // [2, 4, 8] ",
            " ",
            "Метод Number.isInteger()определяет переданное значение большого числа. ",
        ]
    },
    {
        heading: "Найти сумму внутренних углов n-стороннего многоугольника",
        href: "https://www.youtube.com/watch?v=x6bwhwY4WUk&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=41",
        taskCode: [
            "sides - количество сторон многоугольника.  ",
            " ",
            "      const sumAngle = (sides: number) => { ",
            "            return (sides - 2) * 180;",
            "      }; ",
            " ",
            "      console.log(sumAngle(3)); // 180 ",
            "      console.log(sumAngle(4)); // 360 ",
            "      console.log(sumAngle(8)); // 1080 ",
        ]
    },
    {
        heading: "Максимальное произведение двух соседних чисел в массиве",
        href: "https://www.youtube.com/watch?v=Audug9Yyv2A&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=42",
        taskCode: [
            "      const source = [9, 5, 10, 2, 24, -1, 48]; ",
            " ",
            "      const maxAdd = (arr: number[]) => { ",
            "            const addNumbers = [];",
            "",
            "            // ключевое (i < arr.length - 1)",
            "            for (let i = 0; i < arr.length - 1; i++) {",
            "                  addNumbers.push(arr[i] * arr[i + 1]);",
            "            }",
            "            // return addNumbers; // [45, 50, 20, 48, -24, -48]",
            "            return Math.max(...addNumbers);",
            "      }; ",
            " ",
            "console.log(maxAdd(source)); // 50 ",
        ]
    },
    {
        heading: "Длина цепи палиндрома",
        href: "Палиндромом называется число или строка, которые читаются одинаково как слева направо, так и справа налево. Например, слово «АТАТА» — это палиндром, а вот слово «АЙАЙАЙ» — нет.",
        taskCode: [
            "      const palindromeChainLength = (n: number): number => { ",
            "            const r = Number(n.toString().split('').reverse().join(''));",
            "            return r - n && 1 + palindromeChainLength(r + n);",
            "      }; ",
            " ",
            "      console.log(palindromeChainLength(12)); // 1 ",
            "      console.log(palindromeChainLength(49)); // 2 ",
            "      console.log(palindromeChainLength(87)); // 4 ",
        ]
    },
    {
        heading: "Написать функцию, которая определяет, является ли переданная строка-слово палиндромом (читается одинаково слева направо, и справа налево.)",
        href: "",
        taskCode: [
            "      const isPalindrome = (n: string) => { ",
            "            const r = n.toLowerCase().split('').reverse().join('');",
            "            return r === n.toLowerCase();",
            "      }; ",
            "",
            "      console.log(isPalindrome('Abba')); // true",
            "      console.log(isPalindrome('Aba')); // true ",
            "      console.log(isPalindrome('Abaka')); // false ",
            "      console.log(isPalindrome('Казак')); // true ",
        ]
    },
    {
        heading: "Написать функцию, которая определяет, является ли переданная строка палиндромом (читается одинаково слева направо, и справа налево. 7m52)",
        href: "https://www.youtube.com/watch?v=8pRGuvkzK7Y",
        taskCode: [
            "      function isPalindrome(str: string) { ",
            "            let start = 0; // указатель на первый элемент в строке",
            "            let end = str.length - 1; // указатель на последний элемент в строке",
            "            while (start < end) {",
            "                  if (str[start].toLowerCase() === str[start].toUpperCase()) {",
            "                        // Проверяем, являются ли наши символы буквами. Смысл в том, что буквы разных",
            "                        // регистров отличаются друг от друга, а символы и пробелы не отличаются.",
            "                        start += 1;",
            "                        continue;",
            "                  }",
            "",
            "                  if (str[end].toLowerCase() === str[end].toUpperCase()) {",
            "                        // Проверяем, являются ли наши символы буквами. Смысл в том, что буквы разных",
            "                        // регистров отличаются друг от друга, а символы и пробелы не отличаются.",
            "                        end -= 1;",
            "                        continue;",
            "                  }",
            "                  if (!isEquals(firstChar, endChar)) {",
            "                        // Проверяем равенство первого с последним элементом",
            "                        return false;",
            "                  }",
            "                  start += 1; // сдвигаем  указатели",
            "                  end -= 1; // сдвигаем  указатели",
            "            }",
            "            return true;",
            "      } ",
            " ",
            "console.log(isPalindrome('Казак')); // true ",
            "console.log(isPalindrome('А роза упала на лапу Азора')); // true ",
            "console.log(isPalindrome('Do geese see God')); // true ",
            "console.log(isPalindrome('Madam, I'm Adam')); // true ",
        ]
    },
    {
        heading: "Необходимо проверить, является ли число простым. ",
        href: "https://www.youtube.com/watch?v=s8zUK5jmXA4",
        taskCode: [
            "1-ый вариант: ",
            " ",
            "      function isPrime(n: number) { ",
            "            let arr: number[] = [];",
            "            for (let i = 2; i < n; i++) {",
            "                  if (n % i === 0) {",
            "                        // arr.push(i);",
            "                        arr = [...arr, i]; // можно и так добавить элемент в массив",
            "                  }",
            "            }",
            "            return arr.length ? `Число делится на ${arr.join(', ')}` : 'число является простым';",
            "      } ",
            " ",
            "      console.log(isPrime(4)); // Число делится на 2 ",
            "      console.log(isPrime(9)); // Число делится на 3 ",
            "      console.log(isPrime(15)); // Число делится на 3, 5 ",
            "      console.log(isPrime(23)); // число является простым ",
            " ",
            "2-ой вариант: ",
            " ",
            "      function isPrime(n: number) { ",
            "            //for (let i = 2, max = Math.pow(n, 1 / 2); i <= max; i++) {",
            "            for (let i = 2, max = Math.sqrt(n); i <= max; i++) { // то же самое, корень из числа n",
            "                  if (n % i === 0) {",
            "                        return false;",
            "                  }",
            "            }",
            "            return n > 1;",
            "      } ",
            " ",
            "      console.log(isPrime(2)); // true ",
            "      console.log(isPrime(6)); // false ",
            "      console.log(isPrime(23)); // true ",
            "      console.log(isPrime(109)); // true ",
            "      console.log(isPrime(111)); // false ",
            " ",
            "3. Другая задача. Необходимо написать функцию, которая будет принимать один аргумент - это число, до которого нам необходимо найти все простые числа, которые есть. Например дано число 120, нам необходимо найти все простые числа от 2 до 120. ",
            "Берём нашу функцию isPrime() ",
            "      function isPrime(n: number) { ",
            "            //for (let i = 2, max = Math.pow(n, 1 / 2); i <= max; i++) {",
            "            for (let i = 2, max = Math.sqrt(n); i <= max; i++) { // то же самое, корень из числа n",
            "                  if (n % i === 0) {",
            "                        return false;",
            "                  }",
            "            }",
            "            return n > 1;",
            "      } ",
            " ",
            "Создаём новую функцию: ",
            "      function getPrimes(num: number) { ",
            "            const primes: number[] = [];",
            "            for (let i = 2; i <= num; i++) {",
            "                  if (isPrime(i)) {",
            "                        primes.push(i);",
            "                  }",
            "            }",
            "            return primes;",
            "      } ",
            "      console.log(getPrimes(20)); // [2, 3, 5, 7, 11, 13, 17, 19]",
            "      console.log(getPrimes(120)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]",
            " ",
            "4. Эта же задача, решаем способом 'Решето Эратосфена'. ",
            "      function getPrimes(num: number) { ",
            "            const seive: boolean[] = [];",
            "            const primes: number[] = [];",
            "            for (let i = 2; i <= num; i++) {",
            "                  if (!seive[i]) {",
            "                        primes.push(i);",
            "                        for (let j = i * 2; j <= num; j += i) {",
            "                              seive[j] = true;",
            "                        }",
            "                  }",
            "            }",
            "            return primes;",
            "      } ",
            "",
            "      console.log(getPrimes(20)); // [2, 3, 5, 7, 11, 13, 17, 19]",
            "      console.log(getPrimes(120)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113]",
        ]
    },
    {
        heading: "Элементарный калькулятор, основные математические операции. Опасный eval() и старый добрый switch case ",
        href: "https://www.youtube.com/watch?v=_sGHC3PeBAc&t=1s",
        taskCode: [
            "У нас есть три аргумента: математическая операция и два числа. ",
            "1. Опасный eval() ",
            "Функция JavaScript eval() потенциально опасна и часто используется не по назначению. Использование eval() ненадежного кода может открыть программу для нескольких различных атак путем внедрения. Использование eval() в большинстве контекстов может быть заменено лучшим, альтернативным подходом к проблеме. Хакеры смогут запустить какой угодно код, когда мы используем eval().",
            " ",
            "      function basicOp(operation: string, value1: number, value2: number): number { ",
            "            return eval(`${value1}${operation}${value2}`);",
            "      } ",
            "      console.log(basicOp('+', 4, 7));        // 11 ",
            "      console.log(basicOp('-', 118, 18));   // 100 ",
            "      console.log(basicOp('*', 5, 5));         // 25 ",
            "      console.log(basicOp('/', 49, 7));       // 7 ",
            " ",
            "2. Cтарый добрый switch case. ",
            " ",
            "      function basicOp(operation: string, value1: number, value2: number) { ",
            "            switch (operation) {",
            "                  case '+':",
            "                        return value1 + value2;",
            "                  case '-':",
            "                        return value1 - value2;",
            "                  case '*':",
            "                        return value1 * value2;",
            "                  case '/':",
            "                        return value1 / value2;",
            "                  default:",
            "                        return 0;",
            "            }",
            "      } ",
            "      console.log(basicOp('+', 4, 7));        // 11 ",
            "      console.log(basicOp('-', 118, 18));   // 100 ",
            "      console.log(basicOp('*', 5, 5));         // 25 ",
            "      console.log(basicOp('/', 49, 7));       // 7 ",
            "      console.log(basicOp('', 49, 7)); // 0",
        ]
    },
    {
        heading: "Найти сумму всех чисел, кратных 3 или 5, меньше переданного числа.",
        href: "https://www.youtube.com/watch?v=WCIpXcwvXpw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=2",
        taskCode: [
            "Например: 16 => 3 + 5 + 6 + 9 + 10 + 12 + 15 = 60 ",
            "      const sum35 = (n: number) => { ",
            "            let arr: number[] = [];",
            "            for (let i = 1; i < n; i++) {",
            "                  if (i % 3 === 0 || i % 5 === 0) {",
            "                        arr.push(i);",
            "                  }",
            "            }",
            "            return arr.reduce((acc, el, i) => acc + el, 0);",
            "      }; ",
            " ",
            "      console.log(sum35(16)); // 60 ",
            "      console.log(sum35(25)); // 143 ",
        ]
    },
    {
        heading: "Удалить дубликаты из отсортированного массива?",
        href: "https://www.youtube.com/watch?v=Y9GCuYLSDes&list=PL0k-9Y7O1GwccXKHRzmvVj17yB7T9pjTo&index=20",
        taskCode: [
            "1. Используем new Set(): ",
            "      const arr1 = [1, 1, 2]; ",
            "      const arr2 = [0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4]; ",
            "      const arr3 = ['a', 'a', 'b', 'b', 'c', 'c', 'c']; ",
            " ",
            "      function removeDublicates<T>(arr: Array<T>) { ",
            "            const mySet = new Set(arr);",
            "            const array: Array<T> = Array.from(mySet);",
            "            return array;",
            "      } ",
            "      console.log(removeDublicates(arr1)); // [1, 2] ",
            "      console.log(removeDublicates(arr2)); // [0, 1, 2, 3, 4] ",
            "      console.log(removeDublicates(arr3)); // ['a', 'b', 'c'] ",
            " ",
            "2. Используем метод Array.splice(). ",
            "Метод splice() позволяет нам удалить какое-то количество элементов из нашего массива и вставить, если необходимо, какое-то другое количество элементов.",
            "      const arr1 = [1, 1, 2]; ",
            "      const arr2 = [0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4]; ",
            "      const arr3 = ['a', 'a', 'b', 'b', 'c', 'c', 'c']; ",
            " ",
            "      function removeDublicates<T>(arr: Array<T>) { ",
            "            // Текущий элемент равен предыдущему? Если равен, то удаляем текущий элемент.",
            "            for (let i = 0; i < arr.length; i++) {",
            "                  if (arr[i] === arr[i - 1]) {",
            "                        arr.splice(i, 1);",
            "                        i--; // без этой операции работаетне корректно",
            "                  }",
            "            }",
            "            return arr;",
            "      } ",
            "      console.log(removeDublicates(arr1)); // [1, 2] ",
            "      console.log(removeDublicates(arr2)); // [0, 1, 2, 3, 4] ",
            "      console.log(removeDublicates(arr3)); // ['a', 'b', 'c'] ",
        ]
    },
    {
        heading: "Объединение интервалов, смерживание подмассивов.",
        href: "https://www.youtube.com/watch?v=2Od3MV1-mpk&list=PL0k-9Y7O1GwccXKHRzmvVj17yB7T9pjTo&index=1",
        taskCode: [
            "      let input1 = [[1, 3], [2, 6], [8, 10], [15, 18]]; ",
            "      let input2 = [[1, 4], [4, 5]]; ",
            "      let input3 = [[11, 12], [2, 3], [5, 7], [1, 4], [8, 10], [6, 8]]; ",
            " ",
            "      function merge(intervals: number[][]) { ",
            "            if (intervals.length < 2) {",
            "                  return intervals;",
            "            }",
            "            // Сортировка подмассивов по нулевым индексам",
            "            intervals.sort((a, b) => a[0] - b[0]);",
            "",
            "            let result = [intervals[0]];",
            "            for (let interval of intervals) {",
            "                  // Последний элемент из result.",
            "                  let recent = result[result.length - 1]; ",
            "                  // Если предыдущий интервал закончился позже либо ",
            "                  // тогда же, когда начался текущий интервал.",
            "                  if (recent[1] >= interval[0]) {",
            "                        // Выбираем максимальное значение последнего числа[1] из последнего ",
            "                        // и текущего интервалов и записываем его в recent[1].",
            "                        recent[1] = Math.max(recent[1], interval[1]);",
            "                  } else {",
            "                        result.push(interval);",
            "                  }",
            "            }",
            "            return result;",
            "      } ",
            " ",
            "      console.log(merge(input1)); //  [[1, 6], [8, 10], [15, 18]] ",
            "      console.log(merge(input2)); //  [[1, 5]] ",
            "      console.log(merge(input3)); //  [[1, 4], [5, 10], [11, 12]] ",
        ]
    },
    {
        heading: "Лучшее время для покупки акций #1 | Задачи с LeetCode",
        href: "https://www.youtube.com/watch?v=wm8hhQyIR9o&list=PL0k-9Y7O1GwccXKHRzmvVj17yB7T9pjTo&index=6",
        taskCode: [
            "На входе массив с числами - это цена какой-то конкретной акции по дням. Наша задача: максимилизировать нашу прибыль, сделав покупку в какой-то из этих дней и, в последствии, сделать продажу этих акций. Нам необходимо написать функцию, которая в качестве аргумента принимает массив с числами - котировками наших акций. В результате мы должны вернуть одно число - это максимальная прибыль, которую мы с вами можем заработать при таких входных данных. Если мы не можем заработать ни какой прибыли, то мы должны вернуть в этом случае ноль.  ",
            "Покупаем за 1 во второй день, продаём за 6 в пятый день. Макс прибыль: 6 - 1 = 5 у.е. ",
            "      let arr1 = [7, 1, 5, 3, 6, 4];",
            "В нижнем случае мы не можем сделать никакой выгодной операции. Возвращаем ноль. ",
            "      let arr2 = [7, 6, 4, 3, 1];",
            " ",
            "      function getMaxProfit(prices: number[]) { ",
            "            let minPrice = prices[0];",
            "            let maxProfit = 0;",
            "            for (let i = 0; i < prices.length; i++) {",
            "                  const current = prices[i];",
            "                  if (current < minPrice) {",
            "                        minPrice = current;",
            "                  }",
            "                  if (current - minPrice > maxProfit) {",
            "                        maxProfit = current - minPrice;",
            "                  }",
            "            }",
            "            return maxProfit;",
            "      } ",
            " ",
            "      console.log(getMaxProfit(arr1)); // 5 ",
            "      console.log(getMaxProfit(arr2)); // 0 ",
        ]
    },
    {
        heading: "Лучшее время для покупки акций # 2",
        href: "https://www.youtube.com/watch?v=MznMhfjkoQ4&list=PL0k-9Y7O1GwccXKHRzmvVj17yB7T9pjTo&index=2",
        taskCode: [
            "На вход подаётся массив с числами. Числа эти - цена акций в определённый день, то есть в каждый день у нас есть определённая цена акции. Наша задача - максимилизировать наш профиль.  ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
            " ",
        ]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
];

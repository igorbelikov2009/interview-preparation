"use strict";
/* eslint-disable no-useless-escape */
/* eslint-disable no-template-curly-in-string */
exports.__esModule = true;
exports.arrayTasks = void 0;
exports.arrayTasks = [
    {
        heading: "Удалить пробелы из строки. Метод string.replace() с регулярным выражением внутри.",
        href: "https://www.youtube.com/watch?v=awtOmYDEMY8&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=4",
        taskCode: [
            "const [ str, setStr ] = useState(' ftu ft ggwr '); ",
            "const [ strNoSpace, setStrNoSpace ] = useState(''); ",
            "- ",
            "function noSpace(x: string) { ",
            "         return x.replace(/s/g, ''''); ",
            "} ",
            "useEffect(() => {",
            "         setStrNoSpace(noSpace(str)); ",
            "}, [ str ]); ",
            "- ",
            "   console.log(str); // ' ftu ft ggwr ' ",
            "   console.log(strNoSpace); // ftuftggwr ",
            "-*- ",
        ]
    },
    {
        heading: "Очистить строку от числовых символов. Метод string.replaceAll() с регулярным выражением внутри. ",
        href: "https://www.youtube.com/watch?v=oQ-0bm9-_yA&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=6",
        taskCode: [
            "const [ elem ] = useState( 'This looks5 grea8te' ); ",
            "const [ elemClear, setElemClear ] = useState( '' );",
            "- ",
            "function stringCleaner( s: string ) { ",
            "      return s.replaceAll( /d/g, '''' );",
            "} ",
            "useEffect(() => { ",
            "      setElemClear( stringCleaner( elem )); ",
            "}, [ elem ]); ",
            "- ",
            "   console.log( elem ); // 'This looks5 grea8te' ",
            "   console.log( elemClear ); // This looks greate ",
            "-*- ",
        ]
    },
    {
        heading: "Чётное или нечётное? ",
        href: "https://www.youtube.com/watch?v=KwU3wq5DT90&t=77s",
        taskCode: [
            "const number = 1263; ",
            "const number2 = 1264; ",
            "- ",
            "function even_or_odd(number: number) { ",
            "      return number % 2 === 0 ? 'чётное' : 'нечётное'; ",
            "}",
            "- ",
            "   console.log(even_or_odd(number)); // нечётное ",
            "   console.log(even_or_odd(number2)); // чётное ",
            "-*- ",
        ]
    },
    {
        heading: "Вывод пользователей, которые лайкнули публикацию. Используем switch. ",
        href: "https://www.youtube.com/watch?v=XoKmzVPoQ_0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=1&t=20s",
        taskCode: [
            "Дан массив пользователей, которые лайкнули публикацию. Необходимо вывести имена этих пользователей строкой. Используем конструкцию switch.",
            "const printPeopleLiked = (names: string[]) => { ",
            "  switch (names.length) { ",
            "     case 0:",
            "       return 'Нет лайков';",
            "     case 1:",
            "       return `${names[0]} поставил лайк`;",
            "     case 2:",
            "       return `${names[0]} и ${names[1]} поставили лайк`;",
            "     case 3:",
            "       return `${names[0]}, ${names[1]} и ${names[2]} поставили лайк`;",
            "     default:",
            "       return `${names[0]}, ${names[1]} и ещё ${names.length - 2} поставили лайк`;",
            "  } ",
            "}; ",
            "console.log(printPeopleLiked([])); // Нет лайков ",
            "console.log(printPeopleLiked(['Max'])); // Max поставил лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy'])); // Max и Asy поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb'])); // Max, Asy и Gleb поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika'])); // Max, Asy и ещё 2 поставили лайк ",
            "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika', 'Boris', 'Andrey'])); // Max, Asy и ещё 4 поставили лайк ",
        ]
    },
    {
        heading: "Нужно найти сумму всех чисел, кратных 3 или 5.",
        href: "https://www.youtube.com/watch?v=WCIpXcwvXpw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=2",
        taskCode: [
            "Нужно найти сумму всех чисел, кратных 3 или 5, меньше переданного числа. Например, переданное число 16. Находим все числа, кратные 3 или 5, суммируем их и получаем результат.  ",
            "",
            "16 => 3 + 5 + 6 + 9 + 10 + 12 + 15 => 60. ",
            "- ",
            "const sum35 = ( n: number ) => { ",
            "    let sum = 0; ",
            "    for ( let i = 3; i < n; i++ ) { ",
            "        if ( i % 3 === 0 || i % 5 === 0 ) { ",
            "          sum += i; ",
            "        } ",
            "    } ",
            "    return sum;",
            "}; ",
            "- ",
            "console.log( sum35( 16 )); // 60 ",
            "console.log( sum35( 25 )); // 143 ",
            "-*- ",
        ]
    },
    {
        heading: "Разность массивов. Исключить из массива группу элементов другого массива. ",
        href: "https://www.youtube.com/watch?v=qSCy7RaJ6bg&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=3",
        taskCode: [
            "Как исключить из массива группу элементов из другого массива, например: ",
            "arrayDiff = ( [ 1, 2, 8, 2, 7, 3 ], [ 7, 2 ] ) => [ 1, 8, 3 ] ",
            "const arrayDiff = (source: number[], diff: number[]) => { ",
            "    // Метод filter отсечёт ненужные элементы по условию. Оставим в ",
            "    // результате только такие элементы, которые не входят в массив diff. ",
            "    return source.filter((item) => !diff.includes(item)); ",
            " }; ",
            "- ",
            "useEffect(() => { ",
            "    console.log(arrayDiff([2, 3, 4, 5, 6, 7, 8], [7, 2])); // (5) [3, 4, 5, 6, 8]",
            "  }, []); ",
            "-*- ",
        ]
    },
    {
        heading: "Как отформатировать строку и превратить её в телефонный номер. ",
        href: "https://www.youtube.com/watch?v=JbaVl29kVbI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=4",
        taskCode: [
            "Дана строка '1234567890'. Нужно первые три символа обернуть в скобки, потом пробел, потом три символа, дефис и ещё четыре символа: (123) 456-7890.",
            "Для подобных задач пригодятся регулярные выражения, а точнее, скобочные выражения для нахождения подстрок и метод replace().  ",
            "    // Первым аргументом в методе: поиск совпадений в строке. В нашем случае нужно запомнить первые три числовые символа (/d{3}).  (Здесь должен быть обратный слэш.) ",
            "    // Подобным образом запомним следующие 3 числа (/d{3}) и 4 после (/d{4}). (Здесь должен быть обратный слэш.) ",
            "    // Для замены текста используем обозначение '($1) $2-$3': ($1 оборачиваем в скобки - пробел, $2 - дефис, $3)",
            "- ",
            "const createPhoneNumber = (str: string) => { ",
            "    return str.replace(/(/d{3})(/d{3})(/d{4})/, '($1) $2-$3'); // (Здесь должен быть обратный слэш.)  ",
            "}; ",
            "- ",
            "useEffect(() => { ",
            "    console.log(createPhoneNumber('1234567890')); // (123) 456-7890 ",
            "}, []); ",
            "-*-",
        ]
    },
    {
        heading: "Перевести буквы в числа по их позиции в алфавите. ",
        href: "https://www.youtube.com/watch?v=_HmpuK3ori0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=5",
        taskCode: [
            "Как перевести слово в группу чисел, где каждое число - позиция буквы в алфавите. Если слово 'Азбука', то нужно превратить его в '1 8 2 20 11 1' .",
            "Для начала стандартной операции для преобразования строки, приведём её к нижнему регистру (toLowerCase()), разделим посимвольно (split('')) и будем использовать метод map(), который будет трансформировать каждый элемент массива в коллбэк внутри с одним аргументом (char => charCodeAt()). Метод charCodeAt() возвращает числовое значение юниткода для символа по указанному индексу.",
            "'Азбука'.charCodAt(0) // 1040. То есть заглавная русская буква А хранится в юникод под номером 1040. ",
            "'азбука'.charCodAt(0) // 1072. Маленькая русская буква 'а' хранится в юникод под номером 1072.",
            "  Значит, вычитая из результата число 1071, мы будем получать позицию каждой буквы в алфавите.",
            "console.log('азбука'.charCodeAt(0) - 1071); // 1 ",
            "console.log('азбука'.charCodeAt(1) - 1071); // 8 ",
            "console.log('азбука'.charCodeAt(2) - 1071); // 2 ",
            "console.log('азбука'.charCodeAt(3) - 1071); // 20 ",
            "console.log('азбука'.charCodeAt(4) - 1071); // 11 ",
            "console.log('азбука'.charCodeAt(5) - 1071); // 1 ",
            "-",
            "Наша общая функция будет выглядеть так: ",
            "const alphabetPosition = (str: string) => { ",
            "    return str ",
            "        .toLowerCase() ",
            "        .split('') // по пустому разделителю",
            "        .map((char) => char.charCodeAt(0) - 1071)",
            "        .join(' '); // по пробелу",
            "}; ",
            "console.log(alphabetPosition('Азбука')); // 1 8 2 20 11 1 ",
            "-*-",
        ]
    },
    {
        heading: "Схлопнуть соседние элементы. ",
        href: "https://www.youtube.com/watch?v=hnmmm9iOAUo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=6",
        taskCode: [
            "Напишите функцию, которая принимает последовательность (это может быть массив или строка) и возвращает массив, где повторяющиеся сосоедние элементы схлопнулись до одного. Исходный порядок элементов нужно сохранить. ",
            "Решим эту задачу через фильтр. Для этого развернём нашу последовательность на входе ( iterable ) => [ ...iterable ]. Мы получим массив, даже если заспредим строку. Затем отфильтруем элементы этого массива таким образом, чтобы в новый массив попали только те элементы, которые не равны элементу из последовательности по индексу и -1",
            "Наша функция будет выглядеть так:",
            "function uniqueInOrder(iterable: string | string[] | number[]) { ",
            "    return [...iterable].filter((el, index) => el !== iterable[index - 1]); ",
            "} ",
            "- ",
            "console.log(uniqueInOrder('AAAABBBCCDAABBB')); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
            "console.log(uniqueInOrder('ABBCcAD')); // ['A', 'B', 'C', 'c', 'A', 'D'] ",
            "console.log(uniqueInOrder(['A', 'A', 'A', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B'])); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
            "console.log(uniqueInOrder([1, 1, 2, 2, 2, 3, 3, 4, 4])); // [1, 2, 3, 4] ",
            "-*-",
        ]
    },
    {
        heading: "Написать функцию по выявлению пагнрамм.",
        href: "https://www.youtube.com/watch?v=wE3YcgtTZlo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=7",
        taskCode: [
            "Написать функцию по выявлению пагнрамм - фраз, содержащих в себе все буквы алфавита. ",
            "Вычислить панграмму в JS просто: нужно занести в Set- коллекцию нашу преобразованную строку. Как её преобразовать: сначала приводим все буквы к нижнему регистру, а затем, с помощью регулярного выражения оставим только буквы русского алфавита. Используем буквы от 'а' до 'я' начала строки и букву 'ё', потому, что она не включается стандартно и глобально. Всё это заменяем на пустую строку replace(/[^а-яё]/g, '')",
            "Set- коллекция исключит из массива повторяющиеся элементы, оставит только уникальные, и у это коллекции есть метод size. Если size === 33 (количество букв в алфавите), то значит это фраза - паграмма   ",
            "- ",
            "const isPangram = (str: string) => { ",
            "    const set = new Set([...str.toLowerCase().replace(/[^а-яё/]/g, '')]); ",
            "    return set.size === 33; ",
            "}; ",
            "Эта фраза не является панграммой: ",
            "    console.log(isPangram('Мама мыла раму')); // false ",
            "Эта фраза - панграмма:",
            "    console.log(isPangram('Съешь ещё этих мягких французских булочек, да выпей же чаю')); // true ",
            "-*- ",
        ]
    },
    {
        heading: "Нарисуй ёлку из символов, например, из звёзд. ",
        href: "https://www.youtube.com/watch?v=DZ4oAPBmvDI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=8",
        taskCode: [
            "На вход поступает высота ёлки. Ёлка симметрична, поэтому нужно понять, сколько пробелов должно быть в ряду, с обоих сторон от звёзд. С самими звёздами всё ясно, их в ряду будет: 1, 3, 5, 7, 9. Для высоты = 5 будет 9 звёзд в нижнем ряду и 0 пробелов. Значит в первом ряду будет 4 пробела, 1 звезда и опять 4 пробела.",
            "const drawChristmasTree = (n: any) => { ",
            "    let tree = '\n'; ",
            "    for (let i = 0; i < n; i++) { ",
            "        const space = ' '.repeat(n - i - 1); ",
            "        tree += space + '*'.repeat(i + i + 1) + space + '\n'; ",
            "    } ",
            "    return tree; ",
            " }; ",
            "console.log(drawChristmasTree(5)); ",
            "    * ",
            "   *** ",
            "  ***** ",
            " ******* ",
            "********* ",
            "console.log(drawChristmasTree(6)); ",
            "     * ",
            "    *** ",
            "   ***** ",
            "  ******* ",
            " ********* ",
            "*********** ",
            "-*- ",
        ]
    },
    {
        heading: "Валидация строк со скобками. ",
        href: "https://www.youtube.com/watch?v=cNPsxKh4s5U&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=9",
        taskCode: [
            "-*- У меня это решение вызывает ошибку-*-",
            "Напиши валидацию строк с круглыми, квадратными и фигурными скобками. Считаем, что результат правильный, если все скобки открываются и закрываются в нужном порядке. ",
            "Например: ",
            "isValidBraces('(){}[]') // true ",
            "isValidBraces('({[]})') // true ",
            "isValidBraces('(}')     // false ",
            "isValidBraces('[(])')   // false ",
            "isValidBraces('[({}(]') // false ",
            "Стек - это структура данных, представляющие собой список элементов, организованных по принципу: последним зашёл - первым вышел.  ",
            "Мы будем идти по каждому символу в строке и класть в стек открывающиеся скобки. А если будем видеть закрывающую скобку, то будем проверять, соответсвует ли её тип с типом последней последней скобки в стеке. Если они не одного и того же типа, то можно сразу возвращать ложь, не дожидаясь завершения цикла. Если мы вышли из цикла без подобных остановок, то осталось проверить размер стека. Если он равен нулю, то это значит, что в нём не осталось открытых скобок. А значит входная строка валидна. Если хотя бы один элемент в стеке есть, то значит строка не валидна.   ",
            "const isValidBraces = (str: string) => { ",
            "    const braces = { '{': '}', '(': ')', '[': ']' }; ",
            "    const stack = []; ",
            "    for (let i = 0; i < str.length; i++) { ",
            "       const currentBrace = str[i] as keyof typeof braces;",
            "       if (braces[currentBrace]) { ",
            "           stack.push(currentBrace); ",
            "       } else if (currentBrace !== braces[stack.pop()]) { // ts(2538)",
            "       // Тип 'undefined' невозможно использовать как тип индекса.ts(2538)",
            "       // (method) Array<string>.pop(): string | undefined",
            "           return false; ",
            "       } ",
            "    } ",
            "    return stack.length === 0; ",
            "}; ",
            "-*- ",
            "У меня это решение вызывает ошибку. ",
        ]
    },
    {
        heading: "Пересечения массивов",
        href: "https://www.youtube.com/watch?v=APuD-xNMBGc&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=10",
        taskCode: [
            "Нужно написать функцию, которая принимает два массива и возвращает массив с их пересечениями - элементы должны присутствовать и в первом, и во втором массиве. Причём, элемент должен повториться в массиве два и более раза. ",
            "Для начала выбираем только повторяющие числа, для этого создадим Set- коллекцию уникальных элементов, в которой будут лежат элементы, которые хотя бы раз встречались в массиве. А в объекте pick будем собирать числа, которые повторились два или более раз.    ",
            "Пройдём по перому массиву методом forEach(), проверим для каждого числа в массиве условие: если в Set- коллекции нет текущего числа (has()), то занесём его в коллекцию. Иначе, число уже встречалось в массиве, а значит оно повторяющееся. Положим повторяющееся число в объект pick, ключём станет станет само повторяющее число из первого массива, а значением 0 - количество будущих повторений во втором массиве. Получили объект, где ключи - повторяющиеся числа из первого массива, а значения - количество повторений уже во втором массиве. Осталось только преобразовать этот объект в массив, в котором будут лежать только ключи.       ",
            "Проверим, что всё получилось так, как надо. ",
            "Так же проходим по второму массиву, если число из второго массива является ключём в объекте pick, то увеличим его значение на 1.    ",
            "const intersectNubmers = (a: number[], b: number[]) => { ",
            "    const set = new Set(); ",
            "    const pick: any = {};",
            "    // ",
            "    a.forEach((n: number) => {",
            "      if (!set.has(n)) {",
            "        set.add(n); ",
            "      } else {",
            "        pick[n] = 0;",
            "      }",
            "    }); ",
            "    // return pick; // {1: 0, 17: 0, 56: 0} // результат проверки первого массива",
            "    // Проверяем второй массив",
            "    b.forEach((n: number) => {",
            "      if (n in pick) {",
            "        pick[n] = pick[n] + 1;",
            "      }",
            "    });",
            "    // return pick; // {1: 3, 17: 2, 56: 1} // результат проверки обоих массивов",
            "    // Преобразуем объект в массив, в котором будут лежать только ключи",
            "    return Object.entries(pick).reduce((result, [n, count]) => {",
            "      if ((count as number) > 1) {",
            "        result.push(+n);",
            "      }",
            "      return result;",
            "    });",
            "}; ",
            "console.log(intersectNubmers([7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1])); ",
            "-*-",
        ]
    },
    {
        heading: "Представление числа в расширенной нотации.",
        href: "https://www.youtube.com/watch?v=ukx4y4HjhtI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=11",
        taskCode: [
            "Вернуть заданное число в виде строки в расширенной форме. Все числа будут целыми числами больше нуля. ",
            "Что такое расширенная анотация - это когда число представляется в виде суммы каждой цифры, умноженное на соответствующее значение её разряда. Например:   ",
            "expandedForm(12); // => '10 + 2' ",
            "expandedForm(42); // => '40 + 2' ",
            "expandedForm(70304); // => '70000 + 300 + 4' ",
            "--",
            "Наша функция: ",
            "const expandedForm =  ( num: number ) => {   // на входе num = 70304",
            "    return ( ",
            "        String( num ) // Переводим число в строку '70304' ",
            "            .split( '' ) // Разбиваем эту строку посимвольно [ '7', '0', '3', '0', '4' ] ",
            "            // К каждому символу прибавляем определённое количество нулей: ",
            "            .map(( n, i, arr ) => n + '0'.repeat( arr.length - i - 1 )) // [ '70000', '0000', '300', '00', '4' ] ",
            "            // Отфильтруем, оставим всё, что не равно нулю ",
            "            .filter(( n ) => Number( n ) !== 0 ) // [ '70000', '300', '4' ] ",
            "            // Объеденим элементы массива в строку, поставив между ними знак '+'",
            "            .join(' + ') // 70000 + 300 + 4",
            "     ); ",
            "}; ",
            "console.log(expandedForm(12)); // 10 + 2 ",
            "console.log(expandedForm(42)); // 40 + 2 ",
            "console.log(expandedForm(70304)); // 70000 + 300 + 4 ",
            "-*- ",
        ]
    },
    {
        heading: "Получить из массива строк те, которые являются подстроками второго массива  ",
        href: "https://www.youtube.com/watch?v=F2eYgsFuuJ0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=12",
        taskCode: [
            "Даны два массива строк a и b. Возвратить массив, в котором элементы из массива a являются подстроками строк b.",
            "const inArray = ( a: string[], b: string[] ) => { ",
            "    // Отфильтруем массив a по условию: в массиве b есть хотя бы одна срока (метод b.some( str )), ",
            "    // которая содержит в себе такую подстроку ( метод str.includes( sub ) ):",
            "    return a.filter(( sub ) => b.some(( str ) => str.includes( sub )));",
            "}; ",
            "console.log(inArray([ 'ля', 'ты', 'редис' ], [ 'коты', 'цапля', 'крысолов' ])); // [ 'ля', 'ты' ]",
            "-*-",
        ]
    },
    {
        heading: "Разбить прямоугольник на группу квадратов.",
        href: "https://www.youtube.com/watch?v=rJw30E-9kC4&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=13",
        taskCode: [
            "Нужно представить прямоугольник в виде группы квадратов. Есть прямоугольник размерами 3 * 5, мы его делим на квадраты: 3 * 3, 2 * 2, 1 * 1, 1 * 1. ",
            "Алгоритм:  ",
            "1. Нужно выбрать в нашем прямоугольнике меньшую сторону, в нашем случае - это сторона 3. Вырезаем из нашего прямоугольника квадрат 3 * 3. В остатке у нас прямоугольник 2 * 3.",
            "2. Производим точно такие операции с остаточным прямоугольником 2 * 3. Меньшая сторона равна 2, вырезаем квадарт 2 * 2. В остатке у нас прямоугольник 1 * 2.",
            "3. Продолжаем в том же духе.",
            "-*-",
            "Напишем функцию, у нас есть сторона a и сторона b. ",
            "const sqInRect = ( a: number, b: number ): number[] => {",
            "    // База рекурсии: если сторона a строго равна стороне b, то возвращаем массив из стороны a. ",
            "    if ( a === b ) return [ a ]; ",
            "    //",
            "    // Иначе, заводим константу, в которой лежат большая и меньшая стороны,",
            "    // и проверим какая сторона больше. Меньшую сторону заносим в min, большую - в max.",
            "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
            "    //",
            "    // Мы определились, какая сторона наименьшая, а какая наибольшая и остаётся одна операция с рекурсией.",
            "    // Возвратим массив, в котором будет лежать наша минимальная сторона,",
            "    // воспользуемся спред- оператором, потому, что мы каждый раз будем возвращать массив.",
            "    // Используем функцию sqInRect(), внутри которой у нас разность сторон",
            "    // и минимальная сторона - размеры остаточного прямоугольника.",
            "    return [ min, ...sqInRect( max - min, min )];",
            "}; ",
            "-*-",
            "Функция в чистом виде: ",
            "const sqInRect = ( a: number, b: number ): number[] => { ",
            "    if ( a === b ) return [ a ]; ",
            "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
            "    return [ min, ...sqInRect( max - min, min )];",
            "}; ",
            "console.log(sqInRect(5, 3));    // [ 3, 2, 1, 1 ] ",
            "console.log(sqInRect(3, 5));    // [ 3, 2, 1, 1 ] ",
            "console.log(sqInRect(7, 5));    // [ 5, 2, 2, 1, 1 ] ",
            "console.log(sqInRect(20, 14));  // [ 14, 6, 6, 2, 2, 2 ] ",
            "-*-",
        ]
    },
    {
        heading: "Валидация IP-адреса ",
        href: "https://www.youtube.com/watch?v=_d3Q2xStf8E&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=14",
        taskCode: [
            "Нужно свалидировать IP-адрес. Адрес следует считать действительным, если он состоит из четырёх групп чисел со значением от 0 до 255 включительно. ",
            "Примеры допустимых входных данных: ",
            "// 1.2.3.4 ",
            "// 123.45.67.89 ",
            "Недопустимые примеры ввода: ",
            "// 1.2.3 ",
            "// 1.2.3.4.5",
            "// 123.456.78.90 ",
            "// 123.045.067.089 ",
            "-*-",
            "const isValid = (str: string) => { ",
            "    // На входе строка '12.255.56.1'. Для начала выделяем группы чисел, разделяем ",
            "    // строчку посимвольно методом split() с разделитетелем точка '.'",
            "    const numbers = str.split('.'); // ['12', '255', '56', '1']",
            "    //",
            "    // Сраниваем получившиеся количество групп с заданным числом: numbers.length === 4",
            "    // В filter((n) => +n) приводим строку к числу (+n) и проверяем это число",
            "    // на соответствие интервалу от 0 до 255",
            "    // String(+n).length <= таким образом мы обрабатываем такой IP: 'n1.2.3.4'",
            "    //",
            "    return (",
            "        numbers.length === 4 ",
            "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
            "            && n.length === String(+n).length).length === 4",
            "    );",
            "}; ",
            "-*- ",
            "Пишем нашу функцию в чистом виде: ",
            "const isValid = ( str: string ) => { ",
            "    const numbers = str.split('.');",
            "    return (",
            "        numbers.length === 4 ",
            "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
            "            && n.length === String(+n).length).length === 4",
            "    );",
            "}; ",
            "-*-",
            "console.log(isValid( '0.0.0.0' ));         // [ '0', '0', '0', '0' ]        // true ",
            "console.log(isValid( '12.255.56.1' ));     // [ '12', '255', '56', '1' ]    // true ",
            "console.log(isValid( '137.255.1.100' ));   // [ '137', '255', '1', '100' ]  // true ",
            "console.log(isValid( '123.456.789.0' ));   // [ '123', '0' ]                // false ",
            "console.log(isValid( 'abc.def.ghi.jkl' )); // []                            // false ",
            "console.log(isValid( 'n1.2.3.4' ));        // [ '2', '3', '4' ]             // false ",
            "console.log(isValid( '' ));                // false                         // false ",
            "-*-",
        ]
    },
    {
        heading: "Сколько ещё в очереди стоять? ",
        href: "https://www.youtube.com/watch?v=YLc1G12T_jY&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=15",
        taskCode: [
            "В супермаркете очередь к кассам самообслуживания. Нужно написать функцию для расчёта общего времени, необходимого всем покупателям для оформления заказов. Несколько уточнений:",
            "    - существует только ОДНА очередь, обслуживающая множество касс;",
            "    - порядок очереди НИКОГДА не меняется и первый человек в очереди (то есть первый элемент в массиве) проходит к кассе, как только она освобождается. ",
            "Аргументы функции: ",
            "    'customers'- клиенты: массив положительных целых чисел - людей, представляющих очередь. Каждое целое число (каждый элемент массива) представляет покупателя, а его значение - количество времени, которое ему требуется для оформления заказа.",
            "    'n' - количество касс: положительное целое число. ",
            " Выход: функция должна возвращать целое число - общее требуемое время. ",
            "Примеры:  ",
            "const queueTime = (customers, n) => {} // наша функция",
            "1. queueTime([ 2, 3, 4 ], 1)  // => 9",
            "    // Когда есть только одна касса, то общее время - это сумма времени,  ",
            "    //  потраченного на каждого покупателя.",
            "2. queueTime([ 2, 3, 8 ], 2)  // => 10",
            "    // Первый и второй покупатели идут по разным кассам,",
            "    // третий ждёт и подходит к первой освободившейся.",
            "3. queueTime([ 11, 2, 3, 3 ], 2)  // => 11",
            "    // Две кассы. Пока первый покупатель стоит на свой кассе 11 едениц времени,",
            "    // за это время 2-й, 3-й и 4-й покупатели уже расплатились.",
            "-*-",
            "Создадим нашу функцию:",
            "const queueTime = (customers: number[], n: number) => { ",
            "    // Если количество покупателей равно количеству касс.",
            "    if (customers.length === 0) return 0;",
            "    .",
            "    // Если количество покупателей меньше количества касс.",
            "    if (customers.length <= n) return Math.max(...customers);",
            "    .",
            "    // Если количество покупателей больше количества касс, например ([ 2, 3, 8 ], 2 ).",
            "    // Введём новую переменную queues (массив очередей - количество сумм времени",
            "    // в этих очередях), в нём будет n - элементов (количество касс), значение",
            "    // которых определим равными нулю fill( 0 ). То есть, мы создали очереди к кассам:",
            "    // к первой кассе стоит первый клиент, ко второй - второй клиент. Если какая-то",
            "    // касса освобождается, то к ней подходит очередной клиент.",
            "    // 1-й элемент массива будет принимать время первого человека,",
            "    // второй - время второго человека. Изначальное время для всех задали равное нулю.",
            "    .",
            "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
            "    .",
            "    // Пройдём по массиву покупателей",
            "    for ( const time of customers ) {",
            "        // Будем находить индекс у массива очередей. Мы берём самое меньшее число в очередях,",
            "        // и находим его индекс. Так мы получаем самую свободную на данный момент кассу",
            "        // - индекс кассы. ",
            "        const index = queues.indexOf( Math.min( ...queues ));",
            "        //",
            "        // У нас есть список очередей, есть индекс, и мы прибавляем к тому что есть там",
            "        // определённое время - значение элемента массива покупателей customers.",
            "        // Фактически, мы заполняем наш массив очередей.",
            "        queues[index] += time; // Array [ (2 + 8), 3 ] =  [ 10, 3 ]",
            "    } ",
            "    // Нам в конце остаётся только возвратить самое большое число из массива очередей. ",
            "    return Math.max(...queues); // 10",
            "}; ",
            "-*-",
            "Пишем нашу функцию в чистом виде: ",
            "const queueTime = ( customers: number[], n: number ) => {  ",
            "    if ( customers.length === 0 ) return 0; ",
            "    if ( customers.length <= n ) return Math.max( ...customers ); ",
            ". ",
            "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
            "    for (const time of customers) {",
            "        const index = queues.indexOf(Math.min( ...queues ));",
            "        queues[ index ] += time;",
            "    } ",
            "    return Math.max( ...queues ); ",
            "};",
            "-*-",
            "console.log(queueTime([ 2, 3, 4 ], 1 )); // 9 ",
            "console.log(queueTime([ 2, 3, 8 ], 2 )); // 10 ",
            "console.log(queueTime([ 11, 2, 3, 3 ], 2 )); // 11 ",
            "-*-",
        ]
    },
    {
        heading: "Нарисовать таблицу умножения ",
        href: "https://www.youtube.com/watch?v=Hnlf8W04vfk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=16",
        taskCode: [
            "Надо написать функцию, которая возвращает таблицу умножения размерами N * N. Даётся сам размер, например тройка, и мы должны вывести массив, в котором лежат другие массивы, обозначающие строки в нашей результирующей таблице умножения. Стандартный вид таблицы умножения - это когда первые строки по вертикали и по горизонтали содержат цифры от единицы до самого числа size, а внутри перемножение этих чисел.         ",
            "Напимер: ",
            "const multiplicationTable = (size: number) => {}  ",
            "multiplicationTable(3) // => [[1, 2, 3], [2, 4, 6], [3, 6, 9]] ",
            "//  [1, 2, 3] ",
            "//  [2, 4, 6] ",
            "//  [3, 6, 9] ",
            "Пишем функцию: ",
            "const multiplicationTable = (size: number) => { ",
            "    const table: number[][] = []; ",
            "    .",
            "    for (let i = 0; i < size; i++) {",
            "        table[i] = [];",
            "        for (let j = 0; j < size; j++) {",
            "            table[i][j] = (i + 1) * (j + 1);",
            "        } ",
            "    }",
            "    . ",
            "    return table;",
            "}; ",
            "-*-",
            "console.log(multiplicationTable(3)); // [Array(3), Array(3), Array(3)] ",
            "    //  [1, 2, 3] ",
            "    //  [2, 4, 6]",
            "    //  [3, 6, 9] ",
            "console.log(multiplicationTable(10)); ",
            "    // [Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10)] ",
            "    // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
            "    // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]",
            "    // [3, 6, 9, 12, 15, 18, 21, 24, 27, 30] ",
            "    // [4, 8, 12, 16, 20, 24, 28, 32, 36, 40] ",
            "    // [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] ",
            "    // [6, 12, 18, 24, 30, 36, 42, 48, 54, 60] ",
            "    // [7, 14, 21, 28, 35, 42, 49, 56, 63, 70] ",
            "    // [8, 16, 24, 32, 40, 48, 56, 64, 72, 80] ",
            "    // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] ",
            "    // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] ",
            "-*-",
        ]
    },
    {
        heading: "Пропущенное число в прогрессии. Выводим формулу разности прогрессии?",
        href: "https://www.youtube.com/watch?v=c1GnHM2cHjo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=17",
        taskCode: [
            "Задача от FaceBook. Дан массив последовательных элементов арифметической прогрессии, в котором отсутствует ровно одно число. Нужно написать функцию, которая возвратит отсутствующий элемент (он никогда не будет ни первым, ни последним, а массив будет состоять из трёх или более чисел). ",
            "Арифметическая прогрессия - последовательность чисел, в которой каждый следующий элемент можно найти, прибавив к предыдущему число d (delta - разность прогрессии) ",
            "const findMissing = (list) => {} ",
            "findMissing([1, 3, 5, 9, 11]) // => 7",
            "Разность прогрессии d вычисляется по формуле: d = (An - A1) / (n - 1) // это из математики.",
            "-*-",
            "const findMissing = (list: number[]) => { ",
            "    // Сначала найдём то самое n. У нас в заданной прогрессии пропущен один элемент, ",
            "    // этот пропущенный элемент мы и прибавляем к длине данного массива. ",
            "    const n = list.length + 1; ",
            "    .",
            "    // Напишем формулу для вычисления разности прогрессии",
            "    // list[list.length] - это последний элемент в арифметической прогрессии.",
            "    // list[list.length - 1] это последний элемент в заданном массиве, где пропущен один элемент. ",
            "    // Для сокращения памяти выражение (n - 1) заменим на list.length, так это однозначно.",
            "    .",
            "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
            "    // const d = (list[list.length - 1] - list[0]) / list.length;",
            "    .",
            "    for (let i = 0; i < list.length; i++) {",
            "        // предположительное следующее число",
            "        .",
            "        const estimatedNextNumbers = list[i] + d;",
            "        // Сравним предположительное следующее число со следующим элементом, который уже лежит в массиве.",
            "        if (estimatedNextNumbers !== list[i + 1]) {",
            "            return estimatedNextNumbers;",
            "        } ",
            "    } ",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const findMissing = (list: number[]) => { ",
            "    const n = list.length + 1; ",
            "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
            "    .",
            "    for (let i = 0; i < list.length; i++) {",
            "        const estimatedNextNumbers = list[i] + d;",
            "        .",
            "        if (estimatedNextNumbers !== list[i + 1]) { ",
            "            return estimatedNextNumbers;",
            "        } ",
            "    } ",
            "}; ",
            "-*-",
            "console.log(findMissing([1, 3, 5, 9, 11]));            //   7 ",
            "console.log(findMissing([1, 3, 5, 7, 9, 13]));         // 11 ",
            "console.log(findMissing([1, 4, 7, 10, 16, 19]));     // 13 ",
            "-*-",
        ]
    },
    {
        heading: "Решётка заменила Backspace",
        href: "https://www.youtube.com/watch?v=dT7hc6lqyn0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=18",
        taskCode: [
            "Напишите логику, подобную клавише 'Backspace'. Функция будет принимать строку вида 'a#bc#d' и возвращать 'bd'. То есть каждый символ '#' будет как бы стирать последний элемент в строке. ",
            "Напишем нашу функцию: ",
            "const cleanString = (s: string) => {",
            "    // Разбиваем нашу строку посимвольно. После этого воспользуемся функцией высшего порядка ",
            "    // reduce(result, symbol), где result - аккумулятор, а symbol - наш текущий символ строки.",
            "    // Начальное значение result - пустая строка '', мы её будем возвращать в итоге.",
            "    // Если наш символ равен symbol === '#', то мы от result будем срезать последний элемент: ",
            "    // result.slice(0, -1). Иначе к result будем прибавлять очередной символ: result + symbol.",
            "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const cleanString = (s: string) => { ",
            "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
            "}; ",
            "-*-",
            "console.log(cleanString('a#bc#d')); // bd ",
            "console.log(cleanString('abc#d##c')); // ac ",
            "console.log(cleanString('abc##d#####')); // '' ",
            "console.log(cleanString('#####')); // '' ",
            "console.log(cleanString('')); // '' ",
            "-*- ",
        ]
    },
    {
        heading: "Свернуть массив N раз.",
        href: "https://www.youtube.com/watch?v=0XwAo_P49V8&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=19",
        taskCode: [
            "Нужно свернуть массив целых чисел N раз.  ",
            "const foldArray = ( array: number[], runs: number ): number[] => { ",
            "    if ( runs === 0 ) return array; // Это база рекурсии ",
            "    . ",
            "    const result: number[] = []; // Это будет результирующий массив ",
            "    .",
            "    // Мы будем идти от нулевого индекса до середины массива,",
            "    // если середина не целое число, то ничего страшного.",
            "    for ( let i = 0; i < array.length / 2; i++ ) {",
            "        // Создадим переменную зеркальный индекс:",
            "        const mirrorIndex = array.length - i - 1;            // Почему  arr.length - i - 1 ?",
            "        .",
            "        // Зеркальный индекс - индекс элемента, который находится симметрично относительно",
            "        // центра массива. Например, если массив имеет элементы [ 1, 2, 3, 4, 5 ], то зеркальным",
            "        // для элемента 1 будет элемент 5, для элемента 2 - элемент 4.",
            "       .",
            "        // Формула arr.length - i - 1 основана на том факте, что зеркальный индекс элемента",
            "        // находится на расстоянии, равном разности текущего индекса и позиции центрального",
            "        // элемента.",
            "       .",
            "        // Для определения зеркального индекса элемента с индексом i необходимо вычислить",
            "        // разность между позицией центрального элемента и текущим индексом i, а затем",
            "        // вычесть единицу.",
            "        .",
            "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
            "    }",
            "    return foldArray( result, runs - 1 );",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const foldArray = ( array: number[], runs: number ): number[] => { ",
            "    if ( runs === 0 ) return array; ",
            "    .",
            "    const result: number[] = [];",
            "    for ( let i = 0; i < array.length / 2; i++ ) {",
            "        const mirrorIndex = array.length - i - 1;",
            "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
            "    }",
            "    return foldArray( result, runs - 1 );",
            "}; ",
            "-*-",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 1 ));             // [ 6, 6, 3 ] ",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 2 ));             // [ 9, 6 ] ",
            "console.log(foldArray([ 1, 2, 3, 4, 5 ], 3 ));             // [ 15 ] ",
            "console.log(foldArray([ -9, 9, -8, 8, 66, 23 ], 1 ));  // [ 14, 75, 0 ] ",
            "-*-",
        ]
    },
    {
        heading: "Вывести большее из самых повторяющихся чисел в массиве.",
        href: "https://www.youtube.com/watch?v=sB4CA7tyRJI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=20",
        taskCode: [
            "Напишите функцию, которая возвращает самое встречающееся число в заданном массиве. При ничьей, между двух и более чисел, вернуть наибольшее число среди них.",
            "К примеру: ",
            "const hignestRank = (arr: number[]) => {}; // наша будущая функция ",
            ". ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));           // --> 12 ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8])); // --> 12 ",
            "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));      // --> 3",
            "-*-",
            "Напишем нашу функцию: ",
            "const hignestRank = (arr: number[]) => { ",
            "    // Введём переменную для объекта, где будут лежать ключи - числа массива, ",
            "    // а их значение - количество их повторений.",
            "    const map: any = {};",
            "    .",
            "    // Введём переменную в которой мы будем считать максимальное количество повторений",
            "    // любых чисел. Грубо говоря это будет счётчик максимального количества повторений",
            "    // в нашем массиве. ",
            "    let maxRepeat = 0;",
            "    .",
            "    // Пройдёмся по массиву: какое число нужно присвоить map[n]? Либо 1, если map[n] не",
            "    // существует, либо map[n] + 1, как раз для подсчёта повторений.",
            "    arr.forEach((n) => {",
            "        // Оператор ~~ используется для округления числа с плавающей запятой в меньшую сторону:",
            "        // но самое главное: оператор ~~ приводит undefined к нулю. Что нам в принципе и нужно:",
            "        // для map[n], которого ещё нет, мы скажем ноль плюс 1. Фактически, в для map[n] будут",
            "        // всегда лежать корректные данные.",
            "        map[n] = ~~map[n] + 1;",
            "        .",
            "        if (map[n] > maxRepeat) { ",
            "            // если условие выполняется, то максимальное повторение map[n] заносим в maxRepeat",
            "            maxRepeat = map[n];",
            "        }",
            "    });",
            "    .",
            "    return Object.entries(map).reduce(",
            "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
            "        -Infinity",
            "    );",
            "}; ",
            "-*-",
            "Перепишем нашу функцию в чистом виде: ",
            "const hignestRank = (arr: number[]) => { ",
            "    const map: any = {}; ",
            "    let maxRepeat = 0;",
            "    .",
            "    arr.forEach((n) => { ",
            "        map[n] = ~~map[n] + 1;",
            "        .",
            "        if (map[n] > maxRepeat) {",
            "            maxRepeat = map[n];",
            "        }",
            "    });",
            "    .",
            "    return Object.entries(map).reduce(",
            "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
            "        -Infinity ",
            "    ); ",
            "}; ",
            "-*-",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));             // 12 ",
            "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8]));   // 12 ",
            "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));        // 3 ",
            "-*-",
        ]
    },
    {
        heading: "Сложение матриц",
        href: "https://www.youtube.com/watch?v=e9MvJCkhBjk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=21",
        taskCode: [
            "Нужно написать функцию, которая принимает две матрицы (массивы массивов) и возвращает их сумму.",
            "const matrixAddition = (a: number[ ][ ], b: number[ ][ ]) => { ",
            "    return a.map(( row, i ) => row.map(( _, j ) => a[ i ][ j ] + b[ i ][ j ])); ",
            "}; ",
            "-*-",
            "console.log( ",
            "    matrixAddition( ",
            "        [",
            "            [ 1, 2, 3 ], ",
            "            [ 3, 2, 1 ],",
            "            [ 1, 1, 1 ],",
            "        ],                        // [ 3, 4, 4 ]",
            "        //    +                 // [ 6, 4, 4 ]",
            "        [                         // [ 2, 2, 4 ]",
            "            [ 2, 2, 1 ],",
            "            [ 3, 2, 3 ],",
            "            [ 1, 1, 3 ],",
            "        ]",
            "    ) ",
            "); ",
            "-*-",
        ]
    },
    {
        heading: "Количество нажатий для ввода текста на старом телефоне.",
        href: "https://www.youtube.com/watch?v=KxUiRrzVH6o&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=22",
        taskCode: [
            "Сколько раз нужно нажать на кнопки на старых телефонах без Т9, чтобы набрать заданный текст? ",
            "-*-",
            "const presses = (str: string): number => { ",
            "    // Создадим переменную, в которой будут лежать наши числа и буквы, они будут ключами,",
            "    // а значением выступит количество их повторений - сколько раз нужно нажать на кнопку. ",
            "    // На старом телефоне, чтобы вывести букву С, нужно три раза нажать на кнопку (2abc).",
            "    const numbers: any = {",
            "        // По сути это клавиатура старого телефона",
            "        '1': 1,",
            "         a: 1, ",
            "         b: 2,",
            "         c: 3,",
            "        '2': 4,",
            "         d: 1,",
            "         e: 2,",
            "         f: 3,",
            "        '3': 4,",
            "         g: 1,",
            "         h: 2,",
            "         i: 3,",
            "        '4': 4,",
            "         j: 1,",
            "         k: 2,",
            "         l: 3,",
            "        '5': 4,",
            "         m: 1, ",
            "         n: 2,",
            "         o: 3,",
            "        '6': 4,",
            "         p: 1,",
            "         q: 2, ",
            "         r: 3,",
            "         s: 4,",
            "        '7': 5, ",
            "         t: 1, ",
            "         u: 2,",
            "         v: 3, ",
            "        '8': 4,",
            "         w: 1, ",
            "         x: 2,",
            "         y: 3,",
            "         z: 4, ",
            "        '9': 5,",
            "        ' ': 1,",
            "        '0': 2,",
            "    }; ",
            "    return str.split('').reduce((sum: number, char: string) => sum + numbers[char.toLowerCase()], 0);",
            "}; ",
            "-*-",
            "console.log(presses('LOL')); // 9 ",
            "console.log(presses('WHERE DO U WANT 2 MEET L8R')); // 47 ",
            "console.log(presses('')); // 0 ",
            "-*-",
        ]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
    {
        heading: " ",
        href: "",
        taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]
    },
];

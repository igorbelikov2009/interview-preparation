"use strict";
exports.__esModule = true;
exports.arrayTypescript = void 0;
exports.arrayTypescript = [
    {
        heading: "Что такое TypeScript?",
        answer: [
            "TypeScript - это средство проверки статического типа для JavaScript. Средство проверки статического типа добавляет в JavaScript синтаксис, позволяющий указать тип данных переменной. Он может следить за этой переменной через код, чтобы убедиться, что она используется правильно. ",
            " ",
            "По сути это расширение для JavaScript, предназначенное для выявления ошибок на этапе компиляции. ",
            "Программа на TypeScript компилируется в простой код JavaScript, который выполняется в любом браузере. TypeScript помогает писать более читаемый код, обеспечивает масштабируемость и безопасность приложений, дает разработчикам статическую типизацию и приведение типов.",
            "Главная задача тайпскрипта, это внести типы в нетипизированный язык javascript. Благодаря типам, мы сможем быстро рефакторить проекты, поддерживать огромные проекты, а так же писать более качественный код, который будет основан уже на поведении типов.",
            "-*-",
            "TypeScript - это строго типизированный, объектно-ориентированный, компилируемый язык программирования, основанный на JavaScript.",
            "В отличие от JavaScript, TypeScript — это язык программирования со статической типизацией. Как средство проверки статического типа, TypeScript будет проверять поведение определенных переменных перед запуском вашей программы. Это имеет место даже в том случае, когда вы объявляете переменные без указания их типа. В таких ситуациях TypeScript может автоматически назначать типы объявленным переменным.",
            "-*-",
            "TypeScript состоит из трёх частей:",
            "- синтаксис языка программирования,",
            "- компилятор,",
            "- сервис для редактора.",
            "Синтаксис TypeScript позволяет разработчику элегантно выразить решение задачи в виде текста в файле .ts или .tsx. Он является эволюцией синтаксиса JavaScript, поэтому любая программа JS синтаксически корректна на TypeScript.",
            "Компилятор tsc помогает обнаружить множество дефектов до загрузки на продакшн. Он преобразует исходный текст TypeScript в JavaScript и анализирует программу, стараясь найти проблемные места. TypeScript может создать. js-файлы для любой версии JavaScript, начиная с ES3. Разработчик может диктовать TypeScript, какие правила анализа активировать, а какие — отключить.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое JavaScript?",
        answer: [
            "JavaScript — это однопоточный (single threaded) язык программирования с одиночным стеком вызовов. Это означает, что в один момент JavaScript может выполнять только одну операцию (обработать только один кусок кода). ",
            "-*-",
            "JavaScript — это язык программирования на стороне клиента/сервера.",
            "JavaScript можно вставить в HTML, чтобы сделать веб-страницу интерактивной и обеспечить взаимодействие с пользователем.",
            "JavaScript имеет динамическую типизацию. Это означает, что тип объектов проверяется во время выполнения . (В статически типизированном языке тип проверяется во время компиляции.) Другими словами, переменные JavaScript не связаны с типом. Это означает, что вы можете без проблем изменить тип данных.",
            "JavaScript — это интерпретируемый язык. Интерпретатор в браузере читает код JavaScript, интерпретирует каждую строку и запускает ее.",
            "JavaScript — это язык, чувствительный к регистру.",
            "JavaScript — это кросс-платформенный, объектно-ориентированный скриптовый язык (язык сценариев), являющийся небольшим и легковесным. Внутри среды исполнения JavaScript может быть связан с объектами данной среды и предоставлять программный контроль над ними.",
            "JavaScript работает с одним потоком. Это означает, что он выполняет код по порядку и должен завершить выполнение фрагмента кода, прежде чем перейти к следующему.",
            "Это не позволяет писать код, который интерпретатор мог бы выполнять параллельно в нескольких потоках или процессах.",
            "-*-",
            " ",
        ],
        isParagraph: true
    },
    {
        heading: "В чем различия между TypeScript и JavaScript?",
        answer: [
            "1. TypeScript - это объектно-ориентированный язык программирования, основанный на объектах.",
            "2. JavaScript - это объектно-ориентированный язык сценариев, состоит из сценариев для автоматизации какой-либо функции/действия.",
            "3. Языки сценариев не нуждаются в этапе компиляции и в основном интерпретируются.",
            "      *  Интерпретация — это когда код, написанный на языке программирования, проходит построчный анализ, построчную обработку, построчно принимает команды и сразу выполняет их. ",
            "      *  Компиляция: это когда код, написанный на языке программирования, «переводят» в машинные команды целиком.",
            "4. TypeScript строго типизированный, определяет ошибки в период разработки, а JavaScript находит их во время выполнения кода.",
            "5. TypeScript поддерживает статическую типизацию, в то время как JavaScript имеет динамическую типизацию.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Каковы основные особенности TypeScript?",
        answer: [
            "1. Кроссплатформенность : компилятор TypeScript можно установить в любой операционной системе, такой как Windows, macOS и Linux",
            "2. Особенности ES6 : TypeScript включает в себя большинство функций запланированного ECMAScript 2015 ( ES6 ), таких как функции Arrow.",
            "3. Объектно-ориентированный язык : TypeScript предоставляет все стандартные функции ООП , такие как классы, интерфейсы и модули.",
            "4. Статическая проверка типов : TypeScript использует статическую типизацию и помогает проверять типы во время компиляции. Таким образом, можно обнаружить ошибки во время компиляции, при написании кода без запуска скрипта.",
            "5. Необязательная статическая типизация : TypeScript также допускает необязательную статическую типизацию, если вы привыкли к динамической типизации JavaScript.",
            "6. Управление DOM: вы можете использовать TypeScript для управления DOM для добавления или удаления элементов веб-страницы на стороне клиента.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Каковы преимущества использования TypeScript?",
        answer: [
            "1. Если тип переменной не поддерживает некую операцию, компилятор выдаст ошибку.",
            "2. Простая отладка благодаря расширенному отладчику, который фокусируется на отлове логических ошибок перед компиляцией. Если код компилируется, скорее всего он работает. При внесении правок в код среда сразу укажет на измененные классы и функции, а также предупредит об ошибках компиляции (упрощается рефакторинг).",
            "3. Статическая типизация делает TypeScript более удобным для чтения и более структурированным, чем динамическая типизация JavaScript.",
            "4. Читаемость кода упрощает разработчикам поддержку чужих приложений. Может использоваться на разных платформах , как в клиентских, так и в серверных проектах благодаря универсальной транспиляции.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Файл конфигурации tsconfig.json",
        answer: [
            "С помощью файла конфигурации tsconfig.json можно настроить проект TypeScript. В частности, этот файл выполняет следующие задачи:",
            " - устанавливает корневой каталог проекта TypeScript;",
            " - выполняет настройку параметров компиляции;",
            " - устанавливает файлы проекта.",
            "Для его использования достаточно вручную добавить новый файл с именем tsconfig.json в корень проекта.",
            "Вы можете перечислить различные настройки в файле tsconfig.json, который находится в формате JSON. Это подсказывает компилятору, как скомпилировать проект. Этот файл является корневым файлом проекта TypeScript, поскольку он находится в каталоге.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое переменные TypeScript и как вы их создаете?",
        answer: [
            "Переменная - это именованная область памяти, используемая для хранения значений. После имени переменной ставится двоеточие (:), за которым следует тип при объявлении переменной в TypeScript.",
            " - Имена переменных могут содержать буквы и цифры.",
            " - Они не должны содержать пробелы и специальные символы, кроме нижнего подчеркивания (_) и символа доллара ($)",
            " - Имена переменных не должны начинаться с цифр.",
            "Перед использованием переменная должна быть объявлена. Чтобы объявить переменную, используется ключевое слово var, let, const.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как создать переменную в TypeScript? Различия ‘let’, ‘var’ и ‘const’ в TypeScript.",
        answer: [
            "1. ‘let’ позволяет объявлять переменные как в глобальной, так и в локальной областях видимости. let — это способ объявления переменных по умолчанию в TypeScript. По сравнению с var, let уменьшает количество ошибок во время компиляции и повышает читаемость кода.",
            " - Объявление глобальной переменной: использование let вне функции.",
            " - Объявление локальной переменной: использование let внутри функции.",
            "2. ‘var’ позволяет объявлять переменные только с глобальной областью видимости, независимо от того места, где она была определена. Необходимо избегать использования var всегда, когда это возможно, потому что это может вызвать проблемы в больших проектах.",
            "3. ‘const’ аналогично let, за исключением того, что невозможно изменить значение переменной const после ее объявления. const создает постоянную переменную, значение которой не может измениться. Сonst использует те же правила области видимости, что let и помогает снизить общую сложность программы.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Область действия переменной TypeScript",
        answer: [
            "Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. TypeScript имеет три типа областей видимости −",
            "1. Глобальная область видимости : глобальные переменные объявляются вне программных конструкций. К этим переменным можно получить доступ из любого места вашего кода.",
            "2. Функциональная область видимости (область видимости функции): переменные, определенные в функции или классе, могут использоваться в любом месте этой области.",
            "3. Локальная (блочная) область видимости: переменные, определенные внутри блока ({}). Локальные переменные, как следует из названия, объявляются в конструкциях, таких как методы, циклы и т.д. Локальные переменные доступны только внутри конструкции, в которой они объявлены.",
            "---",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Правила аннотации типа.",
        answer: [
            "TypeScript расширяет синтаксис JavaScript за счет добавления в него типов.",
            "В TypeScript аннотация или указание типа осуществляется с помощью оператора двоеточия (:), после которого следует идентификатор (именование) типа. TypeScript является статически типизированным языком, поэтому после того как идентификатор будет связан с типом, изменить тип будет невозможно.",
            "-*-",
            "- Аннотация типа устанавливается оператором двоеточия (:), после которого следует указание типа данных.",
            "- При объявлении переменных тип данных указывается сразу после идентификатора.",
            "- У функций и методов класса возвращаемый тип данных указывается между параметрами и телом.",
            "- У стрелочных функций возвращаемый тип данных указывается между параметрами и стрелкой.",
            "- У функций, стрелочных функций и методов класса, параметрам также указывается тип данных.",
            "- При необходимости функциям, стрелочным функциям и методам класса можно указать параметры типа, которые заключаются в угловые скобки и указываются перед круглыми скобками, в которых размещаются параметры функции",
            "- В TypeScript аннотирование типов у функций, методов и конструкторов расширено при помощи перегрузки функций.",
            "- Для полей класса тип данных указывается сразу после идентификатора-имени.",
            "- Для геттеров (getters) указывается возвращаемый тип данных.",
            "- Для сеттеров (setters) указывается тип единственного параметра и вовсе не указывается возвращаемый тип.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип в TypeScript. Дерево иерархии типов.",
        answer: [
            "У каждого типа в TypeScript есть свое место в иерархии, которую можно представить в виде древовидной структуры. Она всегда состоит из одного родительского и одного дочернего узла. В иерархии типов родительскому узлу соответствует супертип, а дочернему узлу — подтип.",
            "1. Супертипы: аny и unknown - два типа, которые могут выступать как супертипы всех остальных типов в TypeScript. Мы можем присвоить этой переменной значение любого типа, таким образом any и unknown включают в себя все остальные типы. ",
            "-*-",
            "2. Типы в середине иерархии. Между типами верхнего и нижнего уровня иерархии, есть другие типы: number, string, boolean и их СОСТАВНЫЕ типы.",
            "Тип void в TypeScript — это супертип для типа undefined. TypeScript позволяет присваивать значение undefined типу void (восходящее приведение), но не наоборот (нисходящее приведение).",
            "",
            "-*-",
            "3. Тип never полностью противоположен типам верхнего уровня — any и unknown. Never является подтипом всех остальных типов и не принимает никакие значения, в том числе значения типа any. Невозможно присвоить переменной c never значение какого либа типа.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип в TypeScript. Система типов в TypeScript.",
        answer: [
            "Тип (данных) — это характеристика поведения данных, определение их значений и видов операций, которые могут быть выполнены над этими данными.",
            "Типы созданы для того, чтобы заранее указать тип переменной и строго соблюдать его.  Если мы указали тип у переменной и присвоили ей несоответствующий тип, то компилятор выдаст ошибку и будет ругаться.",
            "-*-",
            "Система типов в TypeScript разделена на четыре основных раздела:",
            "    1. Any - специальный тип, который может использоваться для отключения проверки типов.",
            "    2. Примитивные типы Number, String, Boolean, Symbol, BigInt.",
            "    3. Специальные типы Null, Undefined, Void, Never, Unknown",
            "    4. Типы, определяемые пользователем. Пользователь также может определять свой собственный тип данных. Определяемые пользователем типы включают в себя: псевдоним типов, интерфейс объективного или функционального типа, дженерик-типы, объединение типов, пересечение типов, перечисления (enums), классы, интерфейсы, массивы и кортеж.",
            "-*-",
            " Система типов в TypeScript отвечает за проверку типа данных, до того, как эти данные могут быть предоставлены в качестве входных данных для программы.",
            "  - Аннотации типа для переменных.",
            "  - Аннотации типа параметров функции.",
            "  - Аннотация типа возвращаемого значения функции.",
            "  - Аннотации типа массивы, кортеж (tuple), перечисления (enum).",
            "  - Аннотации объектного типа.",
            "- и т.д.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое тип “any” и когда его использовать в TypeScript ?",
        answer: [
            "1. Тип данных “any” описывает значения любого типа. “Any” отключает проверку для этого типа во время компиляции.",
            "2. “Any” и “unknown” - два супертипа для всех остальных типов в TypeScript. Таким переменным мы можем присвоить значение любого типа.",
            "3. Тип “Any” используется, когда мы ожидаем переменную, точный тип которой не знаем. Эта переменная может быть получена из некоего динамического содержимого, например, из сторонних программ, библиотек.",
            "4. Стоит отметить, что если объявить переменную и не указывать ее тип, то будет считаться, что она имеет тип “any”.",
            "5. Рекомендуется всегда явно указывать тип там, где это возможно, и не стоит везде использовать тип “any” так, как это может привести к нежелательным ошибкам в будущем.",
            "-*-",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Unknown” - тип неизвестный, описывает значения любого типа.",
        answer: [
            "1. Unknown -  это аналог any, который также описывает значения любого типа. Однако, прежде чем работать со значением unknown, необходимо убедиться в его типизации: проверить его тип или определить ему тип(<> as). ",
            "-*-",
            "2. Пример: чтобы работать со значением unknown, делаем проверку его типа: ",
            "function test(arg: unknown) {",
            "      if (typeof arg === 'number') {",
            "           console.log(arg + 5)",
            "      }",
            "      if (typeof arg === 'string') {",
            "           console.log(arg.charCodeAt(0))",
            "      }",
            "      if (Array.isArray(arg)) {",
            "           console.log(arg.concat([ 1, 2, 3 ]))",
            "      }",
            "      if (typeof arg === 'object' && arg !== null ) {",
            "           console.log({ ...arg })",
            "      }",
            "}}",
            "-*-",
            "3. Особенности типа Unknown: ",
            "3.1. Над типом unknown запрещено выполнение каких-либо операций.",
            "3.2. В TypeScript, чтобы работать со значением unknown, необходимо проверить его тип или определить ему тип(<> as).",
            "3.3. Unknown присваивается самому себе или any.",
            "3.4. Если тип unknown составляет тип пересечение (intersection), то он будет перекрыт всеми типами.",
            "3.5. Если тип unknown составляет тип объединение (union), то он перекроет все типы, за исключением типа any.",
            "3.6. Запрос ключей (keyof) для типа unknown возвращает тип never.",
            "3.7. Тип unknown позволяется использовать только в операциях равенства ===, ==, !== и != и в операциях с логическими операторами &&, || и !.",
            "3.8. Также стоит упомянуть, что функция у которой возвращаемый тип принадлежит к типу unknown, может не возвращать значение явно.",
            "-*-",
            "Перед работой со значением unknown этими ограничениями гарантируется его проверка, что важно для снижения вероятности ошибок времени выполнения.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Когда использовать тип “unknown” ?",
        answer: [
            "1. Тип unknown позволяется использовать только в операциях равенства == ... == и != и в операциях с логическими операторами &&, || и !. ts.",
            "2. Возможно, нам потребуется описать тип переменных, которые мы не знаем при написании приложения. Эти значения могут поступать из динамического содержимого – например, от пользователя – или мы можем захотеть намеренно принять все значения в нашем API. В этих случаях мы хотим предоставить тип, который сообщает компилятору и будущим читателям, что эта переменная может быть любой, поэтому мы присваиваем ей unknown тип.",
            "-*-",
            "Варианты использования: ",
            "1. Описание с помощью типа unknown неизвестного значения, возвращаемого из сетевого вызова.",
            "2. В утверждении типа.",
            "3. Везде, где возможно, вместо any.",
            "4. Ответы от неизвестных API.",
            "5. Ошибки в catch блоках",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Разница между типами “any” и “unknown”. ",
        answer: [
            "Unknown -  это аналог any, который также описывает значения любого типа. Однако, прежде чем работать со значением unknown, необходимо определить его тип: проверить или переназначить(<> as) ",
            "-*-",
            "Вот главные отличия any от unknown:",
            "1. “Any” отключает проверку для этого типа во время компиляции и выполнение кода продолжается. Перед работой со значением “unknown” гарантируется его проверка, запрещено выполнение каких-либо операций и выполнение кода останавливается до тех пор пока мы не определим его тип.",
            "2. “Unknown” присваивается самому себе или any, а any — чему угодно.",
            "-*-",
            "Типы “any” и “unknown” — это два полезных примитива TypeScript.",
            "“Any” может пригодиться для отключения проверки типа во время компиляции, чтобы предотвратить остановку выполнения кода. Однако этим не обеспечивается типобезопасность, и такие инструменты, как автозаполнение, оказываются нерабочими.",
            "“Unknown” предпочтительнее, когда тип вводимых данных неизвестен. Можно сказать, что тип unknown создан в противовес типу any. “Unknown” был создан для защиты операций с типами, у которых вообще нет типа. Это запрещает любые прямые операции с этим типом.",
            "“Unknown” не существует во время выполнения, поэтому вы не можете создать экземпляр unknown или что-то в этом роде.",
            "“Any”, по возможности, следует избегать.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Примитивные типы Number, String, Boolean, Symbol, BigInt",
        answer: [
            "1. Number (number) примитивный числовой тип. ",
            "2. String (string) примитивный строковый тип.",
            "3. Boolean (boolean) примитивный логический тип.",
            "4. Symbol (symbol) примитивный символьный тип.",
            "5. BigInt (bigint) примитивный числовой тип.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Специальные типы Null, Undefined, Void, Never, Unknown",
        answer: [
            "1. Null - примитивный тип. Имеет явно присвоенное значение null, которое означает отсутствие значения.",
            "2. Undefined - переменная не определена. Она объявлена, но ей не присвоено какое-либо значение.",
            "3. Void - отсутствие конкретного типа. Void явно указывает на то, что у функции или метода отсутствует возвращаемое значение. Оно есть, но оно undefined.",
            "4. Never - примитивный тип данных. Служит для указания того, что какие-либо операции никогда не будут выполнены.",
            "5. Unknown - это аналог any, который также описывает значения любого типа. Однако, прежде чем работать со значением unknown, необходимо убедиться в его типизации (проверить) или переопределить его тип(<> as).",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Null” примитивный тип, значение которого пустое, либо не существует.",
        answer: [
            "1. Null относится к значению, которое либо пусто, либо не существует. Null означает отсутствие значения. Чтобы сделать переменную null, мы должны присвоить ей значение null, поскольку по умолчанию в typescript неназначенные значения называются неопределенными.",
            "-*-",
            "2. В TypeScript null и undefined являются субтипами, им могут быть присвоены любые другие типы, например, string или number. ",
            "3. Проверка, является ли переменная Null",
            "Поскольку оператор typeof возвращает объект, его нельзя использовать для проверки наличия null. В результате вы можете использовать либо операторы == , либо === .",
            "В приведенном ниже коде мы можем видеть, что оператор typeof возвращает объект. При проверке с помощью ‘==’ он возвращает значение true, когда переменная == null, но он также возвращает значение true, когда значение null == undefined. Но когда мы используем оператор строгого равенства, ‘false’ возвращается при сравнении null с undefined.",
            "let variable: null;",
            "variable = null;",
            "- console.log(typeof variable) // object",
            "- console.log(variable == null); // true",
            "- console.log(variable == undefined); // true",
            "- console.log(null == undefined); // true",
            "- console.log(variable === undefined); // false",
            "- console.log(null === undefined); // false",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Undefined” примитивный тип - значение которого неопределённо. ",
        answer: [
            "Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined. Undefined используется, чтобы обозначить неопределённое значение.",
            "-*-",
            "1. JavaScript автоматически (по умолчанию) устанавливает значение undefined объявленным переменным, которые не были проинициализированы значением.",
            " ",
            "2. Также JavaScript автоматически (по умолчанию) устанавливает значение undefined в аргумент функции, если значение не передали при вызове:",
            "    function hello(name) {",
            "        console.log('Привет, ' + name)",
            "    }",
            "    hello('Витя');  // Привет, Витя",
            "*   hello(); // Привет, undefined - значение не передали при вызове.",
            " ",
            "3. Функция возвращает undefined, если она не возвращает какого-либо значения:",
            "    *   внутри функций отсутствует 'return value'; ",
            "    *   или присутствует 'return' без значения;",
            "    *   если переменная, участвующая в вычислениях, не имеет присвоенного значения. ",
            " ",
            "4. При обращении к несуществующему свойству объекта или к свойству объекта, значение которого неопределено, также вернётся undefined.",
            " ",
            "5. Вручную установленное undefined используют, чтобы обозначить неизвестное значение: ",
            "    const person = {",
            "        name: 'Пётр',",
            "        lastName: 'Романов',",
            "        age: undefined ",
            "    }",
            " ",
            "6. Технически мы можем присвоить значение undefined любой переменной. …Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.",
            " ",
            "7. В TypeScript null и undefined являются субтипами. Субтипы – это типы, которые могут быть присвоены любому другому типу, например, string или number. ",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как проверить на “null” или “undefined”?",
        answer: [
            "Для проверки на undefined и на null рекомендуется применять строгую проверку на:  ",
            "    - равенство:    variable === null;  ",
            "                             variable === undefined; ",
            "    - неравенство:  variable !== null;  ",
            "                              variable !== undefined.",
            "Так же оператор нулевого слияния ‘??’ помогает выполнить эту проверку. ",
            " ",
            "1. Строгое равенство ‘===’ или не строгое равенство ‘==’? ",
            "    console.log(null == undefined); // Returns true",
            "    console.log(null === undefined); // Returns false",
            " ",
            "2. Строгое неравенство  ‘!==’:",
            "const message = undefined;",
            "getMessage() {",
            "   if (this.message !== null && this.message !== undefined) {",
            "       return 'default message';",
            "   }",
            "   return this.message;",
            "}",
            " ",
            "3. Так же оператор нулевого слияния ‘??’ помогает проверить, является ли переменная null или undefined. С оператором ?? вместо длинной проверки:",
            "message = undefined;",
            "getMessage() {",
            "   return this.message ?? 'Default message';",
            "}",
            "    - если 'message' определено, то 'message', ",
            "    - если 'message' не определено, то 'Default message'. ",
            "Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй. ",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Void” примитивный тип, указывает на отсутствие конкретного типа",
        answer: [
            "1. Тип “void” используется для обозначения отсутствия возвращаемого значения из функции. Тип “void” говорит нам, что функция ничего не возвращает (или по иному говоря возвращает undefined).",
            "const a = (): void => { ",
            "     return undefined; ",
            "} ",
            " ",
            "2. Например в функции отсутствует слово return, значит функция не возвращает никакого значения. Следовательно, результат выполнения этой функции отсутствует и мы для возвращаемого значения функции указываем тип void.",
            " ",
            "3. Типу void нельзя присвоить ни одного значения.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Never” примитивный тип, указывает, что никогда...",
        answer: [
            "1. Never — это тип, который указывает, что эти операции никогда не будут выполнены; эти значения никогда не встречаются; этих значений никогда не будет; эти функции никогда не вернут определённого значения и результата, и так же как и void, never не имеет явных значений. ",
            "Тип Never указывает на то, что функция ни при каких обстоятельствах не может ничего вернуть из себя, например, она всегда бросает ошибку или включает в себя бесконечный цикл, который не может ничего вернуть из функции. Этот тип является субтипом и может быть присвоен любому типу, но не наоборот.",
            "-*-",
            "2. В TypeScript во время компиляции происходит проверка типов. Мы не всегда можем знать заранее тип некоторых переменных, особенно когда эти значения приходят из сторонних библиотек, введённые пользователем. Тип never используется, когда вы уверены, что что-то никогда не произойдёт.",
            "Например: ",
            "2.1. Когда функция возвращает ошибку и не заканчивает своё выполнение.",
            "export const error = (message: string): never => {",
            "        throw new Error(message); ",
            "} ",
            " ",
            "2.2. Когда функция действительно постоянно выполняется, например находится в бесконечном цикле.",
            "2.3. Для определения типа значения в невозможной ситуации: default в свитче, который никогда не вызовется.  https://purpleschool.ru/blog/typescript-never-type ",
            "2.4. Благодаря never мы можем исключить ненужные типы. Например, сделаем тип, которому, если передано значение с number, мы присваиваем never, то есть, мы исключаем тип number из наших ожиданий. Оставляем только нужный тип в типе А: ",
            "     type NonNumber<T> = T extends number ? never : T; ",
            "     type A = NonNumber<string | number>;  ",
            "-*-",
            "3. В каких случаях может быть полезен Never?",
            "3.1. Never можно использовать для аннотации возвращаемого из функции или метода значения. Тип never можно указать только той функции, из которой программа действительно никогда не сможет выйти.",
            "3.2. Для дополнительной проверки кампилятором, что какая-то ситуация реально не может произойти.",
            "3.3. Для того, чтобы сымитировать пустой элемент в union типе.",
            "Рассмотрим пример:",
            "type Test = number | string | never; ",
            "never у нас сразу исчезает, потому, что это просто пустой элемент - ничего.",
            "// ^? type Test = number | string;",
            "-*-",
            "4. Never находится в самом низу дерева иерархии типов, от которого не отходят никакие другие ветви, имеет два свойства:",
            "- Переменной с типом never можно присвоить только тип never и никакой другой, даже any.",
            "- Тип данных never является подтипом всех типов, поэтому тип never может быть присвоен пременной с любым типом: any, string, unknown, undefined и т.д.",
            "-*-",
            "5. Never - это юнион, у которого нету элементов. Представляет из себя на уровне типизации кейс, который не может произойти, так как юнион с нулями элементов у нас тоже не может существовать.",
            "-*-",
            "6. Когда у нас появляется never? Never появляется тогда, когда мы доходим до кейса, который не может никогда произойти.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "В чем разница между “void” и “never” в TypeScript?",
        answer: [
            "Функция, которая ничего не возвращает – это void, но она возвращает undefined.",
            "Функция, которая никогда ничего не возращает – это never. ",
            " ",
            "1.1. Void возвращает undefined. Это происходит в случае отсутствия оператора return:",
            "function f(arg): void {",
            "      console.log(arg);",
            "}",
            "1.2. Void возвращает undefined и в случае, когда конструкция return используется без указания аргумента:",
            "function f(arg): void {",
            "     if (arg < 0) {",
            "           return;",
            "     }",
            "     console.log(arg);",
            "}",
            " ",
            "",
            "2. Never можно представить как запрет использования оператора return в функции. Never никогда не возвращает значения. Такое может быть когда функция всегда выбрасывает ошибку или идёт бесконечный цикл.",
            " ",
            "3. Если говорить о выборе между void и never, то вам почти всегда нужно выбирать именно void. Все дело в том, что never используется в совсем уж экзотических ситуациях, поэтому его можно смело исключать из набора типов 'на каждый день'.",
            "    Never можно использовать для аннотации возвращаемого из функции или метода значения. Тип never можно указать только той функции, из которой программа действительно никогда не сможет выйти.",
            "    Для дополнительной проверки кампилятором, что какая-то ситуация реально не может произойти.",
            "    Для того, чтобы сымитировать пустой элемент в union типе.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“object” vs “Object” vs “Record”<string, unknown> vs {}",
        answer: [
            "object - представляет все непримитивные типы, то есть тип, который не является number, string, boolean, symbol, null или undefined. Тип object можно присвоить для function, array и объект.",
            "Object - включает в себя все JavaScript-объекты, используется для описания прототипа Object.prototype. Его не надо использовать. Туда можно присвоить всё, кроме undefined и null.  ",
            "{} - представляет собой любое значение (unknown), отличающееся от undefined и null.",
            "Record<string, unknown> - представляет объект, который имеет строки в качестве ключей (индексов). Только для объекта. Массивы, функции сюда не полезут.",
            "-*-",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Определяемый пользователем тип. ",
        answer: [
            "Пользователь также может определять свои собственные типи данных. Определяемые пользователем типы включают в себя: псевдоним типов, интерфейс объективного или функционального типа, дженерик-типы, объединение типов, пересечение типов, перечисления (enums), классы, интерфейсы, массивы и кортеж.",
            "- псевдоним типов",
            "- интерфейс объективного или функционального типа,",
            "- дженерик-типы,",
            "- объединение типов,",
            "- пересечение типов, ",
            "- классы,",
            "- массивы",
            "- перечисления (enums)",
            "- кортеж типа Tuple",
            "",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Cтруктура – это составной тип данных.",
        answer: [
            "Обычно в TypeScript не разделяют понятия типа и структуры, потому что структура тоже является типом. Структура – это составной тип данных, который состоит из разных типов, сгруппированных под одним типом.",
            "1. Тип Array или типизированный массив.",
            "2. Тип Tuple или кортеж.",
            "3. Тип Enum или перечисление.",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип “Array” или типизированный массив. ReadonlyArray<string> и readonly string[]",
        answer: [
            "Тип Array указывает, что в переменной находится массив с определённым типом данных у его элементов.",
            "1. Массивы определяются с помощью выражения [] и также являются строго типизированными. То есть если изначально массив содержит строки, то в будущем он сможет работать только со строками.",
            "let list: number[] = [10, 20, 30];",
            "-*-",
            "2. Как и в JavaScript, с помощью индексов можно обращаться к элементам массива.",
            "console.log(list[0]);",
            "console.log(colors[1]);",
            "-*-",
            "3. Альтернативный способ определения массивов представляет применение типа Array<>, где в фигурных скобках указывается тип элементов массива:",
            "let names: Array<string> = ['Tom', 'Bob', 'Alice'];",
            "console.log(names[1]);  // Bob",
            "Формы массивов: number[] или string[] являются сокращением соответственно типов Array<number> или Array<string>",
            "В остальном массивы в TypeScript поддерживают все те же операции, что и массивы в JavaScript.",
            "-*-",
            "4. ReadonlyArray и readonly. Массивы позволяют изменять значения своих элементов:",
            "- const people = [ 'Tom', 'Bob', 'Sam' ];",
            "- people[1] = 'Kate';",
            "- console.log(people[1]); // Kate",
            "Но TypeScript также позволяет определять массивы, элементы которых нельзя изменять.",
            "4.1. Для этого применяется тип ReadonlyArray<>, для которого в угловых скобках указывается тип элементов массива.:",
            "- const people: ReadonlyArray<string> = [ 'Tom', 'Bob', 'Sam' ];",
            "Теперь не можем изменять значения элементов массива:",
            "- people[1] = 'Kate';     // ! Ошибка элементы массива ReadonlyArray нельзя изменить",
            "-",
            "4.2. Также можно использовать сокращение типа - readonly Тип_данных[]:",
            "- const people: readonly string[]= [ 'Tom', 'Bob', 'Sam' ];",
            "Теперь не можем изменять значения элементов массива:",
            "- people[1] = 'Kate';     // ! Ошибка элементы массива ReadonlyArray нельзя изменить",
            "-*-",
            "5. Деструктуризация массивов. Как и в javascript, массивы поддерживают декомпозицию на константы и переменные. Например:",
            "const people: string[]= [ 'Tom', 'Bob', 'Sam' ];",
            "const [first, second, third] = people;",
            "- console.log(first);     // Tom",
            "- console.log(second);    // Bob",
            "- console.log(third);     // Sam",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип “Tuple” или кортеж.",
        answer: [
            "1. Кортежи (Tuples) также, как и массивы, представляют собой индексированный (спископодобный) набор элементов. Кортеж может иметь любое количество элементов. Но, в отличие от массивов: ",
            "- каждый из элементов кортежа имеет свой определенный тип;",
            "- кортежи имеют фиксированное количество элементов, определённый размер, длина которого не изменяется.",
            "-*-",
            "2. Для определения кортежа применяется синтаксис массива :",
            "* В данном случае кортеж bob представляет тип [ string, number, boolean ], то есть такой кортеж, который состоит из трёх элементов, при чем первый элемент представляет тип string, второй элемент - тип number, а третий - boolean.",
            "let bob: [ string, number, boolean ]",
            "* Для присвоения значения применяется массив:",
            "bob = [ 'Bob', 41, true ]",
            "* Причем передаваемые кортежу данные должны соответствовать элементам по типу. Например, ниже неправильный пример инициализации кортежа;",
            "bobInfo = [ 41, true, 'Bob' ]; // Ошибка ",
            "* Определение кортежа в одну строчку: ",
            "let bob: [ string, number, boolean ] = [ 'Bob', 41, true ];",
            "-*-",
            "3. Для обращения к элементам кортежа, для переопределения их значения, так же как и для массива, применяются индексы:",
            "let bob: [ string, number, boolean ] = [ 'Bob', 41, true ];",
            "   console.log(bob[ 2 ]); // true // доступ к значению элемента кортежа под индексом 2. ",
            "   bob[ 2 ] = false; // изменение значения элемента кортежа под индексом 2.",
            "   console.log(bob[ 2 ]); // false",
            "-*-",
            "4. С помощью цикла for можно перебрать элементы кортежа:",
            "let bob: [ string, number, boolean ] = [ 'Bob', 41, true ]",
            "for( const prop of bob ){",
            "-- console.log( prop );",
            "}",
            "-*-",
            "5. Кортежи в функциях:",
            "5.1. Кортежи как параметры функции: ",
            "function printUser(user: [ string, number ]) {",
            "        console.log(user[ 0 ]);",
            "        console.log(user[ 1 ]);",
            "}",
            "let user: [ string, number ] = [ 'Tom', 36 ];",
            "printUser( tom );",
            "-*-",
            "5.2. Кортеж как результат функции:",
            "function createUser( name: string, age: number ) : [ string, number ]{",
            "        return [ name, age ];",
            "}",
            "let user = createUser( 'Bob', 41 );",
            "console.log(user[ 0 ]);",
            "console.log(user[ 1 ]);",
            "-*-",
            "6. Необязательные элементы кортежей.",
            "Кортежи могут иметь необязательные элементы, для которых можно не предоставлять значение. Чтобы указать, что элемент является необязательным, после типа элемента ставится вопросительный знак ?:",
            "let bob: [ string, number, boolean? ] = [ 'Bob', 41, true ];",
            "let tom: [ string, number, boolean? ] = [ 'Tom', 36 ];",
            "-*-",
            "7. Заполнение кортежа c помощью оператора ...",
            "7.1. С помощью оператора ... внутри определения типа кортежа можно определить набор элементов, количество которых неопределено. Например:",
            "- let math: [ string, ...number[ ]] = [ 'Math', 5, 4, 5, 4, 4 ];",
            "- let physics: [ string, ...number[ ]] = [ 'Physics', 5, 5, 5 ];",
            "-*-",
            "7.2. При этом неопределенное количество элементов можно определять как в конце, так и в середине и в начале кортежа:",
            "В данном случае оба кортежа представляют тип [ string, ...number[ ]]. То есть первый элемент кортежа должен представлять тип string. А остальные элементы кортежа должны представлять тип number, причем таких элементов может быть неопределенное количество.",
            "let math: [ string, ...number[ ]] = [ 'Math', 5, 4, 5, 4, 4 ];",
            "-*-",
            "7.3. В случае с кортежем [ ...number[ ], string ] он должен оканчиваться на элемент типа string, перед которым может быть неопределенное количество элементов типа number.",
            "let physics: [ ...number[ ], string ] = [ 5, 5, 5, 'Physics' ];",
            "-*-",
            "7.4. А в кортеже типа [ string, ...number[ ], boolean ] первый элемент должен представлять тип string, а последний - тип boolean. Между ними может быть неопределенное количество элементов типа number.",
            "let chemistry: [ string, ...number[ ], boolean ] = [ 'Chemistry', 3, 3, 4, 5, false ];",
            "-*-",
            "8. Кортеж только для чтения.",
            "8.1. Стандартные кортежи позволяют изменять значения их элементов:",
            "const tom: [ string, number ] = [ 'Tom', 36 ];",
            "tom[ 1 ] = 37;",
            "console.log( tom[ 1 ]);    // 37",
            "-*-",
            "8.2. Однако TypeScript также позволяет создавать кортежи только для чтения, элементы которого нельзя изменить. Для этого перед типом кортежа указывается ключевое слово readonly:",
            "const tom: readonly [ string, number ] = [ 'Tom', 36 ]; ",
            "tom[ 1 ] = 37; // ! Ошибка - элементы кортежа для чтения нельзя изменять",
            "-*-",
            "8.3. Кортеж для чтения в качестве параметра функции:",
            "function printUser( user: readonly [ string, number ]) {",
            "- - console.log( `name: ${ user[ 0 ]}  age: ${ user[ 1 ]}` );",
            "}",
            "-*-",
            "8.4. Кортеж для чтения в качестве результата возврата функции:",
            "function generateUser(): readonly [ string, number ]{",
            "- - return [ 'Sam', 18 ];",
            "}",
            "-*-",
            "9. Деструктуризация кортежа.",
            "9.1. Кортеж, как и массив, можно раскладывать на переменные и константы:",
            "let tom: [ string, number, boolean ] = [ 'Tom', 36, false ];",
            "let [ username, userage, isMarried ] = tom;   // декомпозиция",
            "- console.log( username );      // Tom",
            "- console.log( userage );       // 36",
            "- console.log( isMarried );     // false",
            "Здесь кортеж tom раскладывается на три переменных: username, userage, isMarried. При этом количество переменных должно соответствовать количеству элементов кортежа.",
            "-*-",
            "9.2. С помощью оператора ... можно указать кортеж, в который будут помещаться все оставшиеся элементы раскладываемого кортежа, которые не вошли в предыдущие переменные или константы:",
            "let tom: [ string, number, boolean ] = [ 'Tom', 36, false ];",
            "const [ username, ...rest ] = tom;",
            "- console.log( username );      // Tom",
            "- console.log( rest[ 0 ]);       // 36",
            "- console.log( rest[ 1 ]);       // false",
            "Здесь константа username также принимает первый элемент кортежа - 'Tom'. Все оставшиеся элементы кортежа будут помещаться в кортеж rest.",
            "-*-",
            "9.3. Мы можем определить меньше переменных/констант, чем элементов в кортеже, тогда оставшиеся элементы кортежа будут игнорироваться:",
            "let tom: [ string, number, boolean ] = [ 'Tom', 36, false ];",
            "const [ username, userage ] = tom",
            "- console.log( username );      // Tom",
            "- console.log( userage );       // 36",
            "-*-",
            "9.4. Также можно оставить пустое место вместо переменной/константы, если мы хотим пропустить соответствующий элемент кортежа:",
            "let tom: [ string, number, boolean, number ] = [ 'Tom', 36, false, 170 ];",
            "const [, age, , height] = tom;      // пропускаем первый и третий элементы",
            "- console.log(age);           // 36",
            "- console.log(height);        // 170",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип “enum” или перечисление. Числовые перечисления. ",
        answer: [
            "-*-  Использование перечисления enum оправдано только в том случае, если мы хотим использовать его как объект, например, где то доставать свойства. -*-  ",
            "1. Тип enum или перечисление позволяет определить набор именованных констант, которые описывают определенные состояния (зима, синий, холодный ...). Имена перечислений и констант указываются в стиле PascalСase, в соответствии с которым каждое составное слово начинается с заглавной буквы. Enum больше похож на объект, в нём мы перечисляем конкретные свойства - именованные ключи.",
            "Например, объявим следующее перечисление:",
            "- enum Season { Winter, Spring, Summer, Autumn };",
            "Перечисление называется Season и имеет четыре элемента. Теперь используем перечисление:",
            "enum Season { Winter, Spring, Summer, Autumn };",
            "let current: Season = Season.Summer;",
            "- console.log(current);       // 2",
            "- current = Season.Autumn;    // изменение значения",
            "Здесь создается переменная current, которая имеет тип Season. При этом консоль браузера выведет нам число 2 - значение константы Season.Summer.",
            "-*-",
            "2. Числовые перечисления. ",
            "2.1. По умолчанию, перечисления являются числовыми, как в примере выше, и представляют собой числовые значения. Элементы Enum нумеруются, то есть, каждой именованной константе перечисления сопоставляется (назначается) числовое значение (свой индекс). По умолчанию, эта нумерация начинается с нуля и идёт по порядку.",
            "Так, созданное выше в примере перечисление: ",
            "- enum Season { Winter, Spring, Summer, Autumn }  // 0, 1, 2, 3 ",
            "фактически эквивалентно следующему: ",
            "- enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 }; // 0, 1, 2, 3 ",
            "-*- ",
            "2.2. Однако, мы можем изменить этот порядок, явно переопределив эти значения. Иногда, такая необходимость может возникнуть. То есть, мы сами можем назначить свойству значение: числовое, либо строковое. В этом случае его надо писать (присваивать). Так, мы можем задать значение одной константы, тогда значения следующих констант будет увеличиваться на единицу (в случае присвоения числового значения): ",
            "- enum Season { Winter=5, Spring, Summer, Autumn };           // 5, 6, 7, 8 ",
            "Либо можно каждой константе задать свое значение: ",
            "- enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 };   // 4, 8, 16, 32 ",
            "-*- ",
            "2.3. Мы можем обратиться к свойству через точку или через квадратные скобки: ",
            "enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 };   // 4, 8, 16, 32 ",
            "- console.log(Season.Winter);     // 4  ",
            "- console.log(Season.Spring);     // 8  ",
            "- console.log(Season.Summer);     // 16 ",
            "- console.log(Season.Autumn);     // 32 ",
            "-*- ",
            "2.4. Также мы можем получить непосредственно текстовое значение: ",
            "enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 };   // 4, 8, 16, 32 ",
            "- console.log(Season[4]);  // Winter  ",
            "- console.log(Season[8]);  // Spring  ",
            "- console.log(Season[16]); // Summer  ",
            "- console.log(Season[32]); // Autumn  ",
            "-*-",
            "Фича - как правильно создавать перечисление и минимизировать выходной код. Просто написав enum и описав его перечисляемые значения, мы всегда получим генерацию объекта через функцию. Даже, если этот объект в переспективе не будет использоваться. ",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип “enum” или перечисление. Строковые, гетерогенные перечисления. ",
        answer: [
            "3. Кроме числовых перечислений в TypeScript есть строковые перечисления, константы которых принимают строковые значения: ",
            "enum Season {  ",
            "- Winter = 'Зима',  ",
            "- Spring = 'Весна', ",
            "- Summer = 'Лето',  ",
            "- Autumn = 'Осень'  ",
            "}; ",
            "- consolle.log(Season.Winter); // Зима ",
            "- consolle.log(Season.Spring); // Весна ",
            "- consolle.log(Season.Summer); // Лето ",
            "- consolle.log(Season.Autumn); // Осень ",
            "-*- ",
            "4. Смешанные гетерогенные перечисления, константы которых могут быть и числа и строки. ",
            "enum Season { Winter = 1, Spring = 'Весна', Summer = 3, Autumn = 'Осень' }; ",
            "- consolle.log(Season.Winter); // 1 ",
            "- consolle.log(Season.Spring); // Весна ",
            "- consolle.log(Season.Summer); // 3 ",
            "- consolle.log(Season.Autumn); // Осень ",
            "-*- ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип “enum” или перечисление. Перечисления в функциях. ",
        answer: [
            "5. Перечисление может выступать в качестве параметра функции. ",
            "enum DayTime { ;",
            "- Morning, ",
            "- Evening, ",
            "} ",
            "function welcome(dayTime: DayTime){ ",
            "- if(dayTime === DayTime.Morning){ ",
            "- - console.log('Доброе утро'); ",
            "- } else {",
            "- - console.log('Добрый вечер'); ",
            "- } ",
            "} ",
            "welcome(DayTime.Morning);   // Доброе утро ",
            "welcome(DayTime.Evening);   // Добрый вечер ",
            "-*-",
            "5.1. Каждая константа перечисления описывает некоторое состояние. И функция welcome() в виде параметра dayTime принимает это состояние и в зависимости от полученного значения выводит на консоль определенное значение. ",
            "Однако стоит отметить, что поскольку здесь перечисление DayTime представляет числовое перечисление, то в реальности в функцию welcome() мы можем передать числовые значения:",
            "welcome(0); // Доброе утро  ",
            "welcome(1); // Добрый вечер ",
            "-*-",
            "5.2. Либо даже определить параметр функции как числового или строкового перечисления: ",
            "enum DayTimeMessage {; ",
            "- Morning = 'Доброе утро', ",
            "- Evening = 'Добрый вечер'  ",
            "}; ",
            "function welcome(message: DayTimeMessage){ ",
            "- - console.log(message); ",
            "} ",
            "welcome(DayTimeMessage.Morning);    // Доброе утро ",
            "welcome(DayTimeMessage.Evening);    // Добрый вечер ",
            "5.3. При использовании строковых перечислений в отличие от числовых мы не можем передать переметру произвольную строку:",
            "welcome('Привет, ты спишь?') ",
            "В этом случе компилятор выкатит нам ошибку при компиляции. ",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип Объединение (“Union” Types)",
        answer: [
            "Из множества существующих типов, с помощью конструкции Union, можно создать объединение нескольких указанных типов. Union - это логическое условие, по которому тип переменной (данных) может принадлежать только одному из указанных типов. В TypeScript конструкция объединения имеет следующий синтаксис: ",
            "    const isUnionType: boolean | string | number = true; ",
            "    const isUnionType: boolean | string | number = 'string'; ",
            "    const isUnionType: boolean | string | number = 123; ",
            " ",
            "Конструкцию вида boolean | string | number следует читать так: в этой переменной может находиться значение типа boolean, string или number, но не другого типа. Присвоение переменной другого типа, не входящего в Union, вызовет ошибку:",
            " ",
            "    const isUnionType: boolean | string | number = {}; ",
            "// Ошибка → Тип '{}' нельзя присвоить типу 'boolean | string | number' ",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Тип Пересечение (“Intersection” Type)",
        answer: [
            "1. INTERSECTION (пересечение) {name: string} & {lastName: string} - совмещает два типа данных в один. Позволяет создавать новые типы на основе существующих. ",
            "Пример: ",
            "* У нас есть тип для объекта:",
            "type TypedProduct = { ",
            "      id: string, ",
            "      sku: string,",
            "      name: string, ",
            "      price: number, ",
            "      description: any ",
            "} ",
            "* и сам объект typedProduct: ",
            "const typedProduct = { ",
            "      id: '88', ",
            "      sku: 'marker',",
            "      name: 'Marker', ",
            "      price: 33, ",
            "      description: 'Some description' ",
            "} ",
            "* Так же у нас есть тип дополнительных атрибутов для продукта: ",
            "type AdditionalAttributes = {",
            "    width: number, ",
            "    color: string, ",
            "} ",
            "* Мы хотим объеденить (пересечь) свойства этих типов в один тип:",
            "        type AdvancedProduct = TypedProduct &  AdditionalAttributes",
            "* Создаём объект advancedProduct с типом AdvancedProduct: ",
            "const advancedProduct: AdvancedProduct = { ",
            "      id: '88', ",
            "      sku: 'marker',",
            "      name: 'Marker', ",
            "      price: 33, ",
            "      description: 'Some description' ",
            "      width: 12, ",
            "      color: 'red', ",
            "}",
            "* Можно использовать деструктуризацию при создании объекта: ",
            "const objectDestructuring: AdvancedProduct = {",
            "      ...typedProduct, // разворачиваем объект typedProduct,",
            "      width: 22, // добавляем доп. атрибут,",
            "      color: 'blue', // добавляем доп. атрибут.",
            "}; ",
            " ",
            "2. Пересечение (Intersection) — ещё один мощный механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое. Пересечение указывается с помощью оператора амперсанда & по обе стороны от которого указываются типы данных.",
            "      let v1: T1 & T2 & T3;",
            "Переменной, которой был указан тип пересечение A и B и С должно быть присвоено значение принадлежащее к типам A и B и C одновременно. Другими словами значение должно обладать всеми обязательными признаками каждому типа определяющего пересечение.",
            "      class A { a: number }",
            "      class B { b: string }",
            "      class C { c: boolean }",
            "      let name: A & B & C; // значение должно принадлежать ко всем типам одновременно",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Псевдонимы Типов (Type “Aliases”)",
        answer: [
            "Псевдонимы типов являются псевдонимами для реальных типов. Их можно создавать для любого существующего типа в TypeScript. Псевдоним типа можно реализовать, расширить, если он представляет собой объектный тип или пересечение объектных типов. ",
            " ",
            "Псевдоним типа объявляется при помощи ключевого слова ''type'', после которого следует идентификатор (имя) псевдонима, за ним идет оператор присваивания =, а справа от него находится тип (string, number...) или структура типов, ассоциирующиеся с псевдонимом.",
            "      type AliasT = T;",
            "      type AliasStr = string;",
            "      type AliasNum = number;",
            "      type AliasBoo = boolean;",
            "      type AliasNull = null;",
            " ",
            "Псевдонимы типов являются лишь псевдонимами для реальных типов, они не оставляют следа в коде после компиляции. Псевдоним типа можно реализовать, расширить, если он представляет собой объектный тип (object type) или пересечение объектных типов со статически известными членами. Кроме того, псевдонимы типов нельзя использовать в таких операциях с типами времени выполнения как typeof и instanceof. Если псевдоним типа будет создан для объекта, то при попытке создать его экземпляр возникнет ошибка.",
            " ",
            "Псевдонимы типов можно создавать для любого существующего типа в TypeScript. Псевдонимы типов можно так же создавать как для типов объединений, так и для типов пересечений.",
            "      type MyString = string;",
            "      type SomeType = number | string | boolean; // union type",
            "      type OtherType = number & string & boolean; // intersection type",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое интерфейс?",
        answer: [
            "Интерфейсы в TypeScript - это удобный инструмент для типизации всего кода. Интерфейс - это определение структуры объекта, класса, функции, функционального выражения и т.д. Другими словами, интерфейс - это именованное определение кастомного типа данных, но без реализации.",
            " ",
            "Интерфейсы в TypeScript служат для именования структур типов данных, определения свойств и методов, которые объект должен реализовать. ",
            "Создавая интерфейс мы создаем именованный тип данных, где определяем свойства и методы объектов, функций или классов. В интерфейсе мы указываем какие поля, какие функции и какие вообще элементы должны присутствовать у этих объектов.",
            "Компилятор TypeScript использует интерфейс для проверки типов объектов и определяет, имеют ли они определенную структуру.",
            " ",
            "В TypeScript интерфейс объявляется с помощью ключевого слова interface, после которого указывается идентификатор (имя), за которым следует заключенное в фигурные скобки тело содержащее описание.",
            "interface Identifier {",
            " // тело интерфейса",
            "}",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Правила именования интерфейсов.",
        answer: [
            "Существует два вида именования.",
            "1. Первый вид конвенций родом из языка Java — они предлагают именовать интерфейсы точно так же как и классы. Допускаются имена прилагательные.",
            "interface Identifier {}",
            "2. Второй вид предлагает использовать конвенции языка C#, по которым интерфейсы именуются так же как классы, но с префиксом I, что является сокращением от Interface.",
            "interface IIdentifier {}",
            "В приоритете именования интерфейсов с префиксом I.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "“Interfaces”. Общая теория.",
        answer: [
            "Несмотря на то, что тема относящаяся к интерфейсам очень проста, именно она вызывает наибольшее количество вопросов у начинающих разработчиков. Поэтому, такие вопросы как для чего нужны интерфейсы, когда их применять, а когда нет, будут подробно рассмотрены в этой главе.",
            "По факту, интерфейс затрагивает сразу несколько аспектов создания программ, относящихся к проектированию, реализации, конечной сборке. Поэтому, что бы понять предназначение интерфейса, необходимо рассмотреть каждый аспект по отдельности.",
            "1. Первый аспект — реализация — предлагает рассматривать создаваемые экземпляры как социальные объекты, чья публичная часть инфраструктуры была оговорена в контракте, к коему относится интерфейс. Другими словами, интерфейс — это контракт, реализация которого гарантирует наличие оговоренных в нем членов потребителю экземпляра. Поскольку интерфейс описывает исключительно типы членов объекта (поля, свойства, сигнатуры методов), они не могут гарантировать, что сопряженная с ними логика будет соответствовать каким-либо критериям. По этому случаю была принята методология называемая контрактное программирование. Несмотря на то, что данная методология вызывает непонимание у большинства начинающих разработчиков, в действительности она очень проста. За этим таинственным термином скрываются рекомендации придерживаться устной или письменной спецификации при реализации логики, сопряженной с оговоренными в интерфейсе членами.",
            "2. Второй аспект — проектирование — предлагает проектировать объекты менее независимыми за счет отказа от конкретных типов (классов) в пользу интерфейсов. Ведь пока тип переменной или параметра представляется классовым типом, невозможно будет присвоить значение соответствующее этому типу, но не совместимое с ним. Под соответствующим подразумевается соответствие по всем обязательным признакам, но не состоящим в отношениях наследования. И хотя в TypeScript из-за реализации номинативной типизации подобной проблемы не существует, по возможности рекомендуется придерживаться классических взглядов.",
            "3. Третий аспект — сборка — вытекает из второго и предполагает уменьшение размера компилируемого пакета (bundle) за счет отказа от конкретных типов (классов). Фактически, если какой-либо объект требуется пакету лишь для выполнения операций над ним, последнему вовсе не нужно содержать определение первого. Другими словами, скомпилированный пакет не должен включать определение класса со всей его логикой только потому, что он указан в качестве типа. Для этого как нельзя лучше подходят типы, представленные интерфейсами. Хотя нельзя не упомянуть, что данная проблема не имеет никакого практического отношения к разработчикам на языке TypeScript, поскольку его (или точнее сказать JavaScript) модульная система лишена подобного недостатка.",
            "Вот эти несколько строк, описывающие оговоренные в самом начале аспекты, заключают в себе ответы на все возможные вопросы, которые только могут возникнуть относительно темы сопряженной с интерфейсами. Если ещё более доступно, то интерфейсы нужны для снижения зависимости и наложения обязательств на реализующие их классы. Интерфейсы стоит применять всегда и везде, где это возможно. Это не только повысит семантическую привлекательность кода, но и сделает его более поддерживаемым.",
            "Не лишним будет добавить, что интерфейсы являются фундаментальной составляющей идеологии как типизированных языков, так и объектно-ориентированного программирования.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "extends-наследование в typescript.",
        answer: [
            "Одним из ключевых моментов объектно-ориентированного программирования является наследование. В TypeScript наследование реализуется с помощью ключевого слова extends.",
            "Наследование — это механизм, при котором дочерние классы могут получать доступ к свойствам и методам родительских классов. Между тем, абстракция — это метод, который скрывает от пользователя подробную реализацию кода, чтобы уменьшить сложность и повысить эффективность.",
            "-*-",
            "extends means:",
            "Новый класс является дочерним. Он получает преимущества, связанные с наследованием. Он имеет все свойства, методы как его родитель. Он может переопределить некоторые из них и реализовать новые, но родительский материал уже включен.",
            "implements means:",
            "Новый класс можно рассматривать как ту же «форму», пока он не является дочерним. Его можно передать любому методу, где требуется Person, независимо от наличия другого родителя, отличного от Person.",
            "      class Person {",
            "            name: string;",
            "            age: number;",
            "      }",
            " ",
            "      class Child extends Person {};",
            "      class Man implements Person {};",
            " ",
            "* Когда подкласс расширяет класс, он позволяет подклассу наследовать (повторно использовать) и переопределять код, определенный в супертипе.",
            "* Когда класс реализует интерфейс, он позволяет использовать объект, созданный из класса, в любом контексте, который ожидает значение интерфейса.",
            " ",
            "Расширение интерфейсов осуществляется с помощью ключевого слова extends, после которого через запятую идет один или несколько идентификаторов расширяемых интерфейсов.",
            "      interface IIdentifiable {}",
            "      interface ILiving {}",
            "// интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, ",
            "// которую можно выделить в интерфейс IAnimal",
            "      interface IAnimal extends IIdentifiable, ILiving {}",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как сделать параметр интерфейса необязательными?",
        answer: [
            "В Typescript “?” представляет необязательные параметры.",
            "Мы используем необязательные параметры, когда не обязательно, чтобы этот параметр имел значение или был указан. Даже если функция задает параметры, вы можете вызвать ее без указания каких-либо аргументов в JavaScript. В результате необязательные параметры поддерживаются по умолчанию в JaveScript, но в typescript это не так.",
            "Каждый вызов функции в TypeScript проверяется компилятором, и выдается ошибка, когда функция указывает другое количество параметров, чем количество аргументов, или когда, альтернативно, типы аргументов не соответствуют типам параметров функции. Мы используем “?” после имени параметра, чтобы сделать параметр функции необязательным. Так же, как и остальные параметры, необязательные параметры должны появляться после создания основных или требуемых параметров или ошибок.",
            " ",
            "      interface ICircle {",
            "      Radius: number;",
            "      Color?: string;",
            "      }",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как сделать все параметры интерфейса необязательными?",
        answer: [
            "Partial<T> можно использовать partial, чтобы сделать все (все) свойства необязательными..",
            "Имеем интерфейс в приложении:",
            "      interface Asset {",
            "            id: string;",
            "            internal_id: string;",
            "            usage: number;",
            "      }",
            " ",
            "Используем Partial<T> тип, который TypeScript предоставляет по умолчанию.",
            "      interface PostDraft {",
            "            asset: Partial<Asset>;",
            "      }",
            " ",
            "Теперь все свойства в asset являются необязательными, что позволит вам выполнить следующее:",
            "      const postDraft: PostDraft = {",
            "            asset: { id: 'some-id' }",
            "      };",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Разница между псевдонимами типов Type и Interface в TypeScript",
        answer: [
            "Смотри на ютубе.",
            "https://www.youtube.com/watch?v=hGdx0hpZsvs&list=PLdTPrJkdrLGGgSnXMsO-Rix3MTuySb_mF&index=2",
            "1. Interface всегда для описания объектов и функций, а Type, как для объектов - функций, так и для других различных сущностей. Функции в JavaScript являются объектами, разница лишь в том, их можно вызвать.",
            "Если мы рассмотрим вариант использования псевдонимов и интерфесов для объектов, то в ряде случаев они взаимно заменяемы:",
            "      interface Interface1 {",
            "            name: string;",
            "      }",
            " ",
            "      type Type1 = {",
            "            name: string;",
            "      }",
            "В данном случае нет особой разницы, что использовать. Оба эти варианта подходят.",
            " ",
            "Однако, если мы будем говорить не об объектах, а о других сущностях, то тут не всё так однозначно. Для таких случаев мы должны использовать Type. Вот пара примеров:",
            " ",
            "      type Type2 = (prop: string) => string; // функция",
            "      type Type3 = string; // примитив ",
            " ",
            "Рассмотрим описание функции, которая принимает и возвращает number через тип:",
            " ",
            "      type SumB = {",
            "            a: number,",
            "            b: number",
            "      } => number; // описание",
            " ",
            "      const sum: SumB = ( a, b ) => a + b ; // функция",
            " ",
            "То же, но через интерфейс: ",
            " ",
            "      interface SumA {",
            "            a: number,",
            "            b: number",
            "      } => number; // описание",
            " ",
            "const sum: SumA = ( a, b ) => a + b ;",
            "",
            "2. Расширение (extends) interface. Для interface существует такая функциональность, как расширение. interface может наследоваться как от interface, так и от типа.",
            "Type не связан с ООП, ни о каком наследовании, расширении не идёт речь.",
            "Представим простой interface Animal, который будет обозначать животного:",
            " ",
            "      interface Animal {",
            "            name: string;",
            "      }",
            " ",
            "У объекта, который реализует этот interface будет одно свойство - name.",
            " ",
            "Теперь рассмотрим расширение данного interface.",
            " ",
            "      interface Dog extends Animal {",
            "            bark: () => void;",
            "      }",
            " ",
            "В данном случае мы создаём Interface Dog, который создаёт более конкретный тип животных - собак. И в нём мы реализуем метод bark - лай. Поскольку не все животные лают, а только собаки, то этот метод - специфическое свойство.",
            " ",
            "И давайте используем этот interface для создания объекта:",
            " ",
            "      const dog: Dog = {",
            "            name: 'Бобик',",
            "            bark: () => console.log('Гав')",
            "      }",
            " ",
            "Как вы увидели из данного примера, interface имеет возможность создания повых interface на основе предыдущих.",
            " ",
            "3. Реализация interface. Поскольку interface - это сущность из ООП, то мы можем использовать её по назначению. Вот пример реализации:",
            "С помощью типа можно сделать псевдоним для примитива. Интерфейс не позволяет такого.",
            " ",
            "     type UniqueId = string;",
            " ",
            "Этот псевдоним можно использовать и в типах и в интерфейсах:",
            " ",
            "     interface Use {",
            "          id: UniqueId;",
            "     };",
            " ",
            "Ещё раз, псевдоним примитива можно сделать только при помощи типа, интерфейс тут не поможет.",
            "Но.... Если этот алиас не для примитива, а для массива, то мы можем здесь использовать интерфейс.",
            " ",
            "     type NamesA = string[];",
            "          interface NamesB {",
            "          [ key: number ]: string // плохая запись через интерфейс, непонятная...",
            "     }",
            " ",
            "4. Так же, через интерфейс невозможно сделать описание кортежа. ",
            "Кортеж, это массив определённого размера, длина которого не изменяется и выступает как константа в мире массивов.",
            " ",
            "     type State = [ number, (n: number)=> void ]",
            "      const s: State = [ 123, (n) => {} ]",
            " ",
            "5. Так же мы можем создать тип, который будет ",
            " ",
            "     type A = {",
            "          age: number;",
            "     }",
            " ",
            "     type B = {",
            "          name: string;",
            "     }",
            " ",
            "     type C = A | B;",
            " ",
            "Это значит, что можно создать объект с полем age: 22 или name: 's', или с обоими полями вместе. И тайпскрипт не будет ругаться на это.",
            " ",
            "     const obj: C = {",
            "          age: 22,",
            "          name: 's',",
            "     }",
            " ",
            "Итнерфейс для такого объекта написать невозможно, только псевдоним типа.",
            " ",
            "6. Невозможно написать один и тот же тип несколько раз:",
            " ",
            "     type A = {",
            "          age: number;",
            "     }",
            " ",
            "     type A = {} // error",
            " ",
            "А интерфейсы позволяют",
            " ",
            "     interface B {",
            "          name: string",
            "     }",
            " ",
            "     interface B {",
            "          age: number",
            "     }",
            " ",
            "И далее при создании объекта, typescript скажет, что нужны поля и  name: string и age: number",
            " ",
            "7. Так когда же использовать интерфейсы, а когда типы?",
            "Интерфейсы мы используем при описании доменной логики нашего приложения, а так же, например для объектов, которые приходят к нам по API. Функционального компонента в реакте.",
            "А типы мы используем для взаимодействия с этими интерфейсами, например у нас может быть интерфейс Nullable, это дженерик, который принимает тип. Он может быть null или undefined. И далее мы можем создавать типы или переменные на основе этих объектов, интерфесов и типов.",
            " ",
            "     interface User {",
            "          name: string;",
            "          age: number;",
            "     }",
            " ",
            "     type Nullable<T> = T | null | undefined;",
            " ",
            "Таким образом, интерфейс у нас будет отвечать за логику приложения, а типы будут описывать поведенческие моменты.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Разница между псвдонимом типа и интерфейсом в TypeScript: характеристики Type - псевдонима типа.",
        answer: [
            "1. Это набор типов данных.",
            "2. Типы более гибкие.",
            "3. Для создания нового псевдонима типа используется ключевое слово “type”.",
            "4. Он поддерживает создание нового имени для типа.",
            "5. У него меньше сравнительно меньших возможностей.",
            "6. Он не поддерживает использование объекта.",
            "7. Нельзя использовать несколько объединенных объявлений.",
            "8. Два типа с одинаковым именем вызывают исключение.",
            "9. У него нет целей реализации.",
            "10. Он не поддерживает функцию реализации или расширения типов объединения в классе.",
            "11. Можно создать тип пересечения, объединив несколько типов в один тип.",
            "12. Он также используется для таких типов, как примитивы, объединения и кортежи.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Разница между типом и интерфейсом в TypeScript: характеристики Interface ",
        answer: [
            "1. Это форма синтаксиса.",
            "2. Интерфейс менее гибкий по сравнению с типами typescript.",
            "3. Для объявления интерфейса используется ключевое слово “interface”.",
            "4. Он предоставляет способ определения сущностей.",
            "5. Он обладает сравнительно большими возможностями.",
            "6. Он поддерживает использование объекта.",
            "7. Можно использовать несколько объединенных объявлений.",
            "8. Два интерфейса с одинаковым именем объединяются.",
            "9. У него есть цель реализации.",
            "10. Он поддерживает реализацию и функцию расширения в typescript.",
            "11. Невозможно создать какой-либо новый интерфейс пересечения.",
            "12. Его нельзя использовать с другими типами объявлений.",
            "Вывод- Хотя оба типа Typescript и интерфейс отличаются некоторыми функциями, но оба они почти похожи, поэтому нельзя перестать использовать одно поверх другого. Разработчик может выбрать, какой typescript он / она хочет использовать.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Дженерики, или “Generic” Types, — обобщенные типы",
        answer: [
            "Суть дженериков 👉 — это всего лишь способ передать типы в компонент. Дженерики — переменные, через которые мы передаём тип. С помощью дженериков мы можем создавать компоненты, работающие не с одним, а с разными типами данных.",
            "Дженерики, или Generic Types — обобщенные типы. Они нужны для описания похожих, но отличающихся какими-то характеристиками структур типов. Мы описываем общую структуру, а конкретную уже определяет пользователь дженерика. Дженерик — это каркас, внутренности которого заполняет разработчик.",
            "Дженерики (generic) помогают писать универсальный, переиспользуемый код, а также в некоторых случаях позволяют отказаться от any. Главная задача дженериков — помочь разработчику писать код, который одинаково будет работать со значениями разных типов.",
            " ",
            "Обобщённый тип (обобщение, дженерик) позволяет резервировать место для типа, который будет заменён на конкретный, переданный пользователем, при вызове функции или метода, а также при работе с классами. ",
            "Обобщенные типы типов используются для создания многоразовых псевдонимов типов.",
            " ",
            "В документации TypeScript приводится следующее определение: 'дженерики — это возможность создавать компоненты, работающие не только с одним, а с несколькими типами данных'.",
            "Основная идея состоит в том, что дженерики позволяют нам создавать некие повторно используемые компоненты, работающие с различными типами передаваемых им данных.",
            " ",
            "Если мы напишем функцию и жёстко зададим тип, то она сможет работать только со значениями этого типа. Значения других типов передать не получится. Есть два способа это поправить.",
            "1. Написать несколько одинаковых функций, которые работают с разными типами.",
            "2. Объявляем в функции параметр типа, а потом передаём через него нужный тип.",
            " ",
            "     function include<T>(array: T[], query:T): boolean { // Т либо string, либо number",
            "          for (const value of array) {",
            "               if (value === query) {",
            "                    return true",
            "               }",
            "          }",
            "          return false;",
            "     }",
            " ",
            "Код функции не поменялся, но теперь мы не указываем конкретный тип. Мы заводим переменную T и говорим, что тип параметра array — это тип, который будет передан в переменную T. А тип параметра query — это тип, который будет передан через переменную T.",
            "Когда мы захотим воспользоваться этой функцией, то помимо данных для параметров array и query мы ещё должны передать информацию о типах (для переменной T). В первом примере мы передаём тип string, а во втором — number.",
            "Передаём string в качестве типа",
            " ",
            "     include<string>(['igor', 'sasha', 'ira'], 'ira'); // true",
            " ",
            "Передаём number в качестве типа",
            "     include<number>([1, 3, 5], 7); // false",
            " ",
            "Получается, что с помощью дженериков мы смогли написать код, который работает с разными типами значений. То есть, если коротко 👉 Дженерики — переменные, через которые мы передаём тип.",
            " ",
            "Для чего существуют обобщённые типы?",
            "При написании кода вы всегда встаёте перед выбором, имеющим как минимум две ветви решения. Первый путь приводит вас к копированию существующего кода с нужным вам типом, что также приводит к «распуханию» кода и необходимости думать при рефакторинге. Второй путь – унификация, что подразумевает под собой параметрический полиморфизм, в основе которого лежит использование одного и того же кода, но с разными типами. Получается, что обобщённые типы нужны для написания кода, который можно многократно использовать вне зависимости от типов.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Дженерики — обобщенные типы: соглашение именования через T, U и A. ",
        answer: [
            "Объявлена функция: ",
            " ",
            "      function identity<T>(arg: T): T {",
            "            return arg;",
            "      }",
            " ",
            "Здесь T – это некоторый параметр-тип T, который будет захвачен при вызове функции. Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T.",
            "Можно использовать любые буквы, которые вам хочется, но буквы на входе и выходе функции должны совпадать, если этого требует логика её работы. Так уж сложилось, что, если имеется единственный параметр-тип, то он получает имя T, но лишь в том случае, если это не нарушает общую ясность. При объявлении нескольких параметр-типов их имена записываются, чаще всего, как T, U и A, соответственно. Однако, существует и другое соглашение, поощряющее именование всех параметр-типов через T, но с применением уточнений, например, TKey, TKeyType или TValue. Официальная документация и разработчики языка придерживаются первого соглашения.",
            "",
            "Попробуем вызвать эту функцию с аргументом типа number и поверхностно проследим за тем, как компилятор определяет, что вернёт функция",
            " ",
            "      const value = identity<number>(115);",
            " ",
            "При вызове функции тип <number> заполняет обобщённый параметр T. В этот момент компилятор неявно подставляет вместо T переданный тип number и переходит к валидации типов переданных аргументов, а затем входит внутрь функции и валидирует её тело.",
            "Примечание: ",
            "Самое часто используемое в TypeScript обобщение – Promise<T>. Например, этот промис, возвращающий строку.",
            "      function a(): Promise<string> { return 'a' }",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Дженерики — обобщенные типы, примеры.",
        answer: [
            "Пример: ",
            "Представим, что нам с сервера приходит описание платежа из истории в формате:",
            " ",
            "      type PaymentInfo = {",
            "            id: string;",
            "            amount: number;",
            "            currency: string; // currencyArr = '₽' | '€' | '$';",
            "      }",
            " ",
            "Потом кто-то разработал новый сервис, который отдает информацию о переводах. И он стал передавать информацию в следующем виде:",
            " ",
            "      type NewPaymentInfo = {",
            "            id: string;",
            "            amount: number;",
            "            currency: number; // код валюты // currencyArr = 643 | 978 | 840;",
            "      }",
            " ",
            "Теперь нам приходит код валюты, а не ее буквенное обозначение. При этом на старые записи в истории мы все еще получаем строковый код. Чтобы не описывать разные типы и не создавать путаницу, можно объединить их в один обобщенный тип — дженерик:",
            " ",
            "      type PaymentInfo<T> = { // T — параметр дженерика",
            "            id: string;",
            "            amount: number;",
            "            currency: T; // «настраиваем» тип поля currency",
            "      }",
            " ",
            "      const paymentInfo: PaymentInfo<string> = // …наш объект",
            " ",
            "Можно указать типы параметров дженерика по умолчанию. Если не передать в такой дженерик параметр, то TypeScript возьмёт значение по умолчанию:",
            " ",
            "      type PaymentInfo<T = string> = { … } // T — по умолчанию тип string",
            " ",
            "      const paymentInfo: PaymentInfo = // … тип переменной — PaymentInfo<string>",
            " ",
            "Почему T? Так сложилось, что параметры дженериков именуют одной буквой (T означает Type), но вы без проблем можете написать не T, а Currency:",
            " ",
            "Интерфейсы тоже могут быть обобщёнными:",
            " ",
            "      interface PaymentInfo<T> {",
            "            id: string;",
            "            amount: number;",
            "            currency: T;",
            "      }",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Дженерики в TypeScript с нуля: Generic, Extends, Дефолтные Параметры. Урок от wise.js.",
        answer: [
            "1. Дженерик в TypeScript - это параметризованный тип, позволяющий объявлять параметры типа, являющиеся временной заменой конкретных монолитных типов, определение которых будет выполнено в момент использования. Дженерики в TypeScript объявляются при помощи пары угловых скобок, в которые через запятую записываются типы  <T, U, A>. Количество типов неограниченно, их может быть сколько угодно.",
            "- interface State <T, U, V, K> {}; ",
            "Выше мы определили интерфейс State, который использует 4 дженерик типа. Так же, дженерики можно использовать не только в интерфейсах, но и в типах. ",
            "- type State2 <T> = {}; ",
            "Так же в классах: ",
            "- class State3 <T> {};",
            "Так же в функциях: ",
            "- function state4 <T> () {}; ",
            "2. Ведут себя дженерики везде абсолютно одинаково, то есть правила их использования идентичны. Для того, чтобы разобраться как работают дженерики, возьмём классический пример из документации.",
            "Допустим, у нас есть функция identity, которая принимает какой-то аргумент, и возвращает этот же аргумент. Мы видим, что это аргумент имеет тип any: ",
            "- function identity(arg: any) { ",
            "- return arg ",
            "} ",
            "Объявим переменные с разными типами: string и number:",
            "- const s: string ='Hello'; ",
            "- const n: number = 10; ",
            "Если мы вызовем identity() и передадим туда s, то в результате получим тип 'any'. ",
            "- const r1 = identity(s); // const r1: any.",
            "То же самое будет, если мы испоьзуем n. ",
            "- const r12 = identity(n); // const r2: any.",
            "Так как наша функция умеет работать с любыми типами, то здесь как раз подойдут дженерики. То есть, мы можем сказать, что функция identity<T>() работает с типом T (может быть любая другая буква или даже слово). Укажем, что аргумент, который прилетает в нашу функцию будет типа Т. При этом, принадлежность этого типа Т, устанавливается в момент передачи аргумента. То есть, если мы передаём в параметры 's: string' типом строка, то Т у нас тоже будет строка и вернётся нам тоже этот Т.",
            "- function identity<T>(arg: T): Т { ",
            "- return arg ",
            "} ",
            "Сейчас на подсветке видно, что мы передаём s типом строка и возвращается нам тоже строка r1: string: ",
            "- const r1 = identity(s: string); // const r1: string.",
            "Точно такая же ситуация с number. На подсветке видно, что мы передаём n: number и получаем r2: number: ",
            "- const r2 = identity(n: number); // const r2: number.",
            "При использовании дженериков тайпскрипт распознаёт типы переменных на лету, тем самым позволяет нам писать более универсальный код. ",
            "-*- ",
            "3. Создадим интерфейс User, на его основе создадим объект user: ",
            "interface User { ",
            "- name: string;",
            "- age: number ",
            "} ",
            "const user = { ",
            "- name: 'Max'; ",
            "- age: 27; ",
            "} ",
            "Вызовем нашу функцию в третий раз и r3 у нас будет тип User: ",
            "- const r3 = identity(user: User); // const r3: User.",
            "-*-",
            "4. Объявляем интерфейсы объектов, которые должны получить в качестве данных с сервера: ",
            "- interface User { ",
            "- name: string;",
            "- age: number ",
            "} ",
            "и ",
            "- interface Message { ",
            "- id: number;",
            "- text: string; ",
            "} ",
            "При загрузке объектов User и Message на сервер по API, для описания состояния загрузки, мы создадим два интерфейса, схожих в общих свойствах, отличие будет только в описании типа получаемых данных: ",
            "interface UserState {",
            "- loading: boolean; ",
            "- error: Error | null; ",
            "- data: User; ",
            "} ",
            "и ",
            "interface MessageState {",
            "- loading: boolean; ",
            "- error: Error | null; ",
            "- data: Message; ",
            "} ",
            "Однако, вместо того, чтобы создавать два похожих интерфейса, мы можем создать один интерфейс State. Указажем, что он будет дженерик и передадим его в поле data.   ",
            "interface State<T> {",
            "- loading: boolean; ",
            "- error: Error | null; ",
            "- data: T; ",
            "} ",
            "А дальше, если возникает необходимость создать UserState, мы можем создать просто тип UserState, указав, что это будет State<User>, где в качестве типа данных используем дженерик User. Аналогично и для MessageState. ",
            "- type UserState = State<User>;",
            "- type MessageState = State<Message>; ",
            "И теперь, если нам надо создать объект messageState, указываем, что тип у него будет MessageState: ",
            "const messageState: MessageState = { ",
            "- loading: false; ",
            "- error: null; ",
            "- data: {",
            "- - id: 1, ",
            "- - text: 'Text',",
            "}; ",
            "В принципе, дженерик можно рассмотреть, как функцию, которую мы вызываем с определённым типом, и она нам возвращает новую структуру с использованием переданного типа.",
            "-*- ",
            "4. Сейчас типизируем более сложное. Создадим функцию, которая будет возвращать элемент массива. Она будет принимать items. Далее генерируем случайный индекс: получаем рандомное число, умножаем его на длину массива, округляем до целого числа. Возвращать функция будет элемент массива с рандомным индексом. То есть, генерируем случайный индекс и берём элемент по этому индексу.",
            "- function getRandomElement(items) {",
            "- const randomIndex = Math.floor(Math.Random() * items.length); ",
            "- return items[randomIndex] ",
            "}; ",
            "Далее попробуем получить элемент из нашего массива. ",
            "const ell = getRandomElement([ 1, 2, 3, 4, 5 ]);  ",
            "Тайпскрипт говорит, что результат выполнения этой функции 'any'. С помощью дженерика, мы можем указать, что нам нужно передать тип Т, а items: T[] будет массив типа Т. Возвращать мы будем тоже тип Т.",
            "- function getRandomElement<T>(items: T[]): T {",
            "- const randomIndex = Math.floor(Math.Random() * items.length); ",
            "- return items[randomIndex] ",
            "}; ",
            "В таком случае тайпскрипт подскажет нам, что ell будет тип number, так как наш массив состоит из чисел. Если в массив будут передаваться строки, то ell будет тип string.",
            "- const ell2 = getRandomElement([ 'a', 'b', 'c ]);  ",
            "Если в массив будут передаваться числа, строки и null, тайпскрипт и это учтёт. ",
            "- const ell3 = getRandomElement([ 'a', 'b', 'c , 4, 5, null ]);  ",
            "-// const ell3: string | number | null. ",
            "* А если бы мы вместо дженерика T использовали 'any', то у нас бы не было никаких подсказок. Тайпскрипт бы не ругался, но мы бы не знали, что нам возвращается. ",
            "-*-",
            "5. Ещё один пример с объектами. Допустим, у нас есть функция merge(), которая принимает объекты о1, о2 и возвращает эти два объекта смёрженные. То есть копирует все свойства о1, о2 в объект и возвращает его. ",
            "function merge(o1, o2) {",
            "- return {",
            "- - ...o1, ",
            "- - ...o2 ",
            "- }",
            "} ",
            "Далее попробуем вызвать эту функцию на объекте, тайпскрипт скажет нам, что и a, и b, и r1 будут типа 'any', потому, как мы не указали никаких типов: ",
            "- const r1 = merge({ a: 1}, { b: 2 }); // тайпскрипт нам подсветит: const r1: any ",
            "Но нам надо, чтобы тайпскрипт распознавал типы на лету. Для этого мы будем использовать дженерик U и V, и он уже сам знает, что возвращает объединение U и V. ",
            "function merge<U, V>( o1: U, o2: V ) {",
            "- return {",
            "- - ...o1, ",
            "- - ...o2 ",
            "- }",
            "} ",
            "- const r1 = merge({ a: 1}, { b: 2 });",
            "Тайпскрипт подсветит нам, что у возвращаемого объекта тип объединения: ",
            "- const r1: { a: number } & { b: number }",
            "Во втором случае добавим входные параметры  c: 'lol':",
            "- const r2 = merge({ a: 1, c: 'lol' }, { b: 2 });",
            "И получим новый тип объединения: ",
            "- const r2: { a: number, c: string } & { b: number }",
            "-*-",
            "6.1. В тайпскрипт существует много встроенных дженериков. Например, самый популярный это промис. ",
            "Создадим асинхронную функцию, которая независимо от того, что она вернёт, вернёт промис. Асинхронные функции всегда возвращают промис. ",
            "async function fakeRequest(){ ",
            "- return 2; ",
            "} ",
            "Если мы запишем переменную b: number и укажем, что там тип number и сделаем вызов функции fakeRequest() в эту переменную без await, то мы увидим, что Promise<number> . То есть, нельзя записать b: number, так как функция всегда вернёт промис.",
            "- const b: number = fakeRequest(); // неверно ",
            "Поэтому нам нужно использовать дженерик.",
            "- const b: Promise<number> = fakeRequest()  // Таким образом всё будет работать верно. ",
            "Здесь, так как мы используем дженерик как тип, мы должны явно указать, какой тип в этом будет использоваться. Или, например, дженерик для массива. ",
            "-*-",
            "6.2. Мы можем создать тип Names, это будет массив строк ",
            "- type Names = string[]; ",
            "или  ",
            "- type Names = Array<string>; ",
            "-*-",
            "6.3. Так же существует дженерик для создания объекта. Например, создаём тип объекта, у которого ключи будут строками, а значения - числами: ",
            "type Obj = {",
            " - [key: string]: number ",
            "}; ",
            "Чтобы не делать такую запись, мы можем использовать встроенный дженерик и указать, что ключи будут строки, а значения - числа:",
            "- type Obj = Record<string, number> ",
            "И мы получим то же самое: ",
            "type Obj = {",
            " - [x: string]: number ",
            "}; ",
            "-*-",
            "6.4. Помимо того, что в Дженериках параметры можно указывать в качестве конкретного типа, они также могут расширять другие типы, в том числе и другие параметры типа. Такой механизм требуется для ограничения наборов обязательных признаков для выполнения операции. Разберём простой пример:      ",
            "Функция len принимает массивоподобный объект и возвращает его длину. ",
            "function len(collection) { ",
            "- return collection.length ",
            "} ",
            "Мы можем получить длину у строки, у массива, но у числа её получить не можем. ",
            "- const r1 = len('hello'); // r1 = 5 ",
            "- const r2 = len([ 1, 2, 3 ]) ",
            "- const r3 = len(3) // Error ",
            "С помощью дженерика, мы можем указать, что наша коллекция будет ограничена (extends) только теми структурами данных, у которых есть свойство length: number и оно (свойство length) является типа number. То есть строка и массив подходят, а число не подходит. ",
            "function len<T extends { length: number} >(collection) { ",
            "- return collection.length ",
            "} ",
            "-*- ",
            "6.5. У нас есть класс DataCollection, и он у нас умеет работать с разными коллекциями. Например, у него есть конструктор, который создаёт публичное свойство data: any[] (для начала any[]). И у него есть метод search (сёрч), который выполняет поиск по id. ID у нас всегда строка, и допустим, всё что он делает - это this.data.find(d => d.id === id).     ",
            "class DataCollection {",
            "- constructor(public data: any[] {}) ",
            "- search(id: string) {",
            "- - return this.data.find(d => d.id === id) ",
            "- }",
            "} ",
            "Этот класс DataCollection мы можем использовать, например с юзерами:  ",
            "- const users = new DataCollection([",
            "- {",
            "- id: ",
            "- } ",
            "]) ",
            "или с сообщениями:",
            "- const messages = new DataCollection([",
            "- {",
            "- id:, ",
            "- text: 'Message', ",
            "- } ",
            "]) ",
            "Но при этом у нас нет никаких подсказок и мы видим, что users и messages это просто тип DataCollection. Даже, если у нас не будет свойства id, то тайпскрипт не поругается, так как он не знает, что мы работаем с id. Но код без id работать не будет. ",
            "- const users: DataCollection и const messages: DataCollection. ",
            "Если ",
            "Для того, чтобы работать с разными структурами данных мы можем здесь использовать дженерик: ",
            "class DataCollection<T> {",
            "- constructor(public data: T[] {}) ",
            "- search(id: string) {",
            "- - return this.data.find(d => d.id === id) ",
            "- }",
            "} ",
            "и теперь, если мы будем работать без id, мы увидим ошибку, что id у нас нет:",
            "- const messages = new DataCollection([",
            "- {",
            "- text: 'Message', ",
            "- } ",
            "]) ",
            "// Property 'id' does not exist on type 'T' ",
            "Так как users и messages имеют разные типы, давайте их опишем:  ",
            "type User = { ",
            "- id: string, ",
            "- name: string, ",
            "} ",
            "type Message = {",
            "- id: string, ",
            "- text: string,",
            "} ",
            "То есть мы имеем различные типы, но из общего мы можем определить id. Таким образом мы можем сказать, что DataCollection работает с любой структурой данных, у которой есть свойство id: string и оно тип строка, примерно так: <T extends { id: string }>.  ",
            "class DataCollection<T extends { id: string }> {",
            "- constructor(public data: T[] {}) ",
            "- search(id: string) {",
            "- - return this.data.find(d => d.id === id) ",
            "- }",
            "} ",
            "-*- ",
            "6.6.1. Нам нужно просто получать свойство из объекта ",
            "function getValue(obj, prop) {",
            "- return obj[prop] ",
            "} ",
            "Попробуем вызвать getValue, передадим туда объект. Например у него будет name: 'Max' и получим свойство age.  ",
            "const r1 = getValue({  ",
            "- name: 'Max' ",
            "}, 'age') // const r1: any ",
            "- getValue(obj: any, prop: any ): any ",
            "У нас такого свойства нет, но мы видим, что тайпскрипт у нас указывает на то, что мне вернётся any, и ты там сам разбирайся, что с ним делать. ",
            "Используя дженерик мы можем определить тип объекта, который нам приходит и указать, что он должен быть extends только объект. То есть другого ничего передавать туда нельзя. ",
            "function getValue<T extends object>(obj: T, prop) {",
            "- return obj[prop] ",
            "} ",
            "Таким образом, если мы передадим в getValue() строку, то тайпскрипт будет ругаться, будет говорить, что нельзя передать строку",
            "- const r1 = getValue('s', 'age') ",
            "// Аргумент типа 'string' нельзя передавать в параметр, у которого тип 'object'.",
            "С помощью extends мы ограничиваем набор типов которые могут быть переданы в эту функцию. ",
            "-*- ",
            "6.6.2. Укажем здесь в дженерике второй тип U. Так же укажем, что второй аргумент будет иметь тип U, а U будет ограничен ключами Т. Extends в этом случае, знает, что, в переменную Т можеть быть записано только то, что может быть записано в объект. А в U может быть записано только то, что является ключом Т (ти), то есть нашего объекта. Поэтому здесь мы можем указать только 'name', так как у нас только один ключ 'name'.   ",
            "function getValue<T extends object, U extends keyof T>(obj: T, prop: U) {",
            "- return obj[prop] ",
            "} ",
            " ",
            "const r1 = getValue({  ",
            "- name: 'Max' ",
            "}, 'name') ",
            "Если же у нас будет больше ключей, то мы можем указать и 'name' и 'age' ",
            "const r1 = getValue({  ",
            "- name: 'Max' ",
            "- age: 26 ",
            "}, 'name', 'age') ",
            "-*- ",
            "7.  ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Литеральные типы",
        answer: [
            "Сегодня в TypeScript доступны три набора литеральных типов: строки, числа и булевы.",
            "Литеральные типы в Typescript позволяют нам указать точное, конкретное значение строк, чисел и логических значений, которые может быть присвоено переменной. ",
            " ",
            "1. Объявим переменную C, которая будет равна 'test':  ",
            " ",
            "      let C: string = 'test'; // Переменная С у нас имеет тип string. ",
            " ",
            "Но мы можем сказать, что переменная С может иметь значение только 'test':",
            " ",
            "      let C: 'test' = 'test'; // Переменная С может быть только test.",
            " ",
            "Это и есть литеральный тип. Мы установили, что переменная С может иметь только одно значение: 'test'. Мы не можем написать teste, testa. Ничего другого, только test. ",
            " ",
            "2. Объявим тип экшен, который может принимать либо 'up' либо 'down'. С помощью экшена мы можем перемещаться либо вверх, либо вниз. Теперь видно, что экшен может быть всего 2-х типов.",
            " ",
            "      type actionType = 'up' | 'down' ",
            " ",
            "Создадим функцию, которая принимает в себя (action: actionType). И, когда мы будем делать switch по этому экшену, мы увидим, что case может быть только либо 'up', либо 'down'. То есть, мы ограничиваем наборы действий по этому экшену. Немного напоминает enum. ",
            " ",
            "      function performAction(action: actionType) {",
            "            switch (action) {",
            "                  case 'up': ... ",
            "                  case 'down': ... ",
            "            }",
            "      }",
            " ",
            "То есть, фактически, мы ограничили строковый выход этого типа или строковый вход этого типа конкретными значениями. Это и есть литеральные значения.",
            " ",
            "3. То же самое мы можем сказать, что данная функция будет возвращать литеральный тип нумерический. Это означает, что она вернёт нам либо -1 либо 1. ",
            " ",
            "      function performAction(action: actionType): -1 | 1 {",
            "            switch (action) {",
            "                  case 'up': ",
            "                        return -1 ",
            "                  case 'down': ",
            "                         return 1 ",
            "          }",
            "      }",
            " ",
            "Тем самым мы обозначили, что принимаем литеральный строковый тип action, а возвращаем литеральный нумерический тип: только -1 либо 1.",
            " ",
            "4. Литеральные типы могут быть скомбинированны с обычными интерфейсами.",
            " ",
            "      function performAction(action: actionType | ComplexAction) {",
            "            switch (action) {",
            "                  case 'up': ",
            "                        return -1 ",
            "                  case 'down': ",
            "                        return 1 ",
            "            }",
            "      }",
            " ",
            "      interface ComplexAction {",
            "            s: string;",
            "      };",
            " ",
            "Литеральные типы немного напоминают enum.",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Литеральные типы, объединения литеральных типов в TypeScript.",
        answer: [
            "1. Литеральные типы в Typescript - это более конкретные типы строк, чисел и логических значений.",
            " ",
            "      type Role = 'Admin';  ",
            " ",
            "Здесь тип Role имеет фиксированное значение Admin. Присвоить перменной с типом Role мы можем только значение Admin. Любое другое значение вызовет ошибку.",
            " ",
            "        const currentRole: Role = 'Admin'; ",
            "        console.log(currentRole); // Admin",
            "        const currentRole: Role = 'Amur'; ",
            "        console.log(currentRole); // Error",
            " ",
            "2. Так же в Typescript существуют объединения литеральных типов. Например, в типе Roles могут быть админ, модератор или юзер: ",
            " ",
            "        type Roles = 'Admin' | 'Moderator' | 'User' ; ",
            " ",
            "И тогда значением переменной currentRole с типом Roles может быть одно из этих значений, то есть 'Admin', 'Moderator' или 'User' .",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Оператор keyof используется в TypeScript для получения ключей любого типа.",
        answer: [
            "Допустим у нас есть интерфейс: ",
            " ",
            "      interface User {",
            "            name: string;",
            "            age: number;",
            "      }",
            " ",
            "Далее мы создадим тип UserKeys, используя оператор keyof над типом User: ",
            " ",
            "      type UserKeys = keyof User;",
            " ",
            "Далее, объявив переменную prop с типом UserKeys,",
            " ",
            "      let prop: UserKeys; // name, age",
            " ",
            "мы увидим, что записать в переменную можно только name или age. Никакое другое значение туда не подходит. Так как мы явно запросили ключи интерфейса User и переменная prop ограничена ими. Оператор keyof возвращает нам новый тип, который является объединением литеральных типов. По сути это аналог типа:",
            " ",
            "      type UserKeys = 'name' | 'age'. ",
            " ",
            "Только мы этот юнион прямо не прописываем, а генерим на лету с помощью тайпскрипт-оператора keyof. ",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Оператор typeof используется в TypeScript для получения типов.",
        answer: [
            "      const message = {",
            "            id: 1,",
            "            text: 'JavaScript', ",
            "      }",
            "      const t = typeof message",
            "      console.log(t); // object",
            " ",
            "Однако, если использовать typeof с типом (typeof message), то тайпскрипт сделает запрос: какой тип объекта message и сохранит его в тип MessageType. Расспознает его, и укажет что id у нас будет типа number, а text будет типа string. Ну и сам тип MessageType будет у нас объект. ",
            " ",
            "      type MessageType = typeof message; // тип MessageType возвращает нам тип объекта message.",
            " ",
            "Таким образом, с помощью typeof получаем тип MessageType",
            " ",
            "      type MessageType = {",
            "      id: number;",
            "      text: string;",
            "      }",
            " ",
            "Далее, основываясь на этом типе, мы можем создавать новое сообщения, например: ",
            " ",
            "      const userMessage: MessageType = {",
            "            id: 123,",
            "            text: 'Hi!',",
            "      }",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Используем операторы keyof и typeof в TypeScript вместе.",
        answer: [
            "Имеем объект message:",
            " ",
            "      const message = {",
            "            id: 1,",
            "            text: 'JavaScript', ",
            "      }",
            " ",
            "Тип MessageType = { id: number, text: string } возвращает нам тип объекта message.",
            " ",
            "      type MessageType = typeof message;",
            " ",
            "Получим ключи типа MessageType:",
            " ",
            "      type MessageKeys = keyof MessageType;",
            " ",
            "И мы видим, что MessageKeys = 'id' | 'text' - это объединение литеральных типов.",
            "Если мы добавим в объект новое поле:",
            " ",
            "      const message = {",
            "            id: 1,",
            "            text: 'JavaScript', ",
            "            postId: 12,",
            "      }",
            " ",
            "то оно добавится в набор типа  ",
            "      MessageKeys = 'id' | 'text' | 'postId' ",
            " ",
            "Этот приём широко используется в enum.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Используем keyof typeof в TypeScript с enum.",
        answer: [
            "Создаём enum (перечисление) цветов, которые будем использовать в нашем приложении:",
            " ",
            "      enum Colors {",
            "            white = '#fff',",
            "            black = '#000',",
            "      }",
            " ",
            "Необходимо определить тип, который будет указывать на доступные цвета:",
            " ",
            "      type AvailableColors = keyof typeof Colors; // то есть white или black.",
            " ",
            "Так как енам у нас это не тип, а объект, если мы переведём его в js, то typeof используем для распознования типа, а keyof для получения ключей этого типа и далее его использовать в переменной.",
            " ",
            "      let color: AvailableColors = 'black' // or 'white'. ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Пример использования keyof typeof в TypeScript с объектом formData.",
        answer: [
            "Имеем объект:",
            " ",
            "      const formData = {",
            "            firstName: 'John',",
            "            lastName: 'Doe', ",
            "            age: 30",
            "      }",
            " ",
            "Нам необходимо создать функцию, которая, на основе переданного объекта, будет возвращать ValidationResult (результат проверки). Этот ValidationResult должен включать в себя все поля, которые есть в нашем объекте и булевое значение, то есть true, есло оно валидно и false, если оно не валидно.",
            " ",
            "      interface ValidationResult {",
            "            firstName: boolean; ",
            "            lastName: boolean; ",
            "            age: boolean;",
            "      }",
            " ",
            "То есть наша функция  validate() должна уметь принимать любой объект и возвращать нам ValidationResult",
            " ",
            "      declare function validate<T>(data: T): ValidationResult;",
            " ",
            "И если вызовем функцию validate() на нашем объекте formData, то она нам вернёт ValidationResult.",
            " ",
            "      const r = validate(formData) ",
            " ",
            "Однако, если в объекте formData будет больше полей или они будут какие-то другие, а нам надо, чтобы они тоже попадали в наш интерфейс (или тип) ValidationResult. То есть, нам нужно знать, какие ключи есть в объекте formData, для того, чтобы их динамески добавить в наш ValidationResult. Мы можем  это сделать с помощью операторов typeof и keyof. Для этого мы создадим новый ValidationResult, ключи которого будут взяты из ключей типов объекта formData и все они будут булевого типа. ",
            " ",
            "      type ValidationResult = {",
            "            [key in keyof typeof formData]: boolean; //  и все они будут булевого типа",
            "      }",
            " ",
            "При динамическом добавлении новых полей в объект formData они у нас будут автоматически добавляться и в ValidationResult",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Пример использования keyof typeof с абсолютно любым объектом, используя Т.",
        answer: [
            "Чтобы не подвязываться под formData, мы можем наш тип ValidationResult вынести в функцию validate(). Здесь нет необходимости использовать formData, можно использовать просто Т",
            "Имеем объект:",
            " ",
            "      const formData = {",
            "            firstName: 'John',",
            "            lastName: 'Doe', ",
            "            age: 30",
            "      }",
            " ",
            "      declare function validate<T>(data: T): { [key in keyof Т ]: boolean };",
            " ",
            "Нам не нужен formData, используем просто Т. На не нужен typeof, так как в дженериках тайпскрипт сам распознает тип. Вызываем функцию validate() с текущим объектов в параметре: ",
            " ",
            "      const r = validate(formData)",
            " ",
            "И вот мы видим перечисление всех полей, основываясь на текущем объекте. ",
            "Так же можно явно указать, что это <typeof formData> и у нас ничто не поменяется. ",
            " ",
            "      const r = validate<typeof formData>(formData)",
            " ",
            "Но теперь наша функция validate() будет работать с абсолютно любым объектом и указывать его результат.  ",
            " ",
            "      const r2 = validate(timeData)",
        ],
        isParagraphBefore: true
    },
    // keyof typeof
    {
        heading: "Что такое утверждения типа в TypeScript?",
        answer: [
            "Утверждение типа - это информирование компилятора о типе переменной. Мы можем использовать утверждение типа, чтобы указать тип значения. Если нам надо изменить тип переменной, например, any или unknown на какой-то определенный тип, мы можем использовать утверждение типа. ",
            "В Typescript утверждение типа - это метод информирования компилятора о типе переменной. Вы можете использовать утверждение типа, чтобы указать тип значения и сказать компилятору не выводить его. Когда мы хотим изменить переменную с одного типа на другой, например, any на number и т.д., Мы используем утверждение типа.",
            "Мы можем либо использовать оператор угловые скобки  ‘<>’ , либо ключевое слово ‘as’ для выполнения утверждения типа. Когда мы переносим код из typescript на другой язык, в игру вступает утверждение типа. Поддержка во время выполнения поставляется с приведением типов, тогда как утверждение типа не влияет на время выполнения. Он используется компилятором.",
            " ",
            "Пример 1. Введите утверждение, используя синтаксис.",
            "В этом примере мы присваиваем строку ‘geeksforgeeks’ переменной неизвестного типа. Далее мы присваиваем значение строки другой переменной и вычисляем длину строки. В приведенном ниже коде мы утверждали, что str имеет тип number, используя ключевое слово “as”.",
            "      let str: unknown = 'geeksforgeeks';",
            "      console.log( str ); // geeksforgeeks",
            "      let len: number = ( str as string ).length;",
            "      console.log( len ); // 13",
            " ",
            "Пример 2. Введите утверждение, используя синтаксис ‘<>’ угловых скобок",
            "Этот пример похож на предыдущий, мы присваиваем число переменной типа any, а затем присваиваем значение другой переменной, и мы утверждаем, что переменная num имеет тип “Число”. Мы использовали <> угловые скобки вместо ключевых слов.",
            "      let num: any = 77;",
            "      // Преобразование из any в number",
            "      let num1 = <Number> num;",
            "      console.log( num1 ); // 77",
            "      console.log( typeof num1 ); // number",
            " ",
            "Пример 3. Утверждение типа для объектов",
            "Иногда мы можем столкнуться с обстоятельством, при котором объект определяется без каких-либо свойств. В результате этого компилятор выдает ошибку. Однако мы можем предотвратить эту проблему, используя утверждение типа. С помощью следующего примера мы можем это понять.",
            "      interface details {}",
            "      details.first_name = 'Sarah';",
            "      details.last_name = 'jane'; // error TS2693: 'details' относится только к типу, ",
            "                                                // но здесь используется как значение.",
            " ",
            "После определения параметров компилятор не выдает ошибку. Компилятор выдает ошибку в предыдущем примере, поскольку он не может найти какие-либо свойства внутри объекта. Утверждение типа помогает нам устранять такие ошибки. Мы использовали утверждение типа для деталей.",
            "      interface details {",
            "      first_name: string;",
            "      last_name: string;",
            "      }",
            "      let person_1 = <details>{};",
            "      person_1.first_name = 'Sarah';",
            "      person_1.last_name = 'jane';",
            "      console.log(person_1); // { first_name: 'Sarah', last_name: 'jane' }",
            "--",
            "Type assertion (утверждение типа) представляет модель преобразования значения переменной к определенному типу.",
            "Утверждение типа в TypeScript работает так же, как преобразование типов в JavaScript, но без проверки типов или реструктуризации данных. Утверждение типа не влияет на время выполнения и используется исключительно компилятором.",
            "Утверждение типа, по сути, представляет собой мягкую версию преобразования (приведения) типов, которая предлагает компилятору рассматривать переменную как определенный тип, но не принудительно вводит ее в эту форму, если она находится в другой форме.",
            "",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Утверждение типов в TypeScript. Type Assertion + as const. Wise.js.",
        answer: [
            "1. Зададим переменную, тип данных которой в будущем неизвестен:",
            "- let value: unknown;",
            "Потом явно определим переменной, что значение будет строкой:",
            "- value = 'Max'; ",
            "И попробуем поработать с переменной, как со строкой  и увидим ушибку, что переменная имеет неизвестный тип. ",
            "- const s = value.toUpperCase(); // object is of type unknown,",
            "Кампилятор не знает, есть ли этот метод у типа unknown. В этом случае, с помощью 'as' (type assertion) мы можем ему подсказать, что можно рассматривать этот тип данных, как строку: ",
            "- const s = (value as string).toUpperCase(); ",
            "С помощью as и указателя типа данных string, тайпскрипт понимает как интерпретировать это значение. ",
            "Существует ещё одна запись утверждения типа с помощью оператора треугольных скобок <>, в которых мы указываем тип.",
            "- const s = <string>value.toUpperCase(); ",
            "Эти две записи обсолютно аналогичны, и ничем не отличаются. Единственно, запись с треугольными скобками <>, как утверждение типа, нельзя использовать в примерах с jsx, в Реакте. Так как парсер будет ихневерно распознавать. ",
            "Утверждение типов в тайпскрипт аналогично приведению к типам в других языках программирования. Однако, в отличие от них, утверждение типов просто позволяют кампилятору знать тип переменной.   ",
            "-*-",
            "2. Рассмотрим другой пример: ",
            "Объявим интерфейс ",
            "interface UserData { ",
            "- name: string;",
            "- age: number;",
            "}",
            "Далее объявим объект, тип которого должен быть UserData ",
            "- const user: UserData = {}",
            "У нас появится ошибка об отсутствии свойств name и age. Тайпскрипт будет хотеть, чтобы мы сразу здесь указали эти свойства. Но, например, эти свойства у нас в программе указываются позже, они как-то высчитываются или запрашиваются по API. Но мы их просто укажем ниже:",
            "- user.name = 'Max'; ",
            "- user.age = 32; ",
            "Ошибка всё равно не исчезает, так как тайпскрипт знает, что здесь не хватает полей. Поэтому мы можем указать, что пустой объект стоит рассматривать как UserDate.",
            "- const user: UserData = {} as UserData.",
            "Таким образом интерпритатор поймёт, что эти свойства, возможно будут добавлены позже или вообще не будут добавлены. То есть утвердит объект, как данный тип данных.",
            "Так же можно использовать запись с треугольными скобками <> перед пустым объектом.",
            "- const user: UserData = <UserData>{}; ",
            "Однако, если тип, который мы попытаемся преобразовать, несовместим с преобразуемым типом, ",
            "- const user: UserData = <UserData>{ ",
            "- prop: null; ",
            "} ",
            "// например, мы здесь попытаемся написать свойство prop со значением null. То в процессе утверждения у нас возникнет ошибка. И тайпскрипт нам скажет, что prop: null не может быть записан в UserData.",
            "-*-",
            "3. Утверждения типа можно использовать так же в преобразовании данных.",
            "Создадим объект person:",
            "const person = {",
            "- name: 'Alex',",
            "- surname: 'Moren', ",
            "}",
            "И получим ключи этого объекта с помощью метода Object.keys(). TypeScript укажет, что это будет массив строк.",
            "- const keys = Object.keys(person); // const keys: string[] (массив строк)",
            "Однако, с помощью type assertion (утверждение типа) можно подсказать, что на самом деле, это будет массив ключей типа person.",
            "- const keys = Object.keys(person) as Array<keyof typeof person>;",
            "И в этом случае тайпскрипт скажет, что в этом случае может быть только name или surname: // const keys: ('name' | 'surname')[]. В дальнейшем, перебирая эти ключи, мы можем получать значения из person.",
            "А если бы этого утверждение типа не было, то была бы ошибка о том, что здесь у нас неизвестгый ключ и его может не быть в нашем объекте. С указанием типа всё работает хорошо.",
            "-*-",
            "Для полной картины смотри видео: Утверждение типов в TypeScript. Type Assertion + as const.",
            "https://www.youtube.com/watch?v=sQaSoKZOQjM&list=PLdTPrJkdrLGGgSnXMsO-Rix3MTuySb_mF&index=6",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Операторы ‘as’ и ‘<>’. Type assertion (утверждение типа) - преобразование к типу.",
        answer: [
            "Операторы ‘as’ и ‘<>’ - это утверждение типа в TypeScript, которое указывает компилятору рассматривать объект как другой тип, отличный от того типа, к которому компилятор относит объект.",
            "Type assertion (утверждение типа) представляет модель преобразования значения переменной к определенному типу.",
            "Предположим, у вас есть два типа: первый и второй. Вы пишете метод, и метод точно не знает, к какому типу будет принадлежать ваш объект. Это может быть тип первый или второй.",
            "Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, any или union, которые по факту допускают значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу.",
            "В качестве примера возьмем простейшую задачу: есть переменная значением строкового типа account = '123'. Для математических вычислений, нам необходимо преобразовать тип из строкового в числовой. ",
            "Есть разные способы для решения этой проблемы, и одним из них является приведение типов с помощью type assertion.",
            "Есть две формы приведения: ",
            "1. Использование угловых скобок <>. Перед значением, в угловых скобках, указывается тип, к которому надо выполнить приведение.",
            "let account = '123';",
            "let numberAccount= <number>account;",
            "--",
            "2. Использование оператора ‘as’ , после которого указывается тип, к которому надо выполнить преобразование:",
            "let account= '123';",
            "let numberAccount= account as number;",
            "",
        ],
        isParagraphBefore: true
    },
    // утверждения типа
    // Утилита
    {
        heading: "Встроенные служебные типы в TypeScript - утилиты (TypeScript Utility Types).",
        answer: [
            "Утилиты в TypeScript предоставляют собой набор встроенных generic типов, которые помогают нам манипулировать типами. Утилиты можно использовать для облегчения преобразований общего типа. Эти утилиты доступны глобально.",
            "Наиболее часто используемые типы утилит для преобразования типов TypeScript: ",
            "1. Awaited<T> используется для получения типа, который будет возвращен из асинхронной функции; для получения типа результата выполнения промиса.",
            "2. Partial<T> - делает все свойства объекта типа T необязательными.",
            "3. Required<T> - делает все свойства объекта типа T обязательными (она является противоположностью утилиты Partial).",
            "4. Readonly<T> - делает все свойства объекта типа T обязательными и доступными только для чтения (readonly), как бы указывая каждому его свойству ключевое слово readonly. Такие свойства являются иммутабельными (их значения нельзя изменить, переназначить). Используя эту утилиту, мы в некоторой степени замораживаем объект, чтобы предотвратить редактирование.",
            "5. Record<Keys, Type> - создает тип, который является записью с ключами, определенными в первом параметре, и значениями типа, определенного во втором параметре.",
            "6. Pick<Type, Keys> - предназначен для фильтрации ключей объекта. Pick Выбирает только указанные свойства Keys из исходного объектного типа Type. Эта утилита позволяет создать новый тип посредством извлечения из Type набора (множества) свойств Keys (Keys — строковый литерал или их объединение).",
            "7. Omit<Type, Keys> - Данная утилита создает новый тип, выбирая свойства из исходного типа Type, исключая из него набор свойств Keys (Keys — строковый литерал или их объединение) (она является противоположностью утилиты Pick).",
            "8. Exclude<UnionType, ExcludedMembers> - создает тип из первого аргумента (UnionType), исключая из него все типы, которые передаются вторым аргументом (ExcludedMembers).",
            "9. Extract<Type, Union> утилита создаёт тип из тех свойств двух аргументов (Type и Union), которые присутствуют в обоих аргументах. Это можно представить как пересечение двух типов. Это может быть полезно в тех случаях, когда вы хотите найти общую базу двух типов.",
            "10. NonNullable<Type> - это простой способ исключить значения null и undefined из значений в типе Type.",
            "-*-",
            "Есть несколько других, которые существуют, но не часто используются:",
            "11. Parameters<Type> - извлекает типы используемых параметров функции Type и создает из них новый тип на основе кортежа (tuple).",
            "12. ConstructorParameters<Type> - извлекает типы аргументов конструктора Type.",
            "13. ReturnType<Type> - извлекает тип значения, возвращаемого функцией Type.",
            "14. InstanceType<Type> - извлекает тип экземпляра класса Type.",
            "15. Утилита для внутренней манипуляции строками Uppercase<StringType>.",
            "16. Утилита для внутренней манипуляции строками Lowercase<StringType>.",
            "17. Утилита для внутренней манипуляции строками Capitalize<StringType>.",
            "18. Утилита для внутренней манипуляции строками  Uncapitalize<StringType>.",
            "19. ThisParameterType<Type> - извлекает тип this из функции Type.",
            "20. OmitThisParameter<Type> - определяет функцию без типа this.",
            "21. ThisType<Type> - добавляет тип this к функции Type.",
            "-*-",
            "Большинство из этого не пригодится в реальной работе",
        ],
        isParagraphBefore: true
    },
    {
        heading: "1. Утилита Awaited<T>.",
        answer: [
            "Awaited<T> используется для получения типа, который будет возвращен из асинхронной функции, для получения типа результата выполнения промиса.",
            " ",
            "      async function getData(): Promise<string> { ",
            "            return 'hello'; ",
            "      } ",
            " ",
            "      let awaitedData: Awaited<ReturnType<typeof getData>>; // let awaitedData: string",
            " ",
            "Tеперь awaitedData может быть 'hello' ",
            "Это новый тип позволяет имитировать операцию await в async функциях, но с точки зрения типов: ",
            " ",
            "      type A = Awaited<Promise<string>>; ",
            "      // Тип A - string ",
            " ",
            "Более того, мы можем использовать его с несколькими Promise:",
            " ",
            "      type A = Awaited<Promise<Promise<string>>>; ",
            "      // Тип A - string ",
            " ",
            "Таким образом он позволяет вытащить из Promise возвращаемый тип. ",
            " ",
            "2. Использование вместе с ReturnType. Служебный тип ReturnType позволяет получить тип, возвращаемый функцией. Теперь представим, что у нас есть сторонняя библиотека, которая даёт нам функцию getData(), но нам неизвестен тип IMyData.",
            " ",
            "      import axios from 'axios'; ",
            " ",
            "      interface IMyData {} ",
            " ",
            "      export async function getData(): Promise<IMyData> { ",
            "            const { data } = await axios.get<IMyData>(''); ",
            "            return data;",
            "      } ",
            " ",
            "Как нам получить тип IMyData? С помощью Awaited мы можем сделать следующую запись: ",
            " ",
            "      type IMyData = Awaited<ReturnType<typeof getData>>; ",
            " ",
            "3. Улучшенная типизация. Так же иногда встречается кейс, где мы хотим вернуть сложный объект, например массив, где его элемент асинхронная функция, к которой применяется await:",
            " ",
            "      async function getArray<T>(x: T): Promise<Awaited<T>[]> { ",
            "            return [await x]; ",
            "      } ",
            " ",
            "В старых версиях мы могли бы видеть следующую типизацию: ",
            " ",
            "      async function getArray2<T>(x: T): Promise<T[]> { ",
            "            return [await x]; ",
            "      } ",
            " ",
            "Хотя эти записи эквивалентны мы фактически теряли информацию из типов, что с типом T происходил await внутри функции, что в некоторых случаях может быть полезно знать. ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "2. Утилита Partial<T>.",
        answer: [
            "Partial<T> - делает все свойства объекта типа T опциональными (необязательными).",
            " ",
            "Пример 1. Имеем тип BlogPost с обязательными полями:",
            " ",
            "      type BlogPost = {",
            "            title: string;",
            "            author: string;",
            "      }",
            " ",
            "Получим тип PartialBlogPost, у которого все поля необязательные, используя утилиту Утилита Partial<T> ",
            " ",
            "      type PartialBlogPost = Partial<BlogPost>;",
            " ",
            "      /* ",
            "      type PartialBlogPost = {",
            "            title?: string;",
            "            author?: string;",
            "      } ",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "3. Утилита Required<T>.",
        answer: [
            "Required<T> делает все свойства объекта типа T обязательными (она является противоположностью утилиты Partial).",
            "Пример 1: имеем interface Person с необязательными полями: ",
            " ",
            "      interface Person {",
            "            name?: string;",
            "            age?: number;",
            "      }",
            " ",
            "Объявим объект с обязательными полями используя утилиту Required: ",
            " ",
            "      let requiredPerson: Required<Person>;",
            " ",
            "Объект requiredPerson имеет тип:",
            " ",
            "      /* ",
            "      RequiredPerson {",
            "            name: string;",
            "            age: number; ",
            "      } ",
            "      */ ",
            " ",
            "Пример 2: у нас есть тип объекта type PartialBlogPost с необязательными полями: ",
            " ",
            "      type PartialBlogPost = {",
            "            title?: string;",
            "            author?: string;",
            "      }",
            " ",
            "Преобразуем тип PartialBlogPost в тип BlogPost с обязательными свойствами: ",
            " ",
            "      type BlogPost = Required<PartialBlogPost>;",
            " ",
            "Результатом преобразования получим тип:",
            " ",
            "      /*  ",
            "      type BlogPost {",
            "            title: string;",
            "            author: string;",
            "      } ",
            "      */ ",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "4. Утилита Readonly<T>.",
        answer: [
            "Readonly<T> - делает все свойства объекта типа T доступными только для чтения (readonly), как бы указывая каждому его свойству ключевое слово readonly. Такие свойства являются иммутабельными (их значения нельзя изменить, переназначить). Используя эту утилиту, мы в некоторой степени замораживаем объект, чтобы предотвратить редактирование.",
            "Пример 1: имеем тип BlogPost с необязательными полями:",
            " ",
            "      type BlogPost = {",
            "            title?: string;",
            "            author?: string;",
            "      }",
            " ",
            "Преобразуем тип BlogPost в тип ReadonlyBlogPost с необязательными полями, которые нельзя будет изменить, то есть доступными только для чтения. Преобразование типа сделаем с помощью утилиты readonly:",
            " ",
            "      type ReadonlyBlogPost = Readonly<BlogPost>;",
            " ",
            "/*  ",
            "      type ReadonlyBlogPost = {",
            "            readonly title?: string | undefined;",
            "            readonly author?: string | undefined;",
            "      }",
            " */ ",
            " ",
            "Пример 2: ",
            " ",
            "Объявляем тип User для объекта с полями:",
            " ",
            "      type User = {",
            "            name: string",
            "            password: string",
            "            addres: string",
            "            phone: string",
            "      }",
            " ",
            "Преобразуем тип User в тип ReadonlyUser с неизменными полями, доступными только чтения. Для этого обернём наша тип User в утилиту Readonly<T>",
            "      type ReadonlyUser = Readonly<User> ",
            " ",
            "В результате преобразования получаем тип ReadonlyUser с неизменными свойствами, доступными только чтения:",
            " ",
            "      type ReadonlyUser = {",
            "            readonly name: string",
            "            readonly password: string",
            "            readonly addres: string",
            "            readonly phone: string",
            "      }",
        ],
        isParagraphBefore: true
    },
    {
        heading: "5. Утилита Record<Keys, Type>.",
        answer: [
            "Предназначен для  динамического конструирования объектов на лету. Утилита принимает два параметра, первый из которых описывает тип ключей объекта, а второй - тип значения этого объекта. На выходе мы получаем map-тип из ключей, описанных нами первым аргументом, и значений описанных вторым аргументом. ",
            " ",
            "Record<Keys, Type> - создает новый объектный тип (object type), ключами которого являются Keys, а значениями свойств — Type. Если все типы имеют одинаковое значение, версия объявления Record будет немного более краткой и удобочитаемой, поскольку очевидно, что все они имеют один и тот же тип. Так же эта утилита так же может использоваться для сопоставления свойств одного типа с другим типом.",
            "Пример 1.",
            "Имеем строковый литерал Keys:",
            " ",
            "      type Keys = 'a' | 'b' | 'c';",
            " ",
            "Преобразуем его в тип объекта с численными значаниями:",
            " ",
            "      type RecordType = Record<Keys, number>;",
            " ",
            "Создаём объект: ",
            " ",
            "      let record: RecordType;",
            " ",
            "Наш тип RecordType:",
            "      /* ",
            "      type RecordType = { ",
            "            a: number; ",
            "            b: number; ",
            "            c: number; ",
            "      } ",
            "      */ ",
            " ",
            "Пример 2. Создаём интерфейс объекта через короткую запись, используя утилиту Record<Keys, Type>",
            "      type BlogPost = Record<'title'| 'author', string>",
            " ",
            "      /*  ",
            "      type BlogPost = {",
            "            title: string;",
            "            author: string",
            "      } ",
            "      */ ",
            " ",
            "3. Эта утилита так же может использоваться для сопоставления свойств одного типа с другим типом:",
            "Имеем два типа. Один тип описывает свойства объекта User: ",
            " ",
            "      type User = {",
            "            name: string;",
            "            password: string;",
            "            address: string;",
            "            phone: string;",
            "      } ",
            " ",
            "Второй тип имеет числовые значения идентификатора пользователей:",
            " ",
            "      type UserIds = 1000 | 1001 | 1002;",
            " ",
            "Создаём новый тип, сопоставляя свойства одного типа с другим типом:",
            " ",
            "      type UserMap = Record<UserIds, User>",
            " ",
            "      type UserMap = {",
            "            000: User;",
            "            1001: User;",
            "            1002: User;",
            "      } ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "6. Утилита Pick<Type, Keys>.",
        answer: [
            "Pick предназначен для фильтрации ключей объекта. Pick Выбирает только указанные свойства Keys из исходного объектного типа Type. Эта утилита позволяет создать новый тип посредством извлечения из Type набора (множества) свойств Keys (Keys — строковый литерал или их объединение).",
            " ",
            "Пример 1 : выбираем только поля 'x' | 'y' из объектного типа с тремя полями 'x' | 'y' | 'z'",
            "Исходный тип:",
            " ",
            "      type Point3d = {",
            "            x: number;",
            "            y: number;",
            "            z: number;",
            "      }",
            " ",
            "Создаём ноый тип объекта Point2d, преобразуя исходный тип Point3d с помощью утилиты Pick<Type, Keys>:",
            " ",
            "      type Point2d = Pick<Point3d, 'x' | 'y'>",
            " ",
            "      /* ",
            "      type Point2d = { ",
            "            x: number; ",
            "            y: number; ",
            "      } ",
            "      */ ",
            " ",
            "Пример 2. Создадим объектный тип с двумя свойствами, используя интерфейс объекта с четырьмя свойствами. ",
            "Имеем исходный тип объекта User ",
            " ",
            "      type User = {",
            "            name: string;",
            "            password: string;",
            "            address: string;",
            "            phone: string;",
            "      }",
            " ",
            "Используем утилиту Pick<Type, Keys>:",
            " ",
            "      type PickUser= Pick<User, 'name' | 'address'>; ",
            " ",
            "Из интерфейса User выбрали только два свойства: 'name' и 'address'.",
            "Получаем тип PickUser:",
            " ",
            "      /* ",
            "      type PickUser = {",
            "            name: string;",
            "            address: string;",
            "      }",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "7. Утилита  Omit<Type, Keys>.",
        answer: [
            "Данная утилита создает новый тип посредством исключения из Type набора свойств Keys (Keys — строковый литерал или их объединение) (она является противоположностью утилиты Pick):",
            "Пример 1: необходмо создать объект на основе этого интерфейса, исключив из него свойство 'age' за ненадобностью.",
            "У нас есть исходный интерфейс Person.",
            " ",
            "      interface Person {",
            "            name: string;",
            "            age: number;",
            "      }",
            " ",
            "Создаём объект, используя утилиту Omit<Type, Keys>.",
            " ",
            "      let omittedPerson: Omit<Person, 'age'>;",
            " ",
            "Теперь omittedPerson может быть { name: string; }",
            " ",
            "Пример 2. Из исходного типа исключаем свойства 'password' и 'phone', используя утилиту Omit<Type, Keys>.",
            "Имеем исходный тип объекта User ",
            " ",
            "      type User = {",
            "            name: string;",
            "            password: string;",
            "            address: string;",
            "            phone: string;",
            "      }",
            " ",
            "Используя утилиту Omit<Type, Keys> исключаем из типа свойства 'password' и 'phone'.",
            "      type OmitUser = Omit<User, 'password' | 'phone'>;",
            " ",
            "       /*",
            "      type OmitUser = {",
            "            name: string;",
            "            address: string;",
            "      }",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "8. Утилита  Exclude<UnionType, ExcludedMembers>.",
        answer: [
            "Создает тип из первого аргумента (UnionType), исключая из него все типы, которые передаются вторым аргументом (ExcludedMembers).",
            " ",
            "1-ый случай: ",
            " ",
            "      type T0 = Exclude< 'a' | 'b' | 'c' , 'a' >;",
            " ",
            "Первый аргумент - UnionType: 'a' | 'b' | 'c'.",
            "Второй аргумент - ExcludedMembers: 'a'.",
            "В первом случае, в UnionType у нас есть три типа: 'a', 'b', 'c'. Тип 'a' мы исключаем, потому, что он у нас идёт вторым аргументом и является исключенным членом.",
            " ",
            "      /* ",
            "      type T0 = 'b' | 'c' ",
            "      */ ",
            " ",
            "2-ой случай:",
            " ",
            "      type T1 = Exclude< 'a' | 'b' | 'c' , 'a' | 'b' >;",
            " ",
            "Первый аргумент - UnionType: 'a' | 'b' | 'c'.",
            "Второй аргумент ExcludedMembers: 'a' | 'b'.",
            "Во втором случае у нас остаётся только 'c', поскольку мы исключаем типы 'a' | 'b'. Они являются вторым аргументом и являются исключенными членами.",
            " ",
            "      /* ",
            "      type T1 = 'c' ",
            "      */ ",
            " ",
            "3-ий случай: ",
            " ",
            "      type T2 = Exclude< string | number | (() => void), Function >;",
            " ",
            "Первый аргумент - UnionType: string | number | (() => void).",
            "Второй аргумент - ExcludedMembers: Function",
            "В третъем случае, в UnionType у нас есть строка, число  и функция. Функцию мы убираем, остаются строка и число.",
            " ",
            "      /* ",
            "      type T2 = string | number",
            "      */ ",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "9. Утилита Extract<Type, Union>.",
        answer: [
            "Утилита создаёт тип из тех свойств двух аргументов (Type и Union), которые присутствуют в обоих аргументах. Это можно представить как пересечение двух типов. Это может быть полезно в тех случаях, когда вы хотите найти общую базу двух типов.",
            " ",
            "1-ый случай: ",
            " ",
            "      type T1 = Extract< 'a' | 'b' | 'c' , 'a' | 'f' >;",
            " ",
            "Первый аргумент - Type содержит три типа: 'a' | 'b' | 'c'.",
            "Второй аргумент - Union содержит два типа: 'a' | 'f' .",
            "В первом случае пересекается тип 'a'. .",
            " ",
            "      /* ",
            "      type T1 = 'a' ",
            "      */ ",
            " ",
            "2-ой случай:",
            " ",
            "      type T2 = Extract< string | number | (() => void), Function >;",
            " ",
            "Первый аргумент - Type: string | number | (() => void).",
            "Второй аргумент - Union: Function",
            "Во втором случае пересекается функция. ",
            " ",
            "      /* ",
            "      type T2 = () => void",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "10. Утилита NonNullable<Type>.",
        answer: [
            "NonNullable<Type> - это простой способ исключить значения null и undefined из значений в типе Type.",
            "Пример 1: ",
            " ",
            "      type T1 = string | number | undefined;",
            " ",
            "Исключаем из типа T1 значение undefined:",
            " ",
            "      type T01 = NonNullable<T1>; ",
            " ",
            "Получаем: ",
            " ",
            "      /* ",
            "      type T01 = string | number;",
            "      */ ",
            " ",
            "Пример 2: ",
            " ",
            "      type T2 = string[] | null | undefined;",
            " ",
            "Исключаем из типа T2 значения null | undefined:",
            " ",
            "      type T02 = NonNullable<T2>;",
            " ",
            "Получаем: ",
            " ",
            "      /* ",
            "      type T02 = string[]; ",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "11. Утилита Parameters<Type>.",
        answer: [
            "1. Parameters<Type> - извлекает типы из параметров функции Type и создает из них кортеж (tuple).",
            " ",
            "      const myFunction = (a: string, b: string) => { ",
            "            return a + b; ",
            "      } ",
            " ",
            "      type MyFunction = Parameters<typeof myFunction>; // type MyFunction = [a: string, b: string]",
            " ",
            "2. Parameters<Type> так же извлекает тип для каждого аргумента: ",
            " ",
            "      const myFunction = (a: string, b: string) => { ",
            "            return a + b; ",
            "      } ",
            " ",
            "      type aType = Parameters<typeof myFunction>[0]; // type aType = string",
            " ",
            "      type bType = Parameters<typeof myFunction>[1]; // type bType = string",
            " ",
            "Пример 1: необходимо получить типы параметров функции getInt():",
            " ",
            "      function getInt(id: number, n: string) {",
            "            return parseInt(n)",
            "      }",
            " ",
            "Создаём тип Input, состоящий из типов параметров функции:",
            " ",
            "      type Input = Parameters<typeof getInt>",
            " ",
            "Таким образом мы получим кортеж: ",
            "      /* ",
            "      type Input = [id: number, n: string]",
            "      */ ",
            " ",
            "Пример 2. Передаём в функцию массив параметров типа кортежа с помощью оператора «три точки». ",
            "У нас есть функция myFunction с двумя аргументами: a и b.",
            " ",
            "      const myFunction = (a: string, b: string) => {",
            "            return a + b;",
            "      }",
            " ",
            "Что бы запустить эту функцию, нам необходимо передать в неё аргументы. Один из способов: передать с помощью кортежа типов и оператора «три точки». Например:",
            " ",
            "      let passArray:[string, string] = [ 'Hello ', 'world!' ]",
            " ",
            "      console.log(myFunction(...passArray)); // Hello world!",
            " ",
            "Здесь мы определяем кортеж, который представляет собой просто [string, string]. Мы можем передать его в myFunction, удовлетворяя аргументы a и b.",
            " ",
            "Пример 3. Это прекрасно работает, но что, если аргументы в myFunction динамически меняются? Это более вероятно, если myFunction приходит из стороннего сценария. Тогда нам придется не только обновить нашу функцию, но и не забыть обновить тип кортежа, который мы передаем. Нам также важно будет знать, какой пакет типов находится в myFunction на этот случай и как он изменяется.",
            "Чтобы мы всегда могли использовать только валидные типы аргументов, независимо от их изменения, мы можем использовать утилиту Parameters для создания текущего, валидного типа. Утилита Parameters автоматически создаст кортеж типов аргументов функции:",
            " ",
            "      const myFunction = (a: string, b: string) => {",
            "            return a + b;",
            "      }",
            " ",
            "      type MyType = Parameters<typeof myFunction>;",
            " ",
            "Получаем кортеж типов:",
            "      /* ",
            "      type MyType = [a: string, b: string];",
            "      */ ",
            " ",
            "Это избавляет нас от хлопот при определении пользовательских типов, так как теперь мы можем передавать любой тип для myFunction, не опасаясь ошибки:",
            "Объявляем функцию myFunction:",
            " ",
            "      const myFunction = (a: string, b: string) => { ",
            "            return a + b;",
            "      };",
            " ",
            "Создаём кортеж из типов функции myFunction используя утилиту Parameter: ",
            " ",
            "      type MyType = [a: string, b: string];",
            " ",
            "Создаём массив значений параметров с типами myType для функции myFunction: ",
            " ",
            "      let myArray: myType = [ 'Hello ', 'world!' ];",
            " ",
            "Передаём параметры в функцию и вызываем её:",
            " ",
            "      console.log(myFunction(...myArray)); // Hello world!",
            " ",
            "Пример 4. Использование отдельного аргумента из пакета параметров с помощью типа Parameters<Type>.",
            "Утилита Parameter достаточно гибка и позволяет нам определять тип одного аргумента из всего набора. Например, если мы хотим предоставить для нашей функции myFunction тип только первого аргумента, мы можем сослаться на него как на элемент массива[0]. Полученное будет соответствовать типу 'a', но если мы нам нужен тип 'b', мы могли бы использовать массив[1]:",
            " ",
            "      type myType = Parameters<typeof myFunction>[0]",
            " ",
            "Получаем 'string'.",
            " ",
            "      type myType = Parameters<typeof myFunction>[1]",
            " ",
            "Получаем 'string'.",
            " ",
            "Таким образом, мы могли бы определить пользовательские типы для каждого аргумента, если это необходимо в нашем коде. Например, здесь мы определяем два пользовательских типа для первого и второго параметров функции и передаем их оба в нашу функцию:",
            " ",
            "      const myFunction = (a: string, b: string) => {",
            "            return a + b;",
            "      }",
            " ",
            "      type aType = Parameters<typeof myFunction>[0]",
            "      type bType = Parameters<typeof myFunction>[1]",
            " ",
            "      let a:aType = 'hello '",
            "      let b:bType = 'world'",
            " ",
            "      console.log(myFunction(a, b)); // Hello world!!!",
            " ",
            "Поскольку Parameters преобразует тип аргументов в новый тип, мы прямо в него можем передать функцию. Ниже будет создан тип [ a: string, b: number ]. Это менее полезно, чем получение параметров из конкретной функции, но в определенных ситуациях может пригодиться:",
            " ",
            "      type anotherType = Parameters<(a: string, b: number) => void>",
            " ",
            "      /* ",
            "      type anotherType = [a: string, b: number] ",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "12. Утилита ConstructorParameters<Type>.",
        answer: [
            "ConstructorParameters<Type> - извлекает типы аргументов конструктора Type.",
            " ",
            "      class Foo {",
            "            constructor(a: string, b: number) {}",
            "      }",
            " ",
            "      type FooConstructorParameters = ConstructorParameters<typeof Foo>;",
            " ",
            "Теперь FooConstructorParameters это [string, number]",
        ],
        isParagraphBefore: true
    },
    {
        heading: "13. Утилита ReturnType<Type>.",
        answer: [
            "ReturnType<Type> - извлекает тип возвращаемого значения функции Type.",
            " ",
            "      function foo(): string { ",
            "            return 'hello'; ",
            "      } ",
            " ",
            "      type FooReturnType = ReturnType<typeof foo>;",
            " ",
            "      /*",
            "      type FooReturnType = string ",
            "      */ ",
            " ",
            "Примеры: ",
            " ",
            "      function getUserInfo(id: number, name: string) { ",
            "            return `User ID: ${id}, User Name: ${name} `; ",
            "      } ",
            " ",
            "      type FuncReturnType = ReturnType<typeof getUserInfo>; ",
            "      /* ",
            "      type FuncReturnType = string ",
            "      */ ",
            " ",
            "      type T0 = ReturnType<(s: string) => void>; // type T0 = void ",
            " ",
            "      type T1 = ReturnType<any>;                        // type T0 = any ",
            " ",
            "      type T2 = ReturnType<never>;                      // type T2 = never ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "14. Утилита InstanceType<Type> - извлекает тип экземпляра класса Type.",
        answer: [
            "      class Foo { x: number }",
            " ",
            "      type FooInstance = InstanceType<typeof Foo>;",
            " ",
            "// type FooInstance = { x: number }",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "15. Утилита для внутренней манипуляции строками Uppercase<StringType>.",
        answer: [
            "Данная утилита конвертирует строковый литеральный тип в верхний регистр",
            " ",
            "      type Method = 'get' | 'post' | 'put' | 'delete'; ",
            "      type UppercaseMethod = Uppercase<Method>",
            "      /* ",
            "      type UppercaseMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "16. Утилита для внутренней манипуляции строками Lowercase<StringType>.",
        answer: [
            "Данная утилита конвертирует строковый литеральный тип в нижний регистр:",
            " ",
            "      type Method = 'GET' | 'POST' | 'PUT' | 'DELETE';",
            "      type LowercaseMethod = Lowercase<Method>",
            "      /* ",
            "      type LowercaseMethod = 'get' | 'post' | 'put' | 'delete';",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "17. Утилита для внутренней манипуляции строками Capitalize<StringType>.",
        answer: [
            "Данная утилита конвертирует первый символ строкового литерального типа в верхний регистр:",
            " ",
            "      type Method = 'get' | 'post' | 'put' | 'delete'; ",
            "      type CapitalizeMethod = Capitalize<Method>",
            "      /* ",
            "      type CapitalizeMethod = 'Get' | 'Post' | 'Put' | 'Delete';",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "18. Утилита для внутренней манипуляции строками  Uncapitalize<StringType>.",
        answer: [
            "Данная утилита конвертирует первый символ строкового литерального типа в нижний регистр:",
            " ",
            "      type Method = 'Get' | 'Post' | 'Put' | 'Delete';",
            "      type UncapitalizeMethod = Uncapitalize<Method>",
            "      /* ",
            "      type UncapitalizeMethod =  'get' | 'post' | 'put' | 'delete';",
            "      */ ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "19. Утилита ThisParameterType<Type> .",
        answer: [
            "ThisParameterType<Type> - извлекает тип this из функции Type.",
            "class Foo {",
            "- - x: number;",
            "- - method(this: this): void { }",
            "}",
            "type ThisType = ThisParameterType<Foo['method']>;",
            "// теперь ThisType это Foo",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "20. Утилита OmitThisParameter<Type>.",
        answer: [
            "OmitThisParameter<Type> - определяет функцию без типа this.",
            "class Foo {",
            "- - x: number;",
            "- - method(this: this): void { }",
            "}",
            "type MethodType = OmitThisParameter<Foo['method']>;",
            "// теперь MethodType это () => void",
            "-*-",
        ],
        isParagraphBefore: true
    },
    {
        heading: "21. Утилита ThisType<Type> .",
        answer: [
            "ThisType<Type> - добавляет тип this к функции Type.",
            "class Foo {",
            "- - x: number;",
            "- - method(): void { }",
            "}",
            "type MethodType = ThisType<Foo['method']>;",
            "// теперь MethodType это (this: Foo) => void",
            "-*-",
        ],
        isParagraphBefore: true
    },
    // Утилита
    {
        heading: "Типизация функций",
        answer: [
            "Функция — блок кода, который принимает входные значения и отдает выходные значения. Часто она может ничего не принимать и что-то отдавать или наоборот принимать аргументы и ничего не отдавать вызывая коллбэки внутри себя.",
            "В целом все что нам нужно понять, это то, что у функции почти всегда есть параметры и выходное значение.",
            "Соответственно, нам нужно типизировать входные и данные и данные которые нам функция отдает (выходные).",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое модули в TypeScript? ",
        answer: [
            "В TS, как и в ECMAScript2015, любой файл, содержащий import или export верхнего уровня (глобальный), считается модулем.",
            "Модули в TypeScript представляют собой набор связанных переменных, функций, классов и интерфейсов.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что делают модули TypeScript?",
        answer: [
            "- Определение модуля.",
            "В TS, как и в ECMAScript2015, любой файл, содержащий import или export верхнего уровня (глобальный), считается модулем.",
            "- Не модули.",
            "Спецификация JS определяет, что любой файл без import или export верхнего уровня является скриптом, а не модулем.",
            "Переменные и типы, объявленные в скрипте, являются глобальными (имеют глобальную область видимости), для объединения нескольких файлов на входе в один на выходе следует использовать либо настроку компилятора outFile, либо несколько элементов script в разметке (указанных в правильном порядке).",
            "Если у нас имеется файл, который не содержит import или export, но мы хотим, чтобы этот файл считался модулем, просто добавляем в него такую строку: export {}.",
            "",
            "- Модули в TS.",
            "Модули выполняются в собственной области видимости, а не в глобальной. Это означает, что переменные, функции, классы и т.д., объявленные в модуле, недоступны за пределами модуля до тех пор, пока они в явном виде не будут из него экспортированы. Кроме того, перед использованием экспортированных сущностей, их следует импортировать в соответствующий файл.",
            "По сути, мы не можем напрямую получить доступ к определенным модулем переменным, функциям, классам и интерфейсам извне модуля. Мы можем использовать ключевое слово export для создания модуля, а ключевое слово import - для включения модуля в другой модуль.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что отличает внутренний модуль от внешнего модуля? ",
        answer: [
            "Внутренний модуль.",
            "Внутренние модули содержат набор классов, интерфейсов, функций и переменных, которые вы можете экспортировать в другие модули. Внутренние модули были особенностью предыдущей итерации Typescript, и они группируют интерфейсы, функции, переменные и классы. Вы можете использовать ModuleDeclarations для определения названия и тела внутренних модулей.",
            "Внешний модуль.",
            "Вы можете скрыть внутренние инструкции определений модулей с помощью внешних модулей, позволяя видеть только методы и аргументы, связанные с определенной переменной.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как сделать так, чтобы переменные, функции, методы, классы, определенные в модуле, были доступны вне модуля?  ",
        answer: [
            "Необходимо сделать именованный export, если переменных, функций, методов, классов испольуемых вне модуля много.",
            "Если необходимо экспортировать только одно значение, то используем export default.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое архитектура Model-View-Controller (MVC)?",
        answer: [
            "Основным принципом MVC является разделение программы на три части:",
            "1. Модель, которая служит основой для базы данных.",
            "2. Контроллер, который регулирует взаимодействие между представлением и моделью.",
            "3. Представление (пользовательский интерфейс и презентация).",
            "Модель.",
            "Модели используются для описания бизнес-логики и формы данных. Помимо доступа к состояниям объектной модели и их хранения в базе данных, она сохраняет данные приложения. Он отвечает на запросы пользователей о считывании данных и также изменяет данные. При получении или публикации данных Модель взаимодействует с базой данных, получает запросы, связанные с базой данных, обрабатывает их, а затем отправляет результаты обратно пользователю через браузер.",
            "Вид.",
            "View - это пользовательский интерфейс, позволяющий пользователям получать доступ к ресурсам программы и отправлять запросы на сервер или серверную часть приложения. Как правило, пользователь может отправить запрос на доступ к определенным ресурсам, таким как определенная веб-страница, с помощью веб-браузера или мобильного приложения. Вы можете использовать инструменты и фреймворки, такие как Vue или React, или написать представление полностью в HTML.",
            "Контролер.",
            "Итак, что происходит, когда вы хотите запросить данные и получить ответ? Вам понадобится соответствующая бизнес-логика - алгоритм, который получает запрос пользователя, проверяет его или отправляет другому компоненту. Эта ответственность ложится на контролеров.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое ключевое слово “declare” в Typescript?",
        answer: [
            "Ключевое слово declare в TypeScript используется для внешнего объявления переменных или методов. Внешние объявления похожи на ключевое слово импорта. Которое сообщает компилятору, что исходный код существует в другом файле. Мы используем внешние объявления в TypeScript для использования сторонних библиотек JavaScript, jQuery, Node и т.д. ключевое слово declare напрямую интегрирует эти библиотеки в наш код и уменьшает вероятность ошибки в нашем коде TypeScript.",
            "Мы используем ключевое слово declare только в окружающем файле для использования метода libraries и переменных.",
            "Синтаксис:",
            "declare var Variable_Name;",
            "declare module Name_of_Module{// Body of module };",
            "Пример: Теперь давайте рассмотрим один пример: у нас есть один файл, который содержит некоторые полезные переменные, но файл написан на JavaScript. Таким образом, мы не можем сказать, что нам нужно написать некоторый код JavaScript в TypeScript, это отнимает столько времени, что нам приходится писать тот же код в TypeScript, но мы объявили ключевые слова, которые предоставляют функциональность для использования той же переменной в конце кода.",
            "Давайте предположим, что у нас есть сторонний код JavaScript, в котором есть переменная, содержащая значение некоторой переменной, но у нас нет значения, но с помощью ключевого слова declaring мы можем использовать значение переменной в нашем коде.",
            "Сторонний код:",
            "var pi_1 = 3.1415926535 ;",
            "var pi_2 = 3.14159265358979323846 ;",
            "Мы хотим использовать эту переменную в нашем коде, чтобы мы могли использовать их для объявления ключевого слова с тем же именем, и TypeScript не выдаст ошибку.",
            "Код TypeScript:",
            "declare var pi_1 : any ;",
            "console.log('Value of pi is :',pi_1) // Value of pi is: 3.1415926535",
            "--",
            "--",
            "Ключевое слово “declare” информирует компилятор о том, что указанный объект уже существует в будущем коде и на него может ссылаться другой код. Это также используется для указания на то, что утверждение не требует компиляции в какой-либо JavaScript.",
            "- Общий Вариант использования: ",
            "Вы добавляете ссылку на свою веб-страницу в файл JavaScript, о котором компилятор ничего не знает. возможно, это скрипт, поступающий из какого-то другого домена, например 'foo.com . при оценке скрипт создаст объект с некоторыми полезными методами API и присвоит ему идентификатор 'fooSdk' в глобальной области видимости.",
            "Вы хотите, чтобы ваш код TypeScript мог вызывать fooSdk.doSomething(), но поскольку ваш компилятор не знает, fooSdk что переменная существует, вы получите ошибку компиляции.",
            "Затем вы используете declare ключевое слово как способ сообщить компилятору: 'поверьте мне, эта переменная существует и имеет этот тип'. Компилятор будет использовать этот оператор для статической проверки другого кода, но не будет перекомпилировать его в какой-либо JavaScript в выходных данных.",
            "declare const fooSdk = { doSomething: () => boolean }",
            "-",
            "Более новая версия Typescript требует немного другого синтаксиса:",
            "declare const fooSdk : { doSomething: () => boolean }",
            "В том же духе вы можете добавить ключевое слово declare в свойства класса, чтобы указать компилятору не создавать какой-либо код, который создал бы это свойство, предполагая, что у вас есть свой собственный код, который создал бы его, о котором компилятор не знает или не понимает.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Когда нужно использовать ключевое слово «declare»?",
        answer: [
            "При использовании библиотеки JavaScript, не объявленной в вашем TypeScript-проекте.",
            "Пример:",
            "declare const libraryName; ",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Расширение .tsx",
        answer: [
            "В основе библиотеки продвинутого рендера React лежит компонентный подход, для улучшения которого, стандартный синтаксис JavaScript был расширен XML-подобным синтаксисом. Таким образом свет увидело новое расширение .jsx.",
            "Из-за высокой популярности React данное расширение получило свое типизированное представление в виде .tsx.",
            "Для того, что бы компилятор tsc смог компилировать .tsx синтаксис, необходимо установить его опцию --jsx в одно из значений - “react” для вэб и настольных, а также “react-native” для мобильных приложений. По умолчанию выставлено значение “preserve”.",
            "// @filename: tsconfig.json",
            "{",
            "'compilerOptions': {",
            "'jsx': 'react'",
            "}",
            "}",
            "Кроме того, помимо самого react, необходимо установить его декларации.",
            "npm i -D @types/react @types/react-dom",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое декораторы и к чему их можно применить? ",
        answer: [
            "Декоратор — это особый тип объявления, который позволяет изменять классы или члены классов одновременно, помечая их аннотацией @<name>. Каждый декоратор должен ссылаться на функцию, которая будет оцениваться во время выполнения.",
            "Например, декоратор @sealed будет соответствовать функции sealed. Все, что помечено, @sealed будет использоваться для оценки sealed функции.",
            "function sealed(target) {",
            "// do something with 'target' ..",
            "",
            "",
            "На текущий момент декораторы являются экпериментальной функциональностью языка TypeScript",
            "-",
            "К ним можно прикрепить:",
            "Объявления классов",
            "Методы",
            "Аксессуар",
            "Характеристики",
            "Параметры",
            "По умолчанию декораторы не включены. Чтобы включить их, вы должны отредактировать поле experimentalDecorators в параметрах компилятора в файле tsconfig.json или в командной строке.",
            "",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое перегрузка функции в TypeScript?",
        answer: [
            "Перегрузка функции - это способ определить функцию с несколькими вариантами типов и реализаций. Перегруженная функция может иметь несколько определений, которые отличаются по количеству и типу параметров.",
            "Перегрузка - это возможность указать несколько типов (несколько сигнатур) для одной и той же функции. Компилятор TypeScript будет сопоставлять типы переданных параметров с перегрузками функции и, если у функции не будет подходящего типа, выдаст ошибку.",
            "Перегрузка — неоднозначный инструмент, вокруг которого много разговоров.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как добиться перегрузки функций в TypeScript?",
        answer: [
            "Чтобы перегрузить функцию в TypeScript, просто создайте две функции с одинаковыми именами, но с разными типами аргументов/возвратов. Обе функции должны принимать одинаковое количество аргументов. Это неотъемлемая часть полиморфизма в TypeScript.",
            "Например, вы можете создать add- функцию, которая суммирует два аргумента, если они являются числами, и объединяет их, если они являются строками:",
            "--",
            "function add( a: string, b: string ): string;",
            "function add( a: number, b: number ): number;",
            "function add( a: any, b: any ): any {",
            " return a + b;",
            "}",
            "--",
            "Сделаем вызов:",
            "add( 'Hello ', 'Steve' ); // returns 'Hello Steve' ",
            "add( 10, 20 ); // returns 30 ",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как перегрузить функцию?",
        answer: [
            "Надо использовать то же имя функции над оригинальной функцией без скобок {} и изменить число и типы аргументов и/или тип возвращаемого значения.",
            "Пример:",
            "function add(x: string, y: string): string;",
            "function add(x: number, y: number): number {",
            "return x + y;",
            "} ",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как использовать миксины (примеси) в TypeScript.",
        answer: [
            "Миксины — это, по сути, наследование, которое работает в противоположном направлении. Примеси позволяют вам создавать новые классы, комбинируя более простые частичные установки классов из предыдущих классов.",
            "Вместо того, чтобы класс Aрасширял класс B, чтобы получить его функциональность, класс B берет класс A и возвращает новый класс с дополнительной функциональностью.",
            "Примесь – объект, содержащий методы и свойства для реализации конкретного функционала. Функциональность миксинов (mixins) частично позволяет унаследовать свойства и методы сразу двух и более классов, тем самым избавившись от дублирования в коде.",
            "TypeScript, как и многие объектно-ориентированные языки, как, например, Java или C#, не позволяет использовать напрямую множественное наследование. Мы можем реализовать множество интерфейсов в классе, но унаследовать его можем только от одного класса. Однако функциональность миксинов (mixins) частично позволяют унаследовать свойства и методы сразу двух и более классов.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое геттеры/сеттеры в TypeScript? Как вы их используете? ",
        answer: [
            "Геттеры и сеттеры — это специальные типы методов, которые помогают вам делегировать различные уровни доступа к закрытым переменным в зависимости от потребностей программы.",
            "Геттеры позволяют ссылаться на значение, но не могут его редактировать. Сеттеры позволяют вам изменить значение переменной, но не видеть ее текущее значение. Они необходимы для достижения инкапсуляции.",
            "Например, новый работодатель может иметь право на getколичество сотрудников в компании, но не имеет разрешения на setколичество сотрудников.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как преобразовать строку в число с помощью Typescript?",
        answer: [
            "Как и в JavaScript, вы можете использовать функции parseInt или parseFloat для преобразования строки в целое число или число с плавающей запятой соответственно. Вы также можете использовать унарный оператор + для преобразования строки в наиболее подходящий числовой тип: «3» становится целым числом, 3а «3.14» становится числом с плавающей запятой 3.14.",
            "var x = '32';",
            "var y: number = +x;",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое файл .map и зачем/как его использовать?",
        answer: [
            "Файл map - это исходная карта, которая показывает, как исходный код TypeScript был интерпретирован в пригодный для использования код JavaScript. Они помогают упростить отладку, поскольку вы можете отловить любое странное поведение компилятора. Инструменты отладки также могут использовать эти файлы, чтобы вы могли редактировать базовый TypeScript, а не создаваемый файл JavaScript.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Какие режимы JSX поддерживает TypeScript?",
        answer: [
            "TypeScript имеет встроенную поддержку preserve, reactи react-native.",
            "- preserve сохраняет JSX нетронутым для использования в последующем преобразовании.",
            "- react не проходит преобразование JSX, а вместо этого генерирует react.createElement и выводит как .js расширение файла.",
            "- react-native сочетает в себе preserve и react в том, что он поддерживает все JSX и выходные данные в качестве .js расширения.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как компилировать файл TypeScript?",
        answer: [
            "Вам нужно вызвать компилятор TypeScript tsc для компиляции файла. Вам потребуется установить компилятор TypeScript, что вы можете сделать с помощью npm.",
            "npm install -g typescript",
            "tsc <TypeScript File Name>",
            "---",
            "Вообще, это  плохая затея. По мне, лучше заново создать проект с TS и переписать его. Если добавить TS в существующий проект, то вылезет миллион ошибок, которые не возможно отследить.",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Объясните параметры Rest... и правила объявления параметров Rest...",
        answer: [
            "Параметры Rest:",
            "- Остаточные параметры позволяют передавать в функцию ноль или более аргументов указанного типа. Это полезно, когда вы не уверены, сколько параметров получит функция. Все аргументы после символа остатка ... будут храниться в массиве.",
            "- у вас может быть только 1 остаточный параметр для каждой функции.",
            "- Остаточный параметр должен быть последним в определении параметра.",
            "- Поскольку здесь речь идет о TypeScript, поэтому тип параметра rest имеет тип массива (далее массив может быть строковым типом данных или числовым типом данных или чем угодно).",
            "--",
            "Синтаксис: Ниже приведен синтаксис параметров rest, предоставленный в TypeScript.",
            "function function_name (...rest_parameter_name : type[]) { }",
            "Здесь эти “...” (тройные точки) представляют синтаксис параметра rest, за которым следует имя параметра rest, за которым следует тип этого параметра rest (должен иметь тип данных массива).",
            "--",
            "Аргументы Rest:",
            "- Это аргументы, которые мы передаем при объединении двух типов данных (предположим, конкатенации двух массивов) с использованием одного и того же “...” (тройные точки).",
            "- Эти типы аргументов обычно используются для слияния или конкатенации или для любых других операционных целей.",
            "--",
            "Синтаксис: Ниже приведен синтаксис использования аргументов Rest в TypeScript (объясняется на примере).",
            "let array_1 : number[] = [1 , 2 , 3];",
            "let array_2 : number[] = [5 , 6, 7];",
            "array_1.push(array_2);",
            "--",
            " Например:",
            "function Greet(greeting: string, ...names: string[]) {",
            "return greeting + ' ' + names.join(', ') + '!';",
            "}",
            "-",
            "Greet('Hello', 'Steve', 'Bill'); // returns 'Hello Steve, Bill!'",
            "Greet('Hello');// returns 'Hello !'",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое директивы с тройной косой чертой? ",
        answer: [
            "Директивы с тройной косой чертой - это однострочные комментарии, содержащие тег XML для использования в качестве директив компилятора.",
            "Каждая директива указывает, что загружать в процессе компиляции. Директивы с тройной косой чертой работают только в верхней части своего файла и будут рассматриваться как обычные комментарии в любом другом месте файла.",
            "--",
            "Директивы с тройной косой чертой — это однострочные комментарии, содержащие тег XML для использования в качестве директив компилятора. Каждая директива указывает, что загружать в процессе компиляции. Директивы с тройной косой чертой работают только в начале своего файла и будут рассматриваться как обычные комментарии в любом другом месте файла.",
            "- /// <reference path=''...'' /> является наиболее распространенной директивой и определяет зависимость между файлами.",
            "- /// <reference types=''...'' /> аналогичен, pathно определяет зависимость для пакета.",
            "- /// <reference lib=''...'' /> позволяет явно включать встроенный lib файл",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Как автоматически получить файлы declaration?",
        answer: [
            "Установить опцию компилятора на true в файле tsconfig.json",
            "Пример:",
            "{",
            "'compilerOptions': {",
            "...",
            "'declaration': true,",
            "}",
            "}",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Множественное наследование",
        answer: ["Если мы хотим унаследоваться у двух классов, то у нас возникает множественное наследование. ", ""],
        isParagraphBefore: true
    },
    {
        heading: "Объектно-ориентированное программирование (ООП).",
        answer: [
            "Объектно-ориентированное программирование (ООП) — подход, при котором разработчик создает систему объектов и классов. ",
            "Объектно-ориентированное программирование – это подход, при котором вся программа рассматривается как набор взаимодействующих друг с другом объектов. При этом нам важно знать их характеристики. У каждого объекта в системе есть свойства и поведение, как и у любого реального объекта.",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Что такое скриптовый язык программирования?",
        answer: [
            "Скриптовый язык (англ. scripting language, также называют язык сценариев) - язык программирования, разработанный для записи «сценариев», последовательностей операций, которые пользователь может выполнять на компьютере.",
            "Сценарии всегда интерпретируются, а не компилируются.",
            "-*-",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Типизация функции map, map через reduce.",
        answer: [
            "1.1. Функция map в js:",
            "    function map(arr, fn) {",
            "        return arr.map(fn);",
            "    }",
            "-*-",
            "1.2. Функция map в ts:",
            "    function map<T, R>(arr: T[], fn: (val: T, index: number, array: T[]) => R): R[] {",
            "        return arr.map(fn)",
            "    }",
            "-*-",
            "2.1. Функция map2 через reduce в js:",
            "    function map2(arr, fn) {",
            "        return arr.reduce((result, item, index, array) => {",
            "            result.push(fn(item, index, array));",
            "            return result;",
            "        }, []);",
            "    }",
            "-*-",
            "2.2. Функция map2 через reduce в ts:",
            "    function map2<T, R>(arr: T[], fn: (val: T, index: number, array: T[]) => R): R[] {",
            "        return arr.reduce((result: R[], item, index, array) => {",
            "            result.push(fn(item, index, array))",
            "            return result;",
            "        }, []);",
            "    }",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript",
        answer: [
            "https://www.youtube.com/watch?v=SpQDK74vLKo&list=PLdTPrJkdrLGGgSnXMsO-Rix3MTuySb_mF&index=51&t=123s",
            " ",
            "Условный тип в JS выглядит так:",
            "        value === result ? true : false;",
            "Условный тип в TypeScript выглядит иначе:  T является принадлежностью подможества U ? Если да, то нам возвращается Т1. Если нет, то возвращается - Т2.",
            "        T extends U ? T1 : T2; ",
            "Объявим дженерик type Test и проверим, что переданный тип Т принадлежит типу string: T extends string ? Если это так, вернём true, иначе - false. Еxtends в нашем случае указывает не нанаследование, как можно подумать, а на принадлежность типа Т строке.   ",
            "        type Test<T> = T extends string ? true : false;",
            "Объявим другой тип.",
            "         type R = Test<'a'>;  // type R = true",
            "         type N = Test<2>;   // type N = false",
            "Например у нас есть интерфейс User: ",
            "         interface User {",
            "             id: string;",
            "         }",
            "и есть интерфейс Message: ",
            "         interface Message {",
            "             id: number;",
            "         }",
            "Так же у нас есть функция, которая принимает объект и возвращает id: ",
            "         function getId(obj) {",
            "                  return obj.id;",
            "         }",
            "Вызовем функцию, используя наши интерфейсы. Нам надо, чтобы в результат попадал правильный тип id переданного интерфейса. Пишем нашу функцию через дженерик, и делаем проверку на выходе функции для определения типа результата:",
            "         function getId<T extends { id: any }>(obj: T): T extends User ? string : number {",
            "                  return obj.id;",
            "         }",
            "После проверки (T extends User ?) мы увидим правильный тип результата",
            "         const r1 = getId({} as User); // const r1: string",
            "         const r2 = getId({} as Message); // const r2: number",
            " ",
            "Чтобы иметь возможность переиспользовать это код, мы можем напрямую не указывать интерфейс User, а указать, что он назначен к типу { id: string }. То есть вместо (T extends User ?) пишем (T extends { id: string } ?).",
            "         function getId<T extends { id: any }>(obj: T): T extends { id: string } ? string : number {",
            "                  return obj.id;",
            "         }",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript с типом 'never'",
        answer: [
            "https://www.youtube.com/watch?v=SpQDK74vLKo&list=PLdTPrJkdrLGGgSnXMsO-Rix3MTuySb_mF&index=51&t=123s",
            " ",
            "1. Очень часто условные типы используются с типом 'never' для исключения определённых типов из выражений. ",
            "* Например, создадим дженерик тип NotFalse. По дефолту он будет принимать null и мы будем проверять, что если тип Т - это null или undefined | false | 0, тогда мы вернём never, иначе мы вернём переданный нами тип. Ключевое слово never указывает на то, что такое значение никогда не появится.",
            " ",
            "         type NotFalse<T = null> = T extends null | undefined | false | 0 ? never : T;",
            " ",
            "* Теперь объявим z. Eсли туда ничего не будем передавать, то тип будет never.",
            "         const z: NotFalse  = 'Hello'; // Тип 'string' не может быть назначен для типа 'never'.ts(2322)",
            " ",
            "* Если передадим string, то всё хорошо.",
            "         const y: NotFalse<string> = 'Hello';",
            " ",
            "* Если вместо строчки передадим null, это вызовет ошибку.",
            "         const y: NotFalse<string> = null; // Тип 'null' не может быть назначен для типа 'string'.ts(2322)",
            "-*-",
            "2. Тип never очень часто используются для фильтрации типов.",
            "*  Например: если T является принадлежностью подможества U ?, тогда мы вернём never. Иначе - Т.",
            "         type Filter<T, U> = T extends U ? never : T;",
            " ",
            "Мы можем фильтровать наши типы: укажем первым аргументом: 'a' | 'b' | 'c', а вторым аргументом только 'b',",
            " В нашем случае extends перебирает по очереди каждый из элементов этого юниона и сравниваться с 'b': ",
            "         // 'a' сравнивается с  'b', ",
            "         // 'b' сравнивается с  'b',",
            "         // 'c' сравнивается с  'b'.",
            "Таким образом мы отфильтруем два элемента, получим только 'a' | 'c'.",
            " ",
            "         type R = Filter<'a' | 'b' | 'c', 'b'>; // мы увидим: type R = 'a' | 'c'",
            " ",
            " На самом деле тип Filter - это встроенный в тайпскрипт тип Exclude, и реализация аналогична.",
            "         type R2 = Exclude<'a' | 'b' | 'c', 'b'>; // type R2 = 'a' | 'c'",
            "-*-",
            "3. ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript (T extends U ? T1 : T2) и условные выражения.",
        answer: [
            "В качестве типов T1 и T2 наших выражений могут выступать и другие условные выражения. ",
            "Создадим тип GetStatus, он будет принимать объект. Если мы туда действительно будем передавать объект (T extends object ?), тогда мы будем вычислять статус. Иначе, в другом случае, мы будем просто возврашать null.   ",
            "Если тип Т может быть записан в статус (T extends { status: string } ?), тогда мы просто возьмём это поле у типа Т ( T['status'] ). Иначе, тоже вернём null.",
            " ",
            "     type GetStatus<T> = T extends object ? (T extends { status: string } ? T['status'] : null) : null;",
            " ",
            "Таким образом мы можем получить status у типа GetStatus. Если мы передадим сюда статус 'STR', то мы его и получим. ",
            " ",
            "     type Status = GetStatus<{ status: 'STR' }>; //  type Status = 'STR'",
            "Если мы передадим сюда статус 'STRoka', то мы его и получим. ",
            "     type Status2 = GetStatus<{ status: 'STRoka' }>; //  type Status2 = 'STRoka' ",
            " ",
            "Если мы сюда в статус передадим что-то другое, не as string (<string>), например числовое значение 2, то мы здесь получим null. ",
            " ",
            "     type Status3 = GetStatus<{ status: 2 }>; //  type Status3 = null",
            " ",
            "",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript. Использование ключевого слова infer.",
        answer: [
            "Но в идеале, конечно, наш код должен был сам распознать тип статуса и вернуть то значение, которое мы хотим. Чтобы бы мы не перечисляли все проверки на строку число, массивы и объекты и так далее. Такая возможность у нас есть в тайпскрипте есть, с использованием ключевого слова infer. ",
            "Infer позволяет нам определить переменную в пределах нашего ограничения типов, на которое можно ссылаться или возвращать. Использоваться оно может только в условных типах, только после ключевого слова extends.",
            "1. Давайте опишем type, который принимает Т объект и укажем (T extends infer R ), вернём R (? R ) или never.",
            " ",
            "     type TryInfer<T extends object = object> = T extends infer R ? R : never;",
            " ",
            "Используем тип TryInfer на каком нибудь объекте, например:",
            " ",
            "     type R = TryInfer<{ a: 1; b: 2 }>; // type R = {",
            "                                                                    a: 1;",
            "                                                                    b: 2;",
            "                                                        // }  ",
            "Infer распознаёт наш объект и возвращает его тип. То есть здесь мы увидим то, что и передали. Но, если нам нужны будут значения наших полей, то мы можем взять R[keyof R], и таким образом получим значения: // type R1 = 2 | 1",
            " ",
            "     type TryInfer2<T extends object = object> = T extends infer R ? R[keyof R] : never;",
            "     type R1 = TryInfer2<{ a: 1; b: 2 }>; // type R1 = 2 | 1",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript. ReturnType, определение типа возвращаемого аргумента функции. ",
        answer: [
            "https://www.youtube.com/watch?v=SpQDK74vLKo&list=PLdTPrJkdrLGGgSnXMsO-Rix3MTuySb_mF&index=57&t=123s   6,49 мин.",
            " ",
            "Рассмотрим пример. Допустим, у нас есть функции test и test2, они возвращают какое-то значение.",
            "     function test() {",
            "          return 2; // number",
            "     }",
            " ",
            "     function test2() {",
            "          return {",
            "               name:'Max', // string",
            "          };",
            "     }",
            " ",
            "Эти функции не принадлежит нам, находятся где-то, в сторонней библиотеке. Но нам надо знать, что они возвращают, какой тип. Для этого мы можем написать свой тип. Назовём его FunctionResult, скажем, что Т может принимать любую функцию, которая возвращает любой результат (<T extends (...args: any)=>any>). Далее используем тот же extends, для ...args укажем (...args: any), а в респонзе этой функции распознаем её результат и вернём этот результат ((сохраним в переменной R)=> infer R ). В условии 'R ?' false у нас выполнется только тогда, когда мы передадим сюда не функцию (то есть не ((...args: any)) ). Если мы передали функцию, то она возвращает значение типа R. Таким образом мы можем определить тип возвращаемого аргумента функции test().",
            " ",
            "     type FunctionResult<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;",
            " ",
            "     type R = FunctionResult<typeof test>; // type R = number",
            "// Мы видим, что type R = number.",
            " ",
            "     type R1 = FunctionResult<typeof test2>; // type R1 = { name: string }",
            "// Мы видим, что type R1 = { name: string }",
            " ",
            "В этом случае infer R распознаёт наш код и сохраняет распознанные типы в переменные R и R1, а дальше эти переменные R и R1 возвращает.",
            " ",
            "На самом деле эта функция FunctionResult тоже утилитный тип, который называется ReturnType, в тайпскрипт он уже встроен.",
            "     type R2 = ReturnType<typeof test>; // type R2 = number",
            " ",
        ],
        isParagraphBefore: true
    },
    {
        heading: "Условные типы в TypeScript. Используем infer с нашим кодом GetStatus",
        answer: [
            "Наш прежний код GetStatus:",
            " ",
            "          type GetStatus<T> = T extends object ? (T extends { status: string } ? T['status'] : null) : null;",
            " ",
            "И теперь используем infer с нашим кодом GetStatus. Вместо того, чтобы проверять наш код на статус { status: string }, мы сразу же распознаем переданный нами код и сохраним в переменную U. Проверим, что если (U extends { status: any } ?, то мы вернём этот U['status'].",
            " ",
            "          type GetStatus<T> = T extends infer U ? (U extends { status: any } ? U['status'] : null) : null;",
            " ",
            "// Таким образом, если мы передадим сюда статус число 125, то мы должны получить число 125.",
            "          type Status1 = GetStatus<{ status: 125 }>; // type Status1 = 125",
            " ",
            "// Если передаём строку 'LOL', то мы и получаем строку 'LOL'.",
            "          type Status2 = GetStatus<{ status: 'LOL' }>; // type Status2 = 'LOL'",
            " ",
            "// Если передаём массив, то мы его и получим.",
            "          type Status3 = GetStatus<{ status: ['a', 's', 's', 'a'] }>; // type Status3 = ['a', 's', 's', 'a']",
            " ",
            "          type Status4 = GetStatus<{ status: [1, 2, 3, 4, 5] }>; // type Status4 = [1, 2, 3, 4, 5]",
            " ",
            "// Если передаём объект, то и получаем объект",
            "          type Status5 = GetStatus<{ status: { name: 'max'; age: 25 } }>; // type Status5 = { name: 'max'; age: 25 }",
        ],
        isParagraphBefore: true
    },
    {
        heading: "",
        answer: ["", "", "", "", "", "", "", "", "", "", "", ""],
        isParagraphBefore: true
    },
    {
        heading: "",
        answer: ["", "", "", "", "", "", "", "", "", "", "", ""],
        isParagraphBefore: true
    },
];

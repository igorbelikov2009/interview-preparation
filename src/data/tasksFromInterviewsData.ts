/* eslint-disable no-useless-escape */
/* eslint-disable no-template-curly-in-string */

import { IObjectTasks } from "../models/types";

export const arrayTasks: IObjectTasks[] = [
  {
    heading: "Удалить пробелы из строки. Метод string.replace() с регулярным выражением внутри.",
    href: "https://www.youtube.com/watch?v=awtOmYDEMY8&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=4",
    taskCode: [
      "const [ str, setStr ] = useState(' ftu ft ggwr '); ",
      "const [ strNoSpace, setStrNoSpace ] = useState(''); ",
      "- ",
      "function noSpace(x: string) { ",
      "         return x.replace(/s/g, ''''); ",
      "} ",
      "useEffect(() => {",
      "         setStrNoSpace(noSpace(str)); ",
      "}, [ str ]); ",
      "- ",
      "   console.log(str); // ' ftu ft ggwr ' ",
      "   console.log(strNoSpace); // ftuftggwr ",
      "-*- ",
    ],
  },
  {
    heading: "Очистить строку от числовых символов. Метод string.replaceAll() с регулярным выражением внутри. ",
    href: "https://www.youtube.com/watch?v=oQ-0bm9-_yA&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=6",
    taskCode: [
      "const [ elem ] = useState( 'This looks5 grea8te' ); ",
      "const [ elemClear, setElemClear ] = useState( '' );",
      "- ",
      "function stringCleaner( s: string ) { ",
      "      return s.replaceAll( /d/g, '''' );",
      "} ",
      "useEffect(() => { ",
      "      setElemClear( stringCleaner( elem )); ",
      "}, [ elem ]); ",
      "- ",
      "   console.log( elem ); // 'This looks5 grea8te' ",
      "   console.log( elemClear ); // This looks greate ",
      "-*- ",
    ],
  },
  {
    heading: "Чётное или нечётное? ",
    href: "https://www.youtube.com/watch?v=KwU3wq5DT90&t=77s",
    taskCode: [
      "const number = 1263; ",
      "const number2 = 1264; ",
      "- ",
      "function even_or_odd(number: number) { ",
      "      return number % 2 === 0 ? 'чётное' : 'нечётное'; ",
      "}",
      "- ",
      "   console.log(even_or_odd(number)); // нечётное ",
      "   console.log(even_or_odd(number2)); // чётное ",
      "-*- ",
    ],
  },
  {
    heading: "Вывод пользователей, которые лайкнули публикацию. Используем switch. ",
    href: "https://www.youtube.com/watch?v=XoKmzVPoQ_0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=1&t=20s",
    taskCode: [
      "Дан массив пользователей, которые лайкнули публикацию. Необходимо вывести имена этих пользователей строкой. Используем конструкцию switch.",
      "const printPeopleLiked = (names: string[]) => { ",
      "  switch (names.length) { ",
      "     case 0:",
      "       return 'Нет лайков';",
      "     case 1:",
      "       return `${names[0]} поставил лайк`;",
      "     case 2:",
      "       return `${names[0]} и ${names[1]} поставили лайк`;",
      "     case 3:",
      "       return `${names[0]}, ${names[1]} и ${names[2]} поставили лайк`;",
      "     default:",
      "       return `${names[0]}, ${names[1]} и ещё ${names.length - 2} поставили лайк`;",
      "  } ",
      "}; ",
      "console.log(printPeopleLiked([])); // Нет лайков ",
      "console.log(printPeopleLiked(['Max'])); // Max поставил лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy'])); // Max и Asy поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb'])); // Max, Asy и Gleb поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika'])); // Max, Asy и ещё 2 поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika', 'Boris', 'Andrey'])); // Max, Asy и ещё 4 поставили лайк ",
    ],
  },
  {
    heading: "Нужно найти сумму всех чисел, кратных 3 или 5.",
    href: "https://www.youtube.com/watch?v=WCIpXcwvXpw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=2",
    taskCode: [
      "Нужно найти сумму всех чисел, кратных 3 или 5, меньше переданного числа. Например, переданное число 16. Находим все числа, кратные 3 или 5, суммируем их и получаем результат.  ",
      "",
      "16 => 3 + 5 + 6 + 9 + 10 + 12 + 15 => 60. ",
      "- ",
      "const sum35 = ( n: number ) => { ",
      "    let sum = 0; ",
      "    for ( let i = 3; i < n; i++ ) { ",
      "        if ( i % 3 === 0 || i % 5 === 0 ) { ",
      "          sum += i; ",
      "        } ",
      "    } ",
      "    return sum;",
      "}; ",
      "- ",
      "console.log( sum35( 16 )); // 60 ",
      "console.log( sum35( 25 )); // 143 ",
      "-*- ",
    ],
  },
  {
    heading: "Разность массивов. Исключить из массива группу элементов другого массива. ",
    href: "https://www.youtube.com/watch?v=qSCy7RaJ6bg&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=3",
    taskCode: [
      "Как исключить из массива группу элементов из другого массива, например: ",
      "arrayDiff = ( [ 1, 2, 8, 2, 7, 3 ], [ 7, 2 ] ) => [ 1, 8, 3 ] ",
      "const arrayDiff = (source: number[], diff: number[]) => { ",
      "    // Метод filter отсечёт ненужные элементы по условию. Оставим в ",
      "    // результате только такие элементы, которые не входят в массив diff. ",
      "    return source.filter((item) => !diff.includes(item)); ",
      " }; ",
      "- ",
      "useEffect(() => { ",
      "    console.log(arrayDiff([2, 3, 4, 5, 6, 7, 8], [7, 2])); // (5) [3, 4, 5, 6, 8]",
      "  }, []); ",
      "-*- ",
    ],
  },
  {
    heading: "Как отформатировать строку и превратить её в телефонный номер. ",
    href: "https://www.youtube.com/watch?v=JbaVl29kVbI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=4",
    taskCode: [
      "Дана строка '1234567890'. Нужно первые три символа обернуть в скобки, потом пробел, потом три символа, дефис и ещё четыре символа: (123) 456-7890.",
      "Для подобных задач пригодятся регулярные выражения, а точнее, скобочные выражения для нахождения подстрок и метод replace().  ",
      "    // Первым аргументом в методе: поиск совпадений в строке. В нашем случае нужно запомнить первые три числовые символа (/d{3}).  (Здесь должен быть обратный слэш.) ",
      "    // Подобным образом запомним следующие 3 числа (/d{3}) и 4 после (/d{4}). (Здесь должен быть обратный слэш.) ",
      "    // Для замены текста используем обозначение '($1) $2-$3': ($1 оборачиваем в скобки - пробел, $2 - дефис, $3)",
      "- ",
      "const createPhoneNumber = (str: string) => { ",
      "    return str.replace(/(/d{3})(/d{3})(/d{4})/, '($1) $2-$3'); // (Здесь должен быть обратный слэш.)  ",
      "}; ",
      "- ",
      "useEffect(() => { ",
      "    console.log(createPhoneNumber('1234567890')); // (123) 456-7890 ",
      "}, []); ",
      "-*-",
    ],
  },
  {
    heading: "Перевести буквы в числа по их позиции в алфавите. ",
    href: "https://www.youtube.com/watch?v=_HmpuK3ori0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=5",
    taskCode: [
      "Как перевести слово в группу чисел, где каждое число - позиция буквы в алфавите. Если слово 'Азбука', то нужно превратить его в '1 8 2 20 11 1' .",
      "Для начала стандартной операции для преобразования строки, приведём её к нижнему регистру (toLowerCase()), разделим посимвольно (split('')) и будем использовать метод map(), который будет трансформировать каждый элемент массива в коллбэк внутри с одним аргументом (char => charCodeAt()). Метод charCodeAt() возвращает числовое значение юниткода для символа по указанному индексу.",
      "'Азбука'.charCodAt(0) // 1040. То есть заглавная русская буква А хранится в юникод под номером 1040. ",
      "'азбука'.charCodAt(0) // 1072. Маленькая русская буква 'а' хранится в юникод под номером 1072.",
      "  Значит, вычитая из результата число 1071, мы будем получать позицию каждой буквы в алфавите.",
      "console.log('азбука'.charCodeAt(0) - 1071); // 1 ",
      "console.log('азбука'.charCodeAt(1) - 1071); // 8 ",
      "console.log('азбука'.charCodeAt(2) - 1071); // 2 ",
      "console.log('азбука'.charCodeAt(3) - 1071); // 20 ",
      "console.log('азбука'.charCodeAt(4) - 1071); // 11 ",
      "console.log('азбука'.charCodeAt(5) - 1071); // 1 ",
      "-",
      "Наша общая функция будет выглядеть так: ",
      "const alphabetPosition = (str: string) => { ",
      "    return str ",
      "        .toLowerCase() ",
      "        .split('') // по пустому разделителю",
      "        .map((char) => char.charCodeAt(0) - 1071)",
      "        .join(' '); // по пробелу",
      "}; ",
      "console.log(alphabetPosition('Азбука')); // 1 8 2 20 11 1 ",
      "-*-",
    ],
  },
  {
    heading: "Схлопнуть соседние элементы. ",
    href: "https://www.youtube.com/watch?v=hnmmm9iOAUo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=6",
    taskCode: [
      "Напишите функцию, которая принимает последовательность (это может быть массив или строка) и возвращает массив, где повторяющиеся сосоедние элементы схлопнулись до одного. Исходный порядок элементов нужно сохранить. ",
      "Решим эту задачу через фильтр. Для этого развернём нашу последовательность на входе ( iterable ) => [ ...iterable ]. Мы получим массив, даже если заспредим строку. Затем отфильтруем элементы этого массива таким образом, чтобы в новый массив попали только те элементы, которые не равны элементу из последовательности по индексу и -1",
      "Наша функция будет выглядеть так:",
      "function uniqueInOrder(iterable: string | string[] | number[]) { ",
      "    return [...iterable].filter((el, index) => el !== iterable[index - 1]); ",
      "} ",
      "- ",
      "console.log(uniqueInOrder('AAAABBBCCDAABBB')); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
      "console.log(uniqueInOrder('ABBCcAD')); // ['A', 'B', 'C', 'c', 'A', 'D'] ",
      "console.log(uniqueInOrder(['A', 'A', 'A', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B'])); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
      "console.log(uniqueInOrder([1, 1, 2, 2, 2, 3, 3, 4, 4])); // [1, 2, 3, 4] ",
      "-*-",
    ],
  },
  {
    heading: "Написать функцию по выявлению пагнрамм.",
    href: "https://www.youtube.com/watch?v=wE3YcgtTZlo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=7",
    taskCode: [
      "Написать функцию по выявлению пагнрамм - фраз, содержащих в себе все буквы алфавита. ",
      "Вычислить панграмму в JS просто: нужно занести в Set- коллекцию нашу преобразованную строку. Как её преобразовать: сначала приводим все буквы к нижнему регистру, а затем, с помощью регулярного выражения оставим только буквы русского алфавита. Используем буквы от 'а' до 'я' начала строки и букву 'ё', потому, что она не включается стандартно и глобально. Всё это заменяем на пустую строку replace(/[^а-яё]/g, '')",
      "Set- коллекция исключит из массива повторяющиеся элементы, оставит только уникальные, и у это коллекции есть метод size. Если size === 33 (количество букв в алфавите), то значит это фраза - паграмма   ",
      "- ",
      "const isPangram = (str: string) => { ",
      "    const set = new Set([...str.toLowerCase().replace(/[^а-яё/]/g, '')]); ",
      "    return set.size === 33; ",
      "}; ",
      "Эта фраза не является панграммой: ",
      "    console.log(isPangram('Мама мыла раму')); // false ",
      "Эта фраза - панграмма:",
      "    console.log(isPangram('Съешь ещё этих мягких французских булочек, да выпей же чаю')); // true ",
      "-*- ",
    ],
  },
  {
    heading: "Нарисуй ёлку из символов, например, из звёзд. ",
    href: "https://www.youtube.com/watch?v=DZ4oAPBmvDI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=8",
    taskCode: [
      "На вход поступает высота ёлки. Ёлка симметрична, поэтому нужно понять, сколько пробелов должно быть в ряду, с обоих сторон от звёзд. С самими звёздами всё ясно, их в ряду будет: 1, 3, 5, 7, 9. Для высоты = 5 будет 9 звёзд в нижнем ряду и 0 пробелов. Значит в первом ряду будет 4 пробела, 1 звезда и опять 4 пробела.",
      "const drawChristmasTree = (n: any) => { ",
      "    let tree = '\n'; ",
      "    for (let i = 0; i < n; i++) { ",
      "        const space = ' '.repeat(n - i - 1); ",
      "        tree += space + '*'.repeat(i + i + 1) + space + '\n'; ",
      "    } ",
      "    return tree; ",
      " }; ",
      "console.log(drawChristmasTree(5)); ",
      "    * ",
      "   *** ",
      "  ***** ",
      " ******* ",
      "********* ",
      "console.log(drawChristmasTree(6)); ",
      "     * ",
      "    *** ",
      "   ***** ",
      "  ******* ",
      " ********* ",
      "*********** ",
      "-*- ",
    ],
  },
  {
    heading: "Валидация строк со скобками. ",
    href: "https://www.youtube.com/watch?v=cNPsxKh4s5U&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=9",
    taskCode: [
      "-*- У меня это решение вызывает ошибку-*-",
      "Напиши валидацию строк с круглыми, квадратными и фигурными скобками. Считаем, что результат правильный, если все скобки открываются и закрываются в нужном порядке. ",
      "Например: ",
      "isValidBraces('(){}[]') // true ",
      "isValidBraces('({[]})') // true ",
      "isValidBraces('(}')     // false ",
      "isValidBraces('[(])')   // false ",
      "isValidBraces('[({}(]') // false ",
      "Стек - это структура данных, представляющие собой список элементов, организованных по принципу: последним зашёл - первым вышел.  ",
      "Мы будем идти по каждому символу в строке и класть в стек открывающиеся скобки. А если будем видеть закрывающую скобку, то будем проверять, соответсвует ли её тип с типом последней последней скобки в стеке. Если они не одного и того же типа, то можно сразу возвращать ложь, не дожидаясь завершения цикла. Если мы вышли из цикла без подобных остановок, то осталось проверить размер стека. Если он равен нулю, то это значит, что в нём не осталось открытых скобок. А значит входная строка валидна. Если хотя бы один элемент в стеке есть, то значит строка не валидна.   ",
      "const isValidBraces = (str: string) => { ",
      "    const braces = { '{': '}', '(': ')', '[': ']' }; ",
      "    const stack = []; ",
      "    for (let i = 0; i < str.length; i++) { ",
      "       const currentBrace = str[i] as keyof typeof braces;",
      "       if (braces[currentBrace]) { ",
      "           stack.push(currentBrace); ",
      "       } else if (currentBrace !== braces[stack.pop()]) { // ts(2538)",
      "       // Тип 'undefined' невозможно использовать как тип индекса.ts(2538)",
      "       // (method) Array<string>.pop(): string | undefined",
      "           return false; ",
      "       } ",
      "    } ",
      "    return stack.length === 0; ",
      "}; ",
      "-*- ",
      "У меня это решение вызывает ошибку. ",
    ],
  },
  {
    heading: "Пересечения массивов",
    href: "https://www.youtube.com/watch?v=APuD-xNMBGc&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=10",
    taskCode: [
      "Нужно написать функцию, которая принимает два массива и возвращает массив с их пересечениями - элементы должны присутствовать и в первом, и во втором массиве. Причём, элемент должен повториться в массиве два и более раза. ",
      "Для начала выбираем только повторяющие числа, для этого создадим Set- коллекцию уникальных элементов, в которой будут лежат элементы, которые хотя бы раз встречались в массиве. А в объекте pick будем собирать числа, которые повторились два или более раз.    ",
      "Пройдём по перому массиву методом forEach(), проверим для каждого числа в массиве условие: если в Set- коллекции нет текущего числа (has()), то занесём его в коллекцию. Иначе, число уже встречалось в массиве, а значит оно повторяющееся. Положим повторяющееся число в объект pick, ключём станет станет само повторяющее число из первого массива, а значением 0 - количество будущих повторений во втором массиве. Получили объект, где ключи - повторяющиеся числа из первого массива, а значения - количество повторений уже во втором массиве. Осталось только преобразовать этот объект в массив, в котором будут лежать только ключи.       ",
      "Проверим, что всё получилось так, как надо. ",
      "Так же проходим по второму массиву, если число из второго массива является ключём в объекте pick, то увеличим его значение на 1.    ",
      "const intersectNubmers = (a: number[], b: number[]) => { ",
      "    const set = new Set(); ",
      "    const pick: any = {};",
      "    // ",
      "    a.forEach((n: number) => {",
      "      if (!set.has(n)) {",
      "        set.add(n); ",
      "      } else {",
      "        pick[n] = 0;",
      "      }",
      "    }); ",
      "    // return pick; // {1: 0, 17: 0, 56: 0} // результат проверки первого массива",
      "    // Проверяем второй массив",
      "    b.forEach((n: number) => {",
      "      if (n in pick) {",
      "        pick[n] = pick[n] + 1;",
      "      }",
      "    });",
      "    // return pick; // {1: 3, 17: 2, 56: 1} // результат проверки обоих массивов",
      "    // Преобразуем объект в массив, в котором будут лежать только ключи",
      "    return Object.entries(pick).reduce((result, [n, count]) => {",
      "      if ((count as number) > 1) {",
      "        result.push(+n);",
      "      }",
      "      return result;",
      "    });",
      "}; ",
      "console.log(intersectNubmers([7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1])); ",
      "-*-",
    ],
  },
  {
    heading: "Представление числа в расширенной нотации.",
    href: "https://www.youtube.com/watch?v=ukx4y4HjhtI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=11",
    taskCode: [
      "Вернуть заданное число в виде строки в расширенной форме. Все числа будут целыми числами больше нуля. ",
      "Что такое расширенная анотация - это когда число представляется в виде суммы каждой цифры, умноженное на соответствующее значение её разряда. Например:   ",
      "expandedForm(12); // => '10 + 2' ",
      "expandedForm(42); // => '40 + 2' ",
      "expandedForm(70304); // => '70000 + 300 + 4' ",
      "--",
      "Наша функция: ",
      "const expandedForm =  ( num: number ) => {   // на входе num = 70304",
      "    return ( ",
      "        String( num ) // Переводим число в строку '70304' ",
      "            .split( '' ) // Разбиваем эту строку посимвольно [ '7', '0', '3', '0', '4' ] ",
      "            // К каждому символу прибавляем определённое количество нулей: ",
      "            .map(( n, i, arr ) => n + '0'.repeat( arr.length - i - 1 )) // [ '70000', '0000', '300', '00', '4' ] ",
      "            // Отфильтруем, оставим всё, что не равно нулю ",
      "            .filter(( n ) => Number( n ) !== 0 ) // [ '70000', '300', '4' ] ",
      "            // Объеденим элементы массива в строку, поставив между ними знак '+'",
      "            .join(' + ') // 70000 + 300 + 4",
      "     ); ",
      "}; ",
      "console.log(expandedForm(12)); // 10 + 2 ",
      "console.log(expandedForm(42)); // 40 + 2 ",
      "console.log(expandedForm(70304)); // 70000 + 300 + 4 ",
      "-*- ",
    ],
  },
  {
    heading: "Получить из массива строк те, которые являются подстроками второго массива  ",
    href: "https://www.youtube.com/watch?v=F2eYgsFuuJ0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=12",
    taskCode: [
      "Даны два массива строк a и b. Возвратить массив, в котором элементы из массива a являются подстроками строк b.",
      "const inArray = ( a: string[], b: string[] ) => { ",
      "    // Отфильтруем массив a по условию: в массиве b есть хотя бы одна срока (метод b.some( str )), ",
      "    // которая содержит в себе такую подстроку ( метод str.includes( sub ) ):",
      "    return a.filter(( sub ) => b.some(( str ) => str.includes( sub )));",
      "}; ",
      "console.log(inArray([ 'ля', 'ты', 'редис' ], [ 'коты', 'цапля', 'крысолов' ])); // [ 'ля', 'ты' ]",
      "-*-",
    ],
  },
  {
    heading: "Разбить прямоугольник на группу квадратов.",
    href: "https://www.youtube.com/watch?v=rJw30E-9kC4&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=13",
    taskCode: [
      "Нужно представить прямоугольник в виде группы квадратов. Есть прямоугольник размерами 3 * 5, мы его делим на квадраты: 3 * 3, 2 * 2, 1 * 1, 1 * 1. ",
      "Алгоритм:  ",
      "1. Нужно выбрать в нашем прямоугольнике меньшую сторону, в нашем случае - это сторона 3. Вырезаем из нашего прямоугольника квадрат 3 * 3. В остатке у нас прямоугольник 2 * 3.",
      "2. Производим точно такие операции с остаточным прямоугольником 2 * 3. Меньшая сторона равна 2, вырезаем квадарт 2 * 2. В остатке у нас прямоугольник 1 * 2.",
      "3. Продолжаем в том же духе.",
      "-*-",
      "Напишем функцию, у нас есть сторона a и сторона b. ",
      "const sqInRect = ( a: number, b: number ): number[] => {",
      "    // База рекурсии: если сторона a строго равна стороне b, то возвращаем массив из стороны a. ",
      "    if ( a === b ) return [ a ]; ",
      "    //",
      "    // Иначе, заводим константу, в которой лежат большая и меньшая стороны,",
      "    // и проверим какая сторона больше. Меньшую сторону заносим в min, большую - в max.",
      "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
      "    //",
      "    // Мы определились, какая сторона наименьшая, а какая наибольшая и остаётся одна операция с рекурсией.",
      "    // Возвратим массив, в котором будет лежать наша минимальная сторона,",
      "    // воспользуемся спред- оператором, потому, что мы каждый раз будем возвращать массив.",
      "    // Используем функцию sqInRect(), внутри которой у нас разность сторон",
      "    // и минимальная сторона - размеры остаточного прямоугольника.",
      "    return [ min, ...sqInRect( max - min, min )];",
      "}; ",
      "-*-",
      "Функция в чистом виде: ",
      "const sqInRect = ( a: number, b: number ): number[] => { ",
      "    if ( a === b ) return [ a ]; ",
      "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
      "    return [ min, ...sqInRect( max - min, min )];",
      "}; ",
      "console.log(sqInRect(5, 3));    // [ 3, 2, 1, 1 ] ",
      "console.log(sqInRect(3, 5));    // [ 3, 2, 1, 1 ] ",
      "console.log(sqInRect(7, 5));    // [ 5, 2, 2, 1, 1 ] ",
      "console.log(sqInRect(20, 14));  // [ 14, 6, 6, 2, 2, 2 ] ",
      "-*-",
    ],
  },
  {
    heading: "Валидация IP-адреса ",
    href: "https://www.youtube.com/watch?v=_d3Q2xStf8E&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=14",
    taskCode: [
      "Нужно свалидировать IP-адрес. Адрес следует считать действительным, если он состоит из четырёх групп чисел со значением от 0 до 255 включительно. ",
      "Примеры допустимых входных данных: ",
      "// 1.2.3.4 ",
      "// 123.45.67.89 ",
      "Недопустимые примеры ввода: ",
      "// 1.2.3 ",
      "// 1.2.3.4.5",
      "// 123.456.78.90 ",
      "// 123.045.067.089 ",
      "-*-",
      "const isValid = (str: string) => { ",
      "    // На входе строка '12.255.56.1'. Для начала выделяем группы чисел, разделяем ",
      "    // строчку посимвольно методом split() с разделитетелем точка '.'",
      "    const numbers = str.split('.'); // ['12', '255', '56', '1']",
      "    //",
      "    // Сраниваем получившиеся количество групп с заданным числом: numbers.length === 4",
      "    // В filter((n) => +n) приводим строку к числу (+n) и проверяем это число",
      "    // на соответствие интервалу от 0 до 255",
      "    // String(+n).length <= таким образом мы обрабатываем такой IP: 'n1.2.3.4'",
      "    //",
      "    return (",
      "        numbers.length === 4 ",
      "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
      "            && n.length === String(+n).length).length === 4",
      "    );",
      "}; ",
      "-*- ",
      "Пишем нашу функцию  в чистом виде: ",
      "const isValid = ( str: string ) => { ",
      "    const numbers = str.split('.');",
      "    return (",
      "        numbers.length === 4 ",
      "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
      "            && n.length === String(+n).length).length === 4",
      "    );",
      "}; ",
      "-*-",
      "console.log(isValid( '0.0.0.0' ));         // [ '0', '0', '0', '0' ]        // true ",
      "console.log(isValid( '12.255.56.1' ));     // [ '12', '255', '56', '1' ]    // true ",
      "console.log(isValid( '137.255.1.100' ));   // [ '137', '255', '1', '100' ]  // true ",
      "console.log(isValid( '123.456.789.0' ));   // [ '123', '0' ]                // false ",
      "console.log(isValid( 'abc.def.ghi.jkl' )); // []                            // false ",
      "console.log(isValid( 'n1.2.3.4' ));        // [ '2', '3', '4' ]             // false ",
      "console.log(isValid( '' ));                // false                         // false ",
      "-*-",
    ],
  },
  {
    heading: "Сколько ещё в очереди стоять? ",
    href: "https://www.youtube.com/watch?v=YLc1G12T_jY&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=15",
    taskCode: [
      "В супермаркете очередь к кассам самообслуживания. Нужно написать функцию для расчёта общего времени, необходимого всем покупателям для оформления заказов. Несколько уточнений:",
      "    - существует только ОДНА очередь, обслуживающая множество касс;",
      "    - порядок очереди НИКОГДА не меняется и первый человек в очереди (то есть первый элемент в массиве) проходит к кассе, как только она освобождается. ",
      "Аргументы функции: ",
      "    'customers'- клиенты: массив положительных целых чисел - людей, представляющих очередь. Каждое целое число (каждый элемент массива) представляет покупателя, а его значение - количество времени, которое ему требуется для оформления заказа.",
      "    'n' - количество касс: положительное целое число. ",
      " Выход: функция должна возвращать целое число - общее требуемое время. ",
      "Примеры:  ",
      "const queueTime = (customers, n) => {} // наша функция",
      "- queueTime([ 2, 3, 4 ], 1)  // => 9",
      "    // Когда есть только одна касса, то общее время - это сумма времени,  ",
      "    //  потраченного на каждого покупателя.",
      "- queueTime([ 2, 3, 8 ], 2)  // => 10",
      "    // Первый и второй покупатели идут по разным кассам,",
      "    // третий ждёт и подходит к первой освободившейся.",
      "- queueTime([ 11, 2, 3, 3 ], 2)  // => 11",
      "    // Две кассы. Пока первый покупатель стоит на свой кассе 11 едениц времени,",
      "    // за это время 2-й, 3-й и 4-й покупатели уже расплатились.",
      "-*-",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
];

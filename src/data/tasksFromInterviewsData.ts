/* eslint-disable no-useless-escape */
/* eslint-disable no-template-curly-in-string */

import { IObjectTasks } from "../models/types";

export const arrayTasks: IObjectTasks[] = [
  {
    heading: "Удалить пробелы из строки. Метод string.replace() с регулярным выражением внутри.",
    href: "https://www.youtube.com/watch?v=awtOmYDEMY8&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=4",
    taskCode: [
      "const [ str, setStr ] = useState(' ftu ft ggwr '); ",
      "const [ strNoSpace, setStrNoSpace ] = useState(''); ",
      "- ",
      "function noSpace(x: string) { ",
      "         return x.replace(/s/g, ''''); ",
      "} ",
      "useEffect(() => {",
      "         setStrNoSpace(noSpace(str)); ",
      "}, [ str ]); ",
      "- ",
      "   console.log(str); // ' ftu ft ggwr ' ",
      "   console.log(strNoSpace); // ftuftggwr ",
      "-*- ",
    ],
  },
  {
    heading: "Очистить строку от числовых символов. Метод string.replaceAll() с регулярным выражением внутри. ",
    href: "https://www.youtube.com/watch?v=oQ-0bm9-_yA&list=PLPiq_hi6UrQo3ornWsqYnivc77kPn3Gwi&index=6",
    taskCode: [
      "const [ elem ] = useState( 'This looks5 grea8te' ); ",
      "const [ elemClear, setElemClear ] = useState( '' );",
      "- ",
      "function stringCleaner( s: string ) { ",
      "      return s.replaceAll( /d/g, '''' );",
      "} ",
      "useEffect(() => { ",
      "      setElemClear( stringCleaner( elem )); ",
      "}, [ elem ]); ",
      "- ",
      "   console.log( elem ); // 'This looks5 grea8te' ",
      "   console.log( elemClear ); // This looks greate ",
      "-*- ",
    ],
  },
  {
    heading: "Чётное или нечётное? ",
    href: "https://www.youtube.com/watch?v=KwU3wq5DT90&t=77s",
    taskCode: [
      "const number = 1263; ",
      "const number2 = 1264; ",
      "- ",
      "function even_or_odd(number: number) { ",
      "      return number % 2 === 0 ? 'чётное' : 'нечётное'; ",
      "}",
      "- ",
      "   console.log(even_or_odd(number)); // нечётное ",
      "   console.log(even_or_odd(number2)); // чётное ",
      "-*- ",
    ],
  },
  {
    heading: "Вывод пользователей, которые лайкнули публикацию. Используем switch. ",
    href: "https://www.youtube.com/watch?v=XoKmzVPoQ_0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=1&t=20s",
    taskCode: [
      "Дан массив пользователей, которые лайкнули публикацию. Необходимо вывести имена этих пользователей строкой. Используем конструкцию switch.",
      "const printPeopleLiked = (names: string[]) => { ",
      "  switch (names.length) { ",
      "     case 0:",
      "       return 'Нет лайков';",
      "     case 1:",
      "       return `${names[0]} поставил лайк`;",
      "     case 2:",
      "       return `${names[0]} и ${names[1]} поставили лайк`;",
      "     case 3:",
      "       return `${names[0]}, ${names[1]} и ${names[2]} поставили лайк`;",
      "     default:",
      "       return `${names[0]}, ${names[1]} и ещё ${names.length - 2} поставили лайк`;",
      "  } ",
      "}; ",
      "console.log(printPeopleLiked([])); // Нет лайков ",
      "console.log(printPeopleLiked(['Max'])); // Max поставил лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy'])); // Max и Asy поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb'])); // Max, Asy и Gleb поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika'])); // Max, Asy и ещё 2 поставили лайк ",
      "console.log(printPeopleLiked(['Max', 'Asy', 'Gleb', 'Vika', 'Boris', 'Andrey'])); // Max, Asy и ещё 4 поставили лайк ",
    ],
  },
  {
    heading: "Нужно найти сумму всех чисел, кратных 3 или 5.",
    href: "https://www.youtube.com/watch?v=WCIpXcwvXpw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=2",
    taskCode: [
      "Нужно найти сумму всех чисел, кратных 3 или 5, меньше переданного числа. Например, переданное число 16. Находим все числа, кратные 3 или 5, суммируем их и получаем результат.  ",
      "",
      "16 => 3 + 5 + 6 + 9 + 10 + 12 + 15 => 60. ",
      "- ",
      "const sum35 = ( n: number ) => { ",
      "    let sum = 0; ",
      "    for ( let i = 3; i < n; i++ ) { ",
      "        if ( i % 3 === 0 || i % 5 === 0 ) { ",
      "          sum += i; ",
      "        } ",
      "    } ",
      "    return sum;",
      "}; ",
      "- ",
      "console.log( sum35( 16 )); // 60 ",
      "console.log( sum35( 25 )); // 143 ",
      "-*- ",
    ],
  },
  {
    heading: "Разность массивов. Исключить из массива группу элементов другого массива. ",
    href: "https://www.youtube.com/watch?v=qSCy7RaJ6bg&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=3",
    taskCode: [
      "Как исключить из массива группу элементов из другого массива, например: ",
      "arrayDiff = ( [ 1, 2, 8, 2, 7, 3 ], [ 7, 2 ] ) => [ 1, 8, 3 ] ",
      "const arrayDiff = (source: number[], diff: number[]) => { ",
      "    // Метод filter отсечёт ненужные элементы по условию. Оставим в ",
      "    // результате только такие элементы, которые не входят в массив diff. ",
      "    return source.filter((item) => !diff.includes(item)); ",
      " }; ",
      "- ",
      "useEffect(() => { ",
      "    console.log(arrayDiff([2, 3, 4, 5, 6, 7, 8], [7, 2])); // (5) [3, 4, 5, 6, 8]",
      "  }, []); ",
      "-*- ",
    ],
  },
  {
    heading: "Как отформатировать строку и превратить её в телефонный номер. ",
    href: "https://www.youtube.com/watch?v=JbaVl29kVbI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=4",
    taskCode: [
      "Дана строка '1234567890'. Нужно первые три символа обернуть в скобки, потом пробел, потом три символа, дефис и ещё четыре символа: (123) 456-7890.",
      "Для подобных задач пригодятся регулярные выражения, а точнее, скобочные выражения для нахождения подстрок и метод replace().  ",
      "    // Первым аргументом в методе: поиск совпадений в строке. В нашем случае нужно запомнить первые три числовые символа (/d{3}).  (Здесь должен быть обратный слэш.) ",
      "    // Подобным образом запомним следующие 3 числа (/d{3}) и 4 после (/d{4}). (Здесь должен быть обратный слэш.) ",
      "    // Для замены текста используем обозначение '($1) $2-$3': ($1 оборачиваем в скобки - пробел, $2 - дефис, $3)",
      "- ",
      "const createPhoneNumber = (str: string) => { ",
      "    return str.replace(/(/d{3})(/d{3})(/d{4})/, '($1) $2-$3'); // (Здесь должен быть обратный слэш.)  ",
      "}; ",
      "- ",
      "useEffect(() => { ",
      "    console.log(createPhoneNumber('1234567890')); // (123) 456-7890 ",
      "}, []); ",
      "-*-",
    ],
  },
  {
    heading: "Перевести буквы в числа по их позиции в алфавите. ",
    href: "https://www.youtube.com/watch?v=_HmpuK3ori0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=5",
    taskCode: [
      "Как перевести слово в группу чисел, где каждое число - позиция буквы в алфавите. Если слово 'Азбука', то нужно превратить его в '1 8 2 20 11 1' .",
      "Для начала стандартной операции для преобразования строки, приведём её к нижнему регистру (toLowerCase()), разделим посимвольно (split('')) и будем использовать метод map(), который будет трансформировать каждый элемент массива в коллбэк внутри с одним аргументом (char => charCodeAt()). Метод charCodeAt() возвращает числовое значение юниткода для символа по указанному индексу.",
      "'Азбука'.charCodAt(0) // 1040. То есть заглавная русская буква А хранится в юникод под номером 1040. ",
      "'азбука'.charCodAt(0) // 1072. Маленькая русская буква 'а' хранится в юникод под номером 1072.",
      "  Значит, вычитая из результата число 1071, мы будем получать позицию каждой буквы в алфавите.",
      "console.log('азбука'.charCodeAt(0) - 1071); // 1 ",
      "console.log('азбука'.charCodeAt(1) - 1071); // 8 ",
      "console.log('азбука'.charCodeAt(2) - 1071); // 2 ",
      "console.log('азбука'.charCodeAt(3) - 1071); // 20 ",
      "console.log('азбука'.charCodeAt(4) - 1071); // 11 ",
      "console.log('азбука'.charCodeAt(5) - 1071); // 1 ",
      "-",
      "Наша общая функция будет выглядеть так: ",
      "const alphabetPosition = (str: string) => { ",
      "    return str ",
      "        .toLowerCase() ",
      "        .split('') // по пустому разделителю",
      "        .map((char) => char.charCodeAt(0) - 1071)",
      "        .join(' '); // по пробелу",
      "}; ",
      "console.log(alphabetPosition('Азбука')); // 1 8 2 20 11 1 ",
      "-*-",
    ],
  },
  {
    heading: "Схлопнуть соседние элементы. ",
    href: "https://www.youtube.com/watch?v=hnmmm9iOAUo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=6",
    taskCode: [
      "Напишите функцию, которая принимает последовательность (это может быть массив или строка) и возвращает массив, где повторяющиеся сосоедние элементы схлопнулись до одного. Исходный порядок элементов нужно сохранить. ",
      "Решим эту задачу через фильтр. Для этого развернём нашу последовательность на входе ( iterable ) => [ ...iterable ]. Мы получим массив, даже если заспредим строку. Затем отфильтруем элементы этого массива таким образом, чтобы в новый массив попали только те элементы, которые не равны элементу из последовательности по индексу и -1",
      "Наша функция будет выглядеть так:",
      "function uniqueInOrder(iterable: string | string[] | number[]) { ",
      "    return [...iterable].filter((el, index) => el !== iterable[index - 1]); ",
      "} ",
      "- ",
      "console.log(uniqueInOrder('AAAABBBCCDAABBB')); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
      "console.log(uniqueInOrder('ABBCcAD')); // ['A', 'B', 'C', 'c', 'A', 'D'] ",
      "console.log(uniqueInOrder(['A', 'A', 'A', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B'])); // ['A', 'B', 'C', 'D', 'A', 'B'] ",
      "console.log(uniqueInOrder([1, 1, 2, 2, 2, 3, 3, 4, 4])); // [1, 2, 3, 4] ",
      "-*-",
    ],
  },
  {
    heading: "Написать функцию по выявлению пагнрамм.",
    href: "https://www.youtube.com/watch?v=wE3YcgtTZlo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=7",
    taskCode: [
      "Написать функцию по выявлению пагнрамм - фраз, содержащих в себе все буквы алфавита. ",
      "Вычислить панграмму в JS просто: нужно занести в Set- коллекцию нашу преобразованную строку. Как её преобразовать: сначала приводим все буквы к нижнему регистру, а затем, с помощью регулярного выражения оставим только буквы русского алфавита. Используем буквы от 'а' до 'я' начала строки и букву 'ё', потому, что она не включается стандартно и глобально. Всё это заменяем на пустую строку replace(/[^а-яё]/g, '')",
      "Set- коллекция исключит из массива повторяющиеся элементы, оставит только уникальные, и у это коллекции есть метод size. Если size === 33 (количество букв в алфавите), то значит это фраза - паграмма   ",
      "- ",
      "const isPangram = (str: string) => { ",
      "    const set = new Set([...str.toLowerCase().replace(/[^а-яё/]/g, '')]); ",
      "    return set.size === 33; ",
      "}; ",
      "Эта фраза не является панграммой: ",
      "    console.log(isPangram('Мама мыла раму')); // false ",
      "Эта фраза - панграмма:",
      "    console.log(isPangram('Съешь ещё этих мягких французских булочек, да выпей же чаю')); // true ",
      "-*- ",
    ],
  },
  {
    heading: "Нарисуй ёлку из символов, например, из звёзд. ",
    href: "https://www.youtube.com/watch?v=DZ4oAPBmvDI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=8",
    taskCode: [
      "На вход поступает высота ёлки. Ёлка симметрична, поэтому нужно понять, сколько пробелов должно быть в ряду, с обоих сторон от звёзд. С самими звёздами всё ясно, их в ряду будет: 1, 3, 5, 7, 9. Для высоты = 5 будет 9 звёзд в нижнем ряду и 0 пробелов. Значит в первом ряду будет 4 пробела, 1 звезда и опять 4 пробела.",
      "const drawChristmasTree = (n: any) => { ",
      "    let tree = '\n'; ",
      "    for (let i = 0; i < n; i++) { ",
      "        const space = ' '.repeat(n - i - 1); ",
      "        tree += space + '*'.repeat(i + i + 1) + space + '\n'; ",
      "    } ",
      "    return tree; ",
      " }; ",
      "console.log(drawChristmasTree(5)); ",
      "    * ",
      "   *** ",
      "  ***** ",
      " ******* ",
      "********* ",
      "console.log(drawChristmasTree(6)); ",
      "     * ",
      "    *** ",
      "   ***** ",
      "  ******* ",
      " ********* ",
      "*********** ",
      "-*- ",
    ],
  },
  {
    heading: "Валидация строк со скобками. ",
    href: "https://www.youtube.com/watch?v=cNPsxKh4s5U&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=9",
    taskCode: [
      "-*- У меня это решение вызывает ошибку-*-",
      "Напиши валидацию строк с круглыми, квадратными и фигурными скобками. Считаем, что результат правильный, если все скобки открываются и закрываются в нужном порядке. ",
      "Например: ",
      "isValidBraces('(){}[]') // true ",
      "isValidBraces('({[]})') // true ",
      "isValidBraces('(}')     // false ",
      "isValidBraces('[(])')   // false ",
      "isValidBraces('[({}(]') // false ",
      "Стек - это структура данных, представляющие собой список элементов, организованных по принципу: последним зашёл - первым вышел.  ",
      "Мы будем идти по каждому символу в строке и класть в стек открывающиеся скобки. А если будем видеть закрывающую скобку, то будем проверять, соответсвует ли её тип с типом последней последней скобки в стеке. Если они не одного и того же типа, то можно сразу возвращать ложь, не дожидаясь завершения цикла. Если мы вышли из цикла без подобных остановок, то осталось проверить размер стека. Если он равен нулю, то это значит, что в нём не осталось открытых скобок. А значит входная строка валидна. Если хотя бы один элемент в стеке есть, то значит строка не валидна.   ",
      "const isValidBraces = (str: string) => { ",
      "    const braces = { '{': '}', '(': ')', '[': ']' }; ",
      "    const stack = []; ",
      "    for (let i = 0; i < str.length; i++) { ",
      "       const currentBrace = str[i] as keyof typeof braces;",
      "       if (braces[currentBrace]) { ",
      "           stack.push(currentBrace); ",
      "       } else if (currentBrace !== braces[stack.pop()]) { // ts(2538)",
      "       // Тип 'undefined' невозможно использовать как тип индекса.ts(2538)",
      "       // (method) Array<string>.pop(): string | undefined",
      "           return false; ",
      "       } ",
      "    } ",
      "    return stack.length === 0; ",
      "}; ",
      "-*- ",
      "У меня это решение вызывает ошибку. ",
    ],
  },
  {
    heading: "Пересечения массивов",
    href: "https://www.youtube.com/watch?v=APuD-xNMBGc&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=10",
    taskCode: [
      "Нужно написать функцию, которая принимает два массива и возвращает массив с их пересечениями - элементы должны присутствовать и в первом, и во втором массиве. Причём, элемент должен повториться в массиве два и более раза. ",
      "Для начала выбираем только повторяющие числа, для этого создадим Set- коллекцию уникальных элементов, в которой будут лежат элементы, которые хотя бы раз встречались в массиве. А в объекте pick будем собирать числа, которые повторились два или более раз.    ",
      "Пройдём по перому массиву методом forEach(), проверим для каждого числа в массиве условие: если в Set- коллекции нет текущего числа (has()), то занесём его в коллекцию. Иначе, число уже встречалось в массиве, а значит оно повторяющееся. Положим повторяющееся число в объект pick, ключём станет станет само повторяющее число из первого массива, а значением 0 - количество будущих повторений во втором массиве. Получили объект, где ключи - повторяющиеся числа из первого массива, а значения - количество повторений уже во втором массиве. Осталось только преобразовать этот объект в массив, в котором будут лежать только ключи.       ",
      "Проверим, что всё получилось так, как надо. ",
      "Так же проходим по второму массиву, если число из второго массива является ключём в объекте pick, то увеличим его значение на 1.    ",
      "const intersectNubmers = (a: number[], b: number[]) => { ",
      "    const set = new Set(); ",
      "    const pick: any = {};",
      "    // ",
      "    a.forEach((n: number) => {",
      "      if (!set.has(n)) {",
      "        set.add(n); ",
      "      } else {",
      "        pick[n] = 0;",
      "      }",
      "    }); ",
      "    // return pick; // {1: 0, 17: 0, 56: 0} // результат проверки первого массива",
      "    // Проверяем второй массив",
      "    b.forEach((n: number) => {",
      "      if (n in pick) {",
      "        pick[n] = pick[n] + 1;",
      "      }",
      "    });",
      "    // return pick; // {1: 3, 17: 2, 56: 1} // результат проверки обоих массивов",
      "    // Преобразуем объект в массив, в котором будут лежать только ключи",
      "    return Object.entries(pick).reduce((result, [n, count]) => {",
      "      if ((count as number) > 1) {",
      "        result.push(+n);",
      "      }",
      "      return result;",
      "    });",
      "}; ",
      "console.log(intersectNubmers([7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1])); ",
      "-*-",
    ],
  },
  {
    heading: "Представление числа в расширенной нотации.",
    href: "https://www.youtube.com/watch?v=ukx4y4HjhtI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=11",
    taskCode: [
      "Вернуть заданное число в виде строки в расширенной форме. Все числа будут целыми числами больше нуля. ",
      "Что такое расширенная анотация - это когда число представляется в виде суммы каждой цифры, умноженное на соответствующее значение её разряда. Например:   ",
      "expandedForm(12); // => '10 + 2' ",
      "expandedForm(42); // => '40 + 2' ",
      "expandedForm(70304); // => '70000 + 300 + 4' ",
      "--",
      "Наша функция: ",
      "const expandedForm =  ( num: number ) => {   // на входе num = 70304",
      "    return ( ",
      "        String( num ) // Переводим число в строку '70304' ",
      "            .split( '' ) // Разбиваем эту строку посимвольно [ '7', '0', '3', '0', '4' ] ",
      "            // К каждому символу прибавляем определённое количество нулей: ",
      "            .map(( n, i, arr ) => n + '0'.repeat( arr.length - i - 1 )) // [ '70000', '0000', '300', '00', '4' ] ",
      "            // Отфильтруем, оставим всё, что не равно нулю ",
      "            .filter(( n ) => Number( n ) !== 0 ) // [ '70000', '300', '4' ] ",
      "            // Объеденим элементы массива в строку, поставив между ними знак '+'",
      "            .join(' + ') // 70000 + 300 + 4",
      "     ); ",
      "}; ",
      "console.log(expandedForm(12)); // 10 + 2 ",
      "console.log(expandedForm(42)); // 40 + 2 ",
      "console.log(expandedForm(70304)); // 70000 + 300 + 4 ",
      "-*- ",
    ],
  },
  {
    heading: "Получить из массива строк те, которые являются подстроками второго массива  ",
    href: "https://www.youtube.com/watch?v=F2eYgsFuuJ0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=12",
    taskCode: [
      "Даны два массива строк a и b. Возвратить массив, в котором элементы из массива a являются подстроками строк b.",
      "const inArray = ( a: string[], b: string[] ) => { ",
      "    // Отфильтруем массив a по условию: в массиве b есть хотя бы одна срока (метод b.some( str )), ",
      "    // которая содержит в себе такую подстроку ( метод str.includes( sub ) ):",
      "    return a.filter(( sub ) => b.some(( str ) => str.includes( sub )));",
      "}; ",
      "console.log(inArray([ 'ля', 'ты', 'редис' ], [ 'коты', 'цапля', 'крысолов' ])); // [ 'ля', 'ты' ]",
      "-*-",
    ],
  },
  {
    heading: "Разбить прямоугольник на группу квадратов.",
    href: "https://www.youtube.com/watch?v=rJw30E-9kC4&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=13",
    taskCode: [
      "Нужно представить прямоугольник в виде группы квадратов. Есть прямоугольник размерами 3 * 5, мы его делим на квадраты: 3 * 3, 2 * 2, 1 * 1, 1 * 1. ",
      "Алгоритм:  ",
      "1. Нужно выбрать в нашем прямоугольнике меньшую сторону, в нашем случае - это сторона 3. Вырезаем из нашего прямоугольника квадрат 3 * 3. В остатке у нас прямоугольник 2 * 3.",
      "2. Производим точно такие операции с остаточным прямоугольником 2 * 3. Меньшая сторона равна 2, вырезаем квадарт 2 * 2. В остатке у нас прямоугольник 1 * 2.",
      "3. Продолжаем в том же духе.",
      "-*-",
      "Напишем функцию, у нас есть сторона a и сторона b. ",
      "const sqInRect = ( a: number, b: number ): number[] => {",
      "    // База рекурсии: если сторона a строго равна стороне b, то возвращаем массив из стороны a. ",
      "    if ( a === b ) return [ a ]; ",
      "    //",
      "    // Иначе, заводим константу, в которой лежат большая и меньшая стороны,",
      "    // и проверим какая сторона больше. Меньшую сторону заносим в min, большую - в max.",
      "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
      "    //",
      "    // Мы определились, какая сторона наименьшая, а какая наибольшая и остаётся одна операция с рекурсией.",
      "    // Возвратим массив, в котором будет лежать наша минимальная сторона,",
      "    // воспользуемся спред- оператором, потому, что мы каждый раз будем возвращать массив.",
      "    // Используем функцию sqInRect(), внутри которой у нас разность сторон",
      "    // и минимальная сторона - размеры остаточного прямоугольника.",
      "    return [ min, ...sqInRect( max - min, min )];",
      "}; ",
      "-*-",
      "Функция в чистом виде: ",
      "const sqInRect = ( a: number, b: number ): number[] => { ",
      "    if ( a === b ) return [ a ]; ",
      "    const [ min, max ] = a < b ? [ a, b ] : [ b, a ];",
      "    return [ min, ...sqInRect( max - min, min )];",
      "}; ",
      "console.log(sqInRect(5, 3));    // [ 3, 2, 1, 1 ] ",
      "console.log(sqInRect(3, 5));    // [ 3, 2, 1, 1 ] ",
      "console.log(sqInRect(7, 5));    // [ 5, 2, 2, 1, 1 ] ",
      "console.log(sqInRect(20, 14));  // [ 14, 6, 6, 2, 2, 2 ] ",
      "-*-",
    ],
  },
  {
    heading: "Валидация IP-адреса ",
    href: "https://www.youtube.com/watch?v=_d3Q2xStf8E&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=14",
    taskCode: [
      "Нужно свалидировать IP-адрес. Адрес следует считать действительным, если он состоит из четырёх групп чисел со значением от 0 до 255 включительно. ",
      "Примеры допустимых входных данных: ",
      "// 1.2.3.4 ",
      "// 123.45.67.89 ",
      "Недопустимые примеры ввода: ",
      "// 1.2.3 ",
      "// 1.2.3.4.5",
      "// 123.456.78.90 ",
      "// 123.045.067.089 ",
      "-*-",
      "const isValid = (str: string) => { ",
      "    // На входе строка '12.255.56.1'. Для начала выделяем группы чисел, разделяем ",
      "    // строчку посимвольно методом split() с разделитетелем точка '.'",
      "    const numbers = str.split('.'); // ['12', '255', '56', '1']",
      "    //",
      "    // Сраниваем получившиеся количество групп с заданным числом: numbers.length === 4",
      "    // В filter((n) => +n) приводим строку к числу (+n) и проверяем это число",
      "    // на соответствие интервалу от 0 до 255",
      "    // String(+n).length <= таким образом мы обрабатываем такой IP: 'n1.2.3.4'",
      "    //",
      "    return (",
      "        numbers.length === 4 ",
      "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
      "            && n.length === String(+n).length).length === 4",
      "    );",
      "}; ",
      "-*- ",
      "Пишем нашу функцию в чистом виде: ",
      "const isValid = ( str: string ) => { ",
      "    const numbers = str.split('.');",
      "    return (",
      "        numbers.length === 4 ",
      "            && numbers.filter((n) => +n >= 0 && +n <= 255 ",
      "            && n.length === String(+n).length).length === 4",
      "    );",
      "}; ",
      "-*-",
      "console.log(isValid( '0.0.0.0' ));         // [ '0', '0', '0', '0' ]        // true ",
      "console.log(isValid( '12.255.56.1' ));     // [ '12', '255', '56', '1' ]    // true ",
      "console.log(isValid( '137.255.1.100' ));   // [ '137', '255', '1', '100' ]  // true ",
      "console.log(isValid( '123.456.789.0' ));   // [ '123', '0' ]                // false ",
      "console.log(isValid( 'abc.def.ghi.jkl' )); // []                            // false ",
      "console.log(isValid( 'n1.2.3.4' ));        // [ '2', '3', '4' ]             // false ",
      "console.log(isValid( '' ));                // false                         // false ",
      "-*-",
    ],
  },
  {
    heading: "Сколько ещё в очереди стоять? ",
    href: "https://www.youtube.com/watch?v=YLc1G12T_jY&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=15",
    taskCode: [
      "В супермаркете очередь к кассам самообслуживания. Нужно написать функцию для расчёта общего времени, необходимого всем покупателям для оформления заказов. Несколько уточнений:",
      "    - существует только ОДНА очередь, обслуживающая множество касс;",
      "    - порядок очереди НИКОГДА не меняется и первый человек в очереди (то есть первый элемент в массиве) проходит к кассе, как только она освобождается. ",
      "Аргументы функции: ",
      "    'customers'- клиенты: массив положительных целых чисел - людей, представляющих очередь. Каждое целое число (каждый элемент массива) представляет покупателя, а его значение - количество времени, которое ему требуется для оформления заказа.",
      "    'n' - количество касс: положительное целое число. ",
      " Выход: функция должна возвращать целое число - общее требуемое время. ",
      "Примеры:  ",
      "const queueTime = (customers, n) => {} // наша функция",
      "1. queueTime([ 2, 3, 4 ], 1)  // => 9",
      "    // Когда есть только одна касса, то общее время - это сумма времени,  ",
      "    //  потраченного на каждого покупателя.",
      "2. queueTime([ 2, 3, 8 ], 2)  // => 10",
      "    // Первый и второй покупатели идут по разным кассам,",
      "    // третий ждёт и подходит к первой освободившейся.",
      "3. queueTime([ 11, 2, 3, 3 ], 2)  // => 11",
      "    // Две кассы. Пока первый покупатель стоит на свой кассе 11 едениц времени,",
      "    // за это время 2-й, 3-й и 4-й покупатели уже расплатились.",
      "-*-",
      "Создадим нашу функцию:",
      "const queueTime = (customers: number[], n: number) => { ",
      "    // Если количество покупателей равно количеству касс.",
      "    if (customers.length === 0) return 0;",
      "    .",
      "    // Если количество покупателей меньше количества касс.",
      "    if (customers.length <= n) return Math.max(...customers);",
      "    .",
      "    // Если количество покупателей больше количества касс, например ([ 2, 3, 8 ], 2 ).",
      "    // Введём новую переменную queues (массив очередей - количество сумм времени",
      "    // в этих очередях), в нём будет n - элементов (количество касс), значение",
      "    // которых определим равными нулю fill( 0 ). То есть, мы создали очереди к кассам:",
      "    // к первой кассе стоит первый клиент, ко второй - второй клиент. Если какая-то",
      "    // касса освобождается, то к ней подходит очередной клиент.",
      "    // 1-й элемент массива будет принимать время первого человека,",
      "    // второй - время второго человека. Изначальное время для всех задали равное нулю.",
      "    .",
      "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
      "    .",
      "    // Пройдём по массиву покупателей",
      "    for ( const time of customers ) {",
      "        // Будем находить индекс у массива очередей. Мы берём самое меньшее число в очередях,",
      "        // и находим его индекс. Так мы получаем самую свободную на данный момент кассу",
      "        // - индекс кассы. ",
      "        const index = queues.indexOf( Math.min( ...queues ));",
      "        //",
      "        // У нас есть список очередей, есть индекс, и мы прибавляем к тому что есть там",
      "        // определённое время - значение элемента массива покупателей customers.",
      "        // Фактически, мы заполняем наш массив очередей.",
      "        queues[index] += time; // Array [ (2 + 8), 3 ] =  [ 10, 3 ]",
      "    } ",
      "    // Нам в конце остаётся только возвратить самое большое число из массива очередей. ",
      "    return Math.max(...queues); // 10",
      "}; ",
      "-*-",
      "Пишем нашу функцию в чистом виде: ",
      "const queueTime = ( customers: number[], n: number ) => {  ",
      "    if ( customers.length === 0 ) return 0; ",
      "    if ( customers.length <= n ) return Math.max( ...customers ); ",
      ". ",
      "    const queues: number[] = new Array( n ).fill( 0 ); //  Array [ 0, 0 ]",
      "    for (const time of customers) {",
      "        const index = queues.indexOf(Math.min( ...queues ));",
      "        queues[ index ] += time;",
      "    } ",
      "    return Math.max( ...queues ); ",
      "};",
      "-*-",
      "console.log(queueTime([ 2, 3, 4 ], 1 )); // 9 ",
      "console.log(queueTime([ 2, 3, 8 ], 2 )); // 10 ",
      "console.log(queueTime([ 11, 2, 3, 3 ], 2 )); // 11 ",
      "-*-",
    ],
  },
  {
    heading: "Нарисовать таблицу умножения ",
    href: "https://www.youtube.com/watch?v=Hnlf8W04vfk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=16",
    taskCode: [
      "Надо написать функцию, которая возвращает таблицу умножения размерами N * N. Даётся сам размер, например тройка, и мы должны вывести массив, в котором лежат другие массивы, обозначающие строки в нашей результирующей таблице умножения. Стандартный вид таблицы умножения - это когда первые строки по вертикали и по горизонтали содержат цифры от единицы до самого числа size, а внутри перемножение этих чисел.         ",
      "Напимер: ",
      "const multiplicationTable = (size: number) => {}  ",
      "multiplicationTable(3) // => [[1, 2, 3], [2, 4, 6], [3, 6, 9]] ",
      "//  [1, 2, 3] ",
      "//  [2, 4, 6] ",
      "//  [3, 6, 9] ",
      "Пишем функцию: ",
      "const multiplicationTable = (size: number) => { ",
      "    const table: number[][] = []; ",
      "    .",
      "    for (let i = 0; i < size; i++) {",
      "        table[i] = [];",
      "        for (let j = 0; j < size; j++) {",
      "            table[i][j] = (i + 1) * (j + 1);",
      "        } ",
      "    }",
      "    . ",
      "    return table;",
      "}; ",
      "-*-",
      "console.log(multiplicationTable(3)); // [Array(3), Array(3), Array(3)] ",
      "    //  [1, 2, 3] ",
      "    //  [2, 4, 6]",
      "    //  [3, 6, 9] ",
      "console.log(multiplicationTable(10)); ",
      "    // [Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10)] ",
      "    // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ",
      "    // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]",
      "    // [3, 6, 9, 12, 15, 18, 21, 24, 27, 30] ",
      "    // [4, 8, 12, 16, 20, 24, 28, 32, 36, 40] ",
      "    // [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] ",
      "    // [6, 12, 18, 24, 30, 36, 42, 48, 54, 60] ",
      "    // [7, 14, 21, 28, 35, 42, 49, 56, 63, 70] ",
      "    // [8, 16, 24, 32, 40, 48, 56, 64, 72, 80] ",
      "    // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] ",
      "    // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] ",
      "-*-",
    ],
  },
  {
    heading: "Пропущенное число в прогрессии. Выводим формулу разности прогрессии?",
    href: "https://www.youtube.com/watch?v=c1GnHM2cHjo&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=17",
    taskCode: [
      "Задача от FaceBook. Дан массив последовательных элементов арифметической прогрессии, в котором отсутствует ровно одно число. Нужно написать функцию, которая возвратит отсутствующий элемент (он никогда не будет ни первым, ни последним, а массив будет состоять из трёх или более чисел). ",
      "Арифметическая прогрессия - последовательность чисел, в которой каждый следующий элемент можно найти, прибавив к предыдущему число d (delta - разность прогрессии) ",
      "const findMissing = (list) => {} ",
      "findMissing([1, 3, 5, 9, 11]) // => 7",
      "Разность прогрессии d вычисляется по формуле: d = (An - A1) / (n - 1) // это из математики.",
      "-*-",
      "const findMissing = (list: number[]) => { ",
      "    // Сначала найдём то самое n. У нас в заданной прогрессии пропущен один элемент, ",
      "    // этот пропущенный элемент мы и прибавляем к длине данного массива. ",
      "    const n = list.length + 1; ",
      "    .",
      "    // Напишем формулу для вычисления разности прогрессии",
      "    // list[list.length] - это последний элемент в арифметической прогрессии.",
      "    // list[list.length - 1] это последний элемент в заданном массиве, где пропущен один элемент. ",
      "    // Для сокращения памяти выражение (n - 1) заменим на list.length, так это однозначно.",
      "    .",
      "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
      "    // const d = (list[list.length - 1] - list[0]) / list.length;",
      "    .",
      "    for (let i = 0; i < list.length; i++) {",
      "        // предположительное следующее число",
      "        .",
      "        const estimatedNextNumbers = list[i] + d;",
      "        // Сравним предположительное следующее число со следующим элементом, который уже лежит в массиве.",
      "        if (estimatedNextNumbers !== list[i + 1]) {",
      "            return estimatedNextNumbers;",
      "        } ",
      "    } ",
      "}; ",
      "-*-",
      "Перепишем нашу функцию в чистом виде: ",
      "const findMissing = (list: number[]) => { ",
      "    const n = list.length + 1; ",
      "    const d = (list[list.length - 1] - list[0]) / (n - 1);",
      "    .",
      "    for (let i = 0; i < list.length; i++) {",
      "        const estimatedNextNumbers = list[i] + d;",
      "        .",
      "        if (estimatedNextNumbers !== list[i + 1]) { ",
      "            return estimatedNextNumbers;",
      "        } ",
      "    } ",
      "}; ",
      "-*-",
      "console.log(findMissing([1, 3, 5, 9, 11]));            //   7 ",
      "console.log(findMissing([1, 3, 5, 7, 9, 13]));         // 11 ",
      "console.log(findMissing([1, 4, 7, 10, 16, 19]));     // 13 ",
      "-*-",
    ],
  },
  {
    heading: "Решётка заменила Backspace",
    href: "https://www.youtube.com/watch?v=dT7hc6lqyn0&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=18",
    taskCode: [
      "Напишите логику, подобную клавише 'Backspace'. Функция будет принимать строку вида 'a#bc#d' и возвращать 'bd'. То есть каждый символ '#' будет как бы стирать последний элемент в строке. ",
      "Напишем нашу функцию: ",
      "const cleanString = (s: string) => {",
      "    // Разбиваем нашу строку посимвольно. После этого воспользуемся функцией высшего порядка ",
      "    // reduce(result, symbol), где result - аккумулятор, а symbol - наш текущий символ строки.",
      "    // Начальное значение result - пустая строка '', мы её будем возвращать в итоге.",
      "    // Если наш символ равен symbol === '#', то мы от result будем срезать последний элемент: ",
      "    // result.slice(0, -1). Иначе к result будем прибавлять очередной символ: result + symbol.",
      "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
      "}; ",
      "-*-",
      "Перепишем нашу функцию в чистом виде: ",
      "const cleanString = (s: string) => { ",
      "    return s.split('').reduce((result, symbol) => (symbol === '#' ? result.slice(0, -1) : result + symbol), '');",
      "}; ",
      "-*-",
      "console.log(cleanString('a#bc#d')); // bd ",
      "console.log(cleanString('abc#d##c')); // ac ",
      "console.log(cleanString('abc##d#####')); // '' ",
      "console.log(cleanString('#####')); // '' ",
      "console.log(cleanString('')); // '' ",
      "-*- ",
    ],
  },
  {
    heading: "Свернуть массив N раз.",
    href: "https://www.youtube.com/watch?v=0XwAo_P49V8&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=19",
    taskCode: [
      "Нужно свернуть массив целых чисел N раз.  ",
      "const foldArray = ( array: number[], runs: number ): number[] => { ",
      "    if ( runs === 0 ) return array; // Это база рекурсии ",
      "    . ",
      "    const result: number[] = []; // Это будет результирующий массив ",
      "    .",
      "    // Мы будем идти от нулевого индекса до середины массива,",
      "    // если середина не целое число, то ничего страшного.",
      "    for ( let i = 0; i < array.length / 2; i++ ) {",
      "        // Создадим переменную зеркальный индекс:",
      "        const mirrorIndex = array.length - i - 1;            // Почему  arr.length - i - 1 ?",
      "        .",
      "        // Зеркальный индекс - индекс элемента, который находится симметрично относительно",
      "        // центра массива. Например, если массив имеет элементы [ 1, 2, 3, 4, 5 ], то зеркальным",
      "        // для элемента 1 будет элемент 5, для элемента 2 - элемент 4.",
      "       .",
      "        // Формула arr.length - i - 1 основана на том факте, что зеркальный индекс элемента",
      "        // находится на расстоянии, равном разности текущего индекса и позиции центрального",
      "        // элемента.",
      "       .",
      "        // Для определения зеркального индекса элемента с индексом i необходимо вычислить",
      "        // разность между позицией центрального элемента и текущим индексом i, а затем",
      "        // вычесть единицу.",
      "        .",
      "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
      "    }",
      "    return foldArray( result, runs - 1 );",
      "}; ",
      "-*-",
      "Перепишем нашу функцию в чистом виде: ",
      "const foldArray = ( array: number[], runs: number ): number[] => { ",
      "    if ( runs === 0 ) return array; ",
      "    .",
      "    const result: number[] = [];",
      "    for ( let i = 0; i < array.length / 2; i++ ) {",
      "        const mirrorIndex = array.length - i - 1;",
      "        result[ i ] = mirrorIndex === i ? array[ i ] : array[ i ] + array[ mirrorIndex ];",
      "    }",
      "    return foldArray( result, runs - 1 );",
      "}; ",
      "-*-",
      "console.log(foldArray([ 1, 2, 3, 4, 5 ], 1 ));             // [ 6, 6, 3 ] ",
      "console.log(foldArray([ 1, 2, 3, 4, 5 ], 2 ));             // [ 9, 6 ] ",
      "console.log(foldArray([ 1, 2, 3, 4, 5 ], 3 ));             // [ 15 ] ",
      "console.log(foldArray([ -9, 9, -8, 8, 66, 23 ], 1 ));  // [ 14, 75, 0 ] ",
      "-*-",
    ],
  },
  {
    heading: "Вывести большее из самых повторяющихся чисел в массиве.",
    href: "https://www.youtube.com/watch?v=sB4CA7tyRJI&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=20",
    taskCode: [
      "Напишите функцию, которая возвращает самое встречающееся число в заданном массиве. При ничьей, между двух и более чисел, вернуть наибольшее число среди них.",
      "К примеру: ",
      "const hignestRank = (arr: number[]) => {}; // наша будущая функция ",
      ". ",
      "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));           // --> 12 ",
      "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8])); // --> 12 ",
      "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));      // --> 3",
      "-*-",
      "Напишем нашу функцию: ",
      "const hignestRank = (arr: number[]) => { ",
      "    // Введём переменную для объекта, где будут лежать ключи - числа массива, ",
      "    // а их значение - количество их повторений.",
      "    const map: any = {};",
      "    .",
      "    // Введём переменную в которой мы будем считать максимальное количество повторений",
      "    // любых чисел. Грубо говоря это будет счётчик максимального количества повторений",
      "    // в нашем массиве. ",
      "    let maxRepeat = 0;",
      "    .",
      "    // Пройдёмся по массиву: какое число нужно присвоить map[n]? Либо 1, если map[n] не",
      "    // существует, либо map[n] + 1, как раз для подсчёта повторений.",
      "    arr.forEach((n) => {",
      "        // Оператор ~~ используется для округления числа с плавающей запятой в меньшую сторону:",
      "        // но самое главное: оператор ~~ приводит undefined к нулю. Что нам в принципе и нужно:",
      "        // для map[n], которого ещё нет, мы скажем ноль плюс 1. Фактически, в для map[n] будут",
      "        // всегда лежать корректные данные.",
      "        map[n] = ~~map[n] + 1;",
      "        .",
      "        if (map[n] > maxRepeat) { ",
      "            // если условие выполняется, то максимальное повторение map[n] заносим в maxRepeat",
      "            maxRepeat = map[n];",
      "        }",
      "    });",
      "    .",
      "    return Object.entries(map).reduce(",
      "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
      "        -Infinity",
      "    );",
      "}; ",
      "-*-",
      "Перепишем нашу функцию в чистом виде: ",
      "const hignestRank = (arr: number[]) => { ",
      "    const map: any = {}; ",
      "    let maxRepeat = 0;",
      "    .",
      "    arr.forEach((n) => { ",
      "        map[n] = ~~map[n] + 1;",
      "        .",
      "        if (map[n] > maxRepeat) {",
      "            maxRepeat = map[n];",
      "        }",
      "    });",
      "    .",
      "    return Object.entries(map).reduce(",
      "        (maxValue, [n, repeat]) => (repeat === maxRepeat && +n > maxValue ? +n : maxValue),",
      "        -Infinity ",
      "    ); ",
      "}; ",
      "-*-",
      "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12]));             // 12 ",
      "console.log(hignestRank([12, 10, 8, 12, 7, 6, 4, 10, 12, 8, 10, 8]));   // 12 ",
      "console.log(hignestRank([12, 10, 8, 8, 3, 3, 2, 4, 10, 12, 3]));        // 3 ",
      "-*-",
    ],
  },
  {
    heading: "Сложение матриц",
    href: "https://www.youtube.com/watch?v=e9MvJCkhBjk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=21",
    taskCode: [
      "Нужно написать функцию, которая принимает две матрицы (массивы массивов) и возвращает их сумму.",
      "const matrixAddition = (a: number[ ][ ], b: number[ ][ ]) => { ",
      "    return a.map(( row, i ) => row.map(( _, j ) => a[ i ][ j ] + b[ i ][ j ])); ",
      "}; ",
      "-*-",
      "console.log( ",
      "    matrixAddition( ",
      "        [",
      "            [ 1, 2, 3 ], ",
      "            [ 3, 2, 1 ],",
      "            [ 1, 1, 1 ],",
      "        ],                        // [ 3, 4, 4 ]",
      "        //    +                 // [ 6, 4, 4 ]",
      "        [                         // [ 2, 2, 4 ]",
      "            [ 2, 2, 1 ],",
      "            [ 3, 2, 3 ],",
      "            [ 1, 1, 3 ],",
      "        ]",
      "    ) ",
      "); ",
      "-*-",
    ],
  },
  {
    heading: "Количество нажатий для ввода текста на старом телефоне.",
    href: "https://www.youtube.com/watch?v=KxUiRrzVH6o&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=22",
    taskCode: [
      "Сколько раз нужно нажать на кнопки на старых телефонах без Т9, чтобы набрать заданный текст? ",
      "-*-",
      "const presses = (str: string): number => { ",
      "    // Создадим переменную, в которой будут лежать наши числа и буквы, они будут ключами,",
      "    // а значением выступит количество их повторений - сколько раз нужно нажать на кнопку. ",
      "    // На старом телефоне, чтобы вывести букву С, нужно три раза нажать на кнопку (2abc).",
      "    const numbers: any = {",
      "        // По сути это клавиатура старого телефона",
      "        '1': 1,",
      "         a: 1, ",
      "         b: 2,",
      "         c: 3,",
      "        '2': 4,",
      "         d: 1,",
      "         e: 2,",
      "         f: 3,",
      "        '3': 4,",
      "         g: 1,",
      "         h: 2,",
      "         i: 3,",
      "        '4': 4,",
      "         j: 1,",
      "         k: 2,",
      "         l: 3,",
      "        '5': 4,",
      "         m: 1, ",
      "         n: 2,",
      "         o: 3,",
      "        '6': 4,",
      "         p: 1,",
      "         q: 2, ",
      "         r: 3,",
      "         s: 4,",
      "        '7': 5, ",
      "         t: 1, ",
      "         u: 2,",
      "         v: 3, ",
      "        '8': 4,",
      "         w: 1, ",
      "         x: 2,",
      "         y: 3,",
      "         z: 4, ",
      "        '9': 5,",
      "        ' ': 1,",
      "        '0': 2,",
      "    }; ",
      "    return str.split('').reduce((sum: number, char: string) => sum + numbers[char.toLowerCase()], 0);",
      "}; ",
      "-*-",
      "console.log(presses('LOL')); // 9 ",
      "console.log(presses('WHERE DO U WANT 2 MEET L8R')); // 47 ",
      "console.log(presses('')); // 0 ",
      "-*-",
    ],
  },
  {
    heading: "Расширение встроенных классов",
    href: "https://www.youtube.com/watch?v=C6b9pR9lEDM",
    taskCode: [
      "Умеете ли вы расширять фунциональность встроенных классов? Нужно расширить всторенный класс Array методами: ",
      "    square() - должен вернуть копию массива, содержащую все значения в квадрате.",
      "    cube() - должен возвращать копию массива, содержащую все значения в кубе. ",
      "    average() - должен возвращать среднее значение всех значений массива; при пустом - NaN. ",
      "    sum() - должен возвращать сумму всех значений массива.",
      "    even() - должен возвращать массив всех чётных чисел.",
      "    odd() - должен возвращать массив всех нечётных чисел. ",
      " ",
      "Примечание: исходный массив ни в коем случае не должен быть изменён!",
      "-*-",
      "Object.assign() метод копирует все перечисляемые собственные свойства из одного или нескольких исходных объектов в целевой объект. Он возвращает измененный целевой объект.",
      "Object.assign() метод в javascript, который используется для копирования одного или нескольких объектов в целевой объект. Он принимает несколько исходных объектов и присваивает их ключи и значения целевому объекту, перезаписывая предыдущие значения, если они существуют. По сути он позволяет объединять объекты в один, добавляя свойства нескольких объектов в один объект.",
      "-*- Не смог типизировать это расширение -*-",
      "Object.assign(Array.prototype, { ",
      "    square(): number[] { return this.map((n: number) => n * n) }, ",
      "    cube(): number[] { return this.map((n: number) => n * n * n) }, ",
      "    average(): number {",
      "        return this.reduce((sum: number, n: number) => sum + n, 0) / this.length;",
      "    },",
      "    sum(): number { return this.reduce((sum: number, n: number) => sum + n, 0) },",
      "    even(): number[] { return this.filter((n: number) => !(n % 2)) },",
      "    odd(): number[] { return this.filter((n: number) => n % 2) },",
      "}); ",
      " ",
      "const numbers = [1, 2, 3, 4, 5]; ",
      " ",
      "console.log(numbers.square()); // [1, 4, 9, 16, 25] ",
      "console.log(numbers.cube()); // [1, 8, 27, 64, 125] ",
      "console.log(numbers.average()); // 3 ",
      "console.log(numbers.sum()); // 15 ",
      "console.log(numbers.even()); // [2, 4] ",
      "console.log(numbers.odd()); // [1, 3, 5] ",
      "-*-",
    ],
  },
  {
    heading: "Что такое обратная польская нотация и как написать специфичный калькулятор?",
    href: "https://www.youtube.com/watch?v=_OzKGJZ_Ye4",
    taskCode: [
      "Нужно создать калькулятор, работающий с выражениями в обратной польской нотации (+, -, *, / ). Операторы и операнды разделены между собой пробелами. Пустое выражение должно быть равно нулю, обрабатывать исключения не нужно (деления на ноль и прочее не будет). ",
    ],
  },
  {
    heading: "Отображение даты и чисел для разных стран",
    href: "https://www.youtube.com/watch?v=Lf_RJgkww5Y",
    taskCode: ["В разных странах по разному записывают время и числа, "],
  },
  {
    heading: "Перемножить элементы массива, используя метод array.reduce(). ",
    href: "https://www.youtube.com/watch?v=NZP3o0xnT9o",
    taskCode: [
      "Дан непустой массив из целых чисел, нужно возвратить число, равное умножению всех элементов массива.",
      "    const array = [1, 2, 3, 4, 5];      // 1 * 2 * 3 * 4 * 5",
      "    const array2 = [2, 4, 6, 8, 10];  // 2 * 4 * 6 * 8 * 10",
      " ",
      "const multipliedElements = (arr: number[]): number => { ",
      "    return arr.reduce((acc, next) => acc * next, 1); ",
      "}; ",
      " ",
      "console.log(multipliedElements(array)); // 120 ",
      "console.log(multipliedElements(array2)); // 3840 ",
    ],
  },
  {
    heading: "Объединить два массива и найти сумму их элементов. Метод array.concat() и ...spread ",
    href: "https://www.youtube.com/watch?v=3ICqfxnfSAY",
    taskCode: [
      "Объединить два массива и найти сумму их элементов: ",
      "    const array1 = [1, 2, 3, 4, 5]; ",
      "    const array2 = [2, 4, 6, 8, 10];",
      " ",
      "    const arrayA = ['H', 'E', 'L', 'L', 'O', ','];",
      "    const arrayB = ['F', 'R', 'I', 'E', 'N', 'D', '!'];",
      " ",
      "1. Объединим два массива с помощью метода array.concat(): ",
      "function unionOfArrays<T>(arr1: T[], arr2: T[]) {  ",
      "    return arr1.concat(arr2); ",
      "} ",
      " ",
      "let arrayNumeric: number[] = unionOfArrays(array1, array2); ",
      "console.log(arrayNumeric); ",
      "    // [1, 2, 3, 4, 5, 2, 4, 6, 8, 10] ",
      " ",
      "let arrayString: string[] = unionOfArrays(arrayA, arrayB); ",
      "console.log(arrayString); ",
      "    // ['H', 'E', 'L', 'L', 'O', ',' 'F', 'R', 'I', 'E', 'N', 'D', '!'] ",
      " ",
      "2. Найдём сумму числовых элементов массива arrayNumeric:",
      "function sumOfArrayElements(arrNum: number[]) { ",
      "    return arrNum.reduce((acc, next) => acc + next, 0); ",
      "} ",
      " ",
      "console.log(sumOfArrayElements(arrayNumeric)); // 45 ",
      " ",
      "3. Объединим два массива через ...spread: ",
      "function unionOfArrays<T>(arr1: T[], arr2: T[]) { ",
      "    return [...arr1, ...arr2]; ",
      "} ",
      " ",
      "let arrayNumeric: number[] = unionOfArrays(array1, array2); ",
      "console.log(arrayNumeric); ",
      "    // [1, 2, 3, 4, 5, 2, 4, 6, 8, 10] ",
      " ",
      "let arrayString: string[] = unionOfArrays(arrayA, arrayB); ",
      "console.log(arrayString); ",
      "    // ['H', 'E', 'L', 'L', 'O', ',' 'F', 'R', 'I', 'E', 'N', 'D', '!'] ",
      " ",
    ],
  },
  {
    heading: "Найти минимум и максимум. Math.min() и Math.max() ",
    href: "https://www.youtube.com/watch?v=MlVCNJynN9Q",
    taskCode: [
      "Имеем массивы: ",
      "const array1 = [1, 2, 3, 4, 5]; ",
      "const array2 = [2, 4, 6, 8, 10]; ",
      " ",
      "1. Находим min: ",
      "List обязательно разворачиваем: ...list, иначе работать не будет. Этим мы из массива сделаем просто список, то что нам нужно для Math.min():",

      " ",
      "function minOfTheArray(list: number[]) { ",
      "    return Math.min(...list); ",
      "} ",

      "console.log(minOfTheArray(array1)); // 1 ",
      "console.log(minOfTheArray(array2)); // 2 ",
      " ",
      "2. Находим max: ",
      "List обязательно разворачиваем: ...list, иначе работать не будет. Этим мы из массива сделаем просто список, то что нам нужно для Math.min():",
      " ",
      "function maxOfTheArray(list: number[]) { ",
      "    return Math.max(...list); ",
      "} ",
      " ",
      "console.log(maxOfTheArray(array1)); //  5 ",
      "console.log(maxOfTheArray(array2)); // 10 ",
    ],
  },
  {
    heading: "Когда бегуны встретятся на старте кругов разной длины? ",
    href: "https://www.youtube.com/watch?v=DJt12of3OIw&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=26",
    taskCode: [
      "Два бегуна бегут с одинаковой скоростью. Круги разной длины, но с одним местом старта. Через сколько кругов они встретятся в начальной точке?",
      "Функция принимает длины a, b и возвращает массив количеств, в котором, сначала лежит, сколько кругов нужно пробежать первому, а потом второму бегуну.",
      "Лучшим решением станет использование наименьшего общего кратного для a и b. Иначе говоря, числа, которое кратно им обоим, делятся на них без остатка. Мы найдём это число, поделим длины кругов и получим ответ. ",
      " ",

      "Как найти общее наименьшее кратное? В цикле мы будем увеличивать HOK каждый раз на +=a, пока остаток деления (HOK % b !==0) ",
      " ",
      "const nbrOfLars = (a: number, b: number) => { ",
      "    let HOK = a; ",
      "    while (HOK % b !== 0) {",
      "        HOK += a;",
      "    }",

      "    return [HOK / a, HOK / b]; ",
      "}; ",
      " ",
      "console.log(nbrOfLars(5, 3)); // [3, 5] ",
      "console.log(nbrOfLars(4, 6)); // [3, 2] ",
      "console.log(nbrOfLars(5, 5)); // [1, 1] ",
    ],
  },
  {
    heading: "wise.js. Найти сумму элементов массива.",
    href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
    taskCode: [
      "Найти сумму элементов массива.",
      " ",
      "1. Самый лёгкий способ сделать это - перебрать массив в цикле: ",
      "const array: number[] = [ 1, 2, 3, 4, 5, 6 ]; ",
      "let sum: number = 0; ",

      "for ( let i = 0; i < array.length; i++ ) { ",
      "    sum += array[ i ]; ",
      "} ",
      "console.log(sum); // 21 ",
      " ",
      "2. Способ посложнее называется reduce(). Методы reduce() и reduceRight() вычисляют одно значение на основе всего массива (суммирование, умножение и т.д...).",
      "const array2 = [1, 2, 2, 4, 5, 6, 6]; ",
      "let sum2: number = array2.reduce((acc, next) => acc + next); ",
      "// acc - аккумулятор ",
      "// next - следующий элемент ",
      "// Последний ноль - изначальное значение аккумулятора. Если массив будет пустой, ",
      "// то отсутствие изначального значения аккумулятора вызовет ошибку. ",
      "console.log(sum2); // 26 ",
    ],
  },
  {
    heading: "wise.js. Найти максимальный или минимальный элемент массива.",
    href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
    taskCode: [
      "У нас есть массив, найдём его максимальное значение. ",
      "1. Воспользуемся циклом for().  Для этого введём переменную max и по дефолту её значение будет первый элемент массива. ",
      "const array = [10, 2, 2, 4, 5, 6, 6, 1]",
      "let max = array[0]; ",
      " ",
      "for (let i = 0; i < array.length; i++) { ",
      "    if (max < array[i]) { ",
      "        max = array[i];",
      "    }",
      "} ",

      "console.log(max); // 12 ",
      " ",
      "2. Воспользуемся циклом for(), но проверку сделаем через тернарный оператор: ",
      "const array = [1, 2, 2, 4, 5, 6, 6, 12]; ",
      "let max = array[0]; ",
      " ",
      "for (let i = 0; i < array.length; i++) { ",
      "    // Если array[i] > max, то переменной max присвоить значение array[i], иначе - max: ",
      "    max = array[i] > max ? array[i] : max;",
      "} ",
      "console.log(max); // 12 ",

      " ",
      "3. Воспользуемся утилитной функцией. ",
      "const array = [1, 2, 2, 4, 5, 6, 6]; ",
      "let max = array[0]; ",
      " ",
      "// То есть нам нужно выбрать максимальное значение из двух доступных: ",
      "for (let i = 0; i < array.length; i++) { ",
      "    max = Math.max(array[i], max); ",
      "} ",

      "console.log(max); // 6 ",
      " ",
      "4. Воспользуемся методом массивов reduce(): ",
      "const array = [1, 2, 2, 4, 5, 6, 6, 12, 14]; ",
      "let max: number = array.reduce((acc, next) => Math.max(acc, next)); ",
      "console.log(max); ",
      " ",
      "5. Воспользуемся методом сортировки sort(). ",
      "const array = [100, 2, 2, 4, 5, 6, 6, 12]; ",
      "    // Отсортируем массив: ",
      "array.sort((a, b) => a - b); // [2, 2, 4, 5, 6, 6, 12, 100] ",
      "    // Достанем из массива последний элемент: ",
      "let max = array[array.length - 1]; ",

      "console.log(max); // 100 ",
      " ",
      "6. Если нам не важна целостность массива, воспользуемся методом pop(). ",
      "const array = [10, 20, 20, 40, 55, 66, 69, 12]; ",
      "    // Отсортируем массив: ",
      "array.sort((a, b) => a - b);",
      "console.log(array);  // [10, 12, 20, 20, 40, 55, 66, 69]; ",
      "    // Достанем последний элемент из массива: ",
      "let max = array.pop(); ",
      "console.log(max); // 69 ",
      " ",
      "7. Самый читерский способ получить максимальный или минимальный элемент массива - это воспользоваться деструктуризацией и утилитным методом Math.max().",
      "const array = [20, 40, 55, 66, 69, 88]; ",
      "// let max = Math.max(...array); ",
      "let max = Math.max.apply(null, array); // для ES6 ",
      " ",
      "console.log(max); // 88 ",
    ],
  },
  {
    heading: "wise.js. Сортировка элементов массива.",
    href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
    taskCode: [
      "1. Сортировка чисел в массиве.",
      "const array = [10, 2, 2, 4, 5, 6, 6, 1];",
      "    // Сортируем массив:",
      "array.sort((a: number, b: number): number => a - b); ",

      "    // Получаем массив: ",
      "array = [1, 2, 2, 4, 5, 6, 6, 10] ",
      " ",
      "2. Сортировка строк в массиве независимо от регистра символов. ",
      "const array = ['dfa', 'ghdfg', 'Fjrytnd', 'Dhsghsfg', 'agfa']; ",
      "    // Сортируем массив:",
      "array.sort((a, b) => a.localeCompare(b)); ",
      "    // Получаем массив: ",
      "array = ['agfa', 'dfa', 'Dhsghsfg', 'Fjrytnd', 'ghdfg'] ",
      " ",
      "3. Необходимо отсортировать массив, элементы которого являются объектами. ",
      "const users = [ ",
      "    { name: 'John Doe', age: 20 }, ",
      "    { name: 'Alex Moren', age: 30 },",
      "    { name: 'Jane Moren', age: 25 }, ",
      "]; ",

      "3.1. Сортируем по полю name (по строкам): ",
      "users.sort((u1, u2) => { ",
      "    return u1.name.localeCompare(u2.name); ",
      "}); ",

      "    // users [",
      "    //     { name: 'Alex Moren', age: 30},",
      "    //     { name: 'Jane Moren', age: 25 },",
      "    //     { name: 'John Doe', age: 20},",
      "    // ]",
      " ",
      "3.2. Сортируем по полю age (по числам):",
      "users.sort((a, b) => a.age - b.age); ",
      "    // users [",
      "    //     { name: 'John Doe', age: 20},",
      "    //     { name: 'Jane Moren', age: 25 },",
      "    //     { name: 'Alex Moren', age: 30},",
      "    // ]",
    ],
  },
  {
    heading: "wise.js. Поменять порядок элементов на противоположный - перевернуть массив.",
    href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
    taskCode: [
      "Нам даны массивы чисел и массивы строк: ",
      "    const array1 = [1, 2, 3, 4, 5]; ",
      "    const array2 = [2, 4, 6, 8, 10];",
      " ",
      "    const arrayA = ['H', 'E', 'L', 'L', 'O', ','];",
      "    const arrayB = ['F', 'R', 'I', 'E', 'N', 'D', '!'];",
      " ",
      "1. Перевернём элементы массива методом arr.reverse():",
      "function reverseArray<T>(arr: T[]) { ",
      "    return arr.reverse(); ",
      "} ",
      "console.log(reverseArray(array1)); // [5, 4, 3, 2, 1] ",
      "console.log(reverseArray(array2)); // [10, 8, 6, 4, 2] ",
      "console.log(reverseArray(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
      "console.log(reverseArray(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
      " ",
      "2. Можем создать новый массив reversed и перебрать его с конца. ",
      "function reverseArr<T>(arr: T[]) { ",
      "    const reversed = []; ",
      " ",
      "    for (let i = arr.length - 1; i >= 0; i--) { ",
      "        reversed.push(arr[i]); ",
      "    } ",
      "    return reversed; ",
      "} ",
      "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
      "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
      "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
      "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
      " ",
      "3. Воспользуемся методом array.map() ",
      "function reverseArr<T>(arr: T[]) { ",
      "    // На первой итерации мы берём последний элемент, на следующей - предпоследний ",
      "    // и так далее, пока не дойдём до последнего элемента массива.",
      "    const reversed = arr.map((el, index, arr) => arr[arr.length - index - 1]);",
      " ",
      "    return reversed; ",
      "} ",
      "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
      "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
      "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
      "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
      " ",
      "4. Метод ...spread, map(arr.pop): ",
      "function reverseArr<T>(arr: T[]) { ",
      "    return [...arr].map(arr.pop, arr); ",
      "} ",
      "console.log(reverseArr(array1)); // [5, 4, 3, 2, 1] ",
      "console.log(reverseArr(array2)); // [10, 8, 6, 4, 2] ",
      "console.log(reverseArr(arrayA)); // [',', 'O', 'L', 'L', 'E', 'H'] ",
      "console.log(reverseArr(arrayB)); // ['!', 'D', 'N', 'E', 'I', 'R', ' F'] ",
    ],
  },
  {
    heading: "wise.js. Отфильтровать false - значения в массиве.",
    href: "https://www.youtube.com/watch?v=YA6yZ_KUIYA&t=23s",
    taskCode: [
      "const arr = [7, 'correct', false, 9, NaN, '']; ",
      " ",
      " 1. С помощью цикла for() приведём к булевому типу (!!) значения array[i] и проверим их на соотношение к true. Если эти значения правдивы, то пушим их в новый массив:",
      "function notFalseValue(array: any) { ",
      "    const notFalse: any = []; ",

      "    for (let i = 0; i < array.length; i++) { ",
      "        if (!!array[i]) { ",
      "            notFalse.push(array[i]);",
      "        } ",
      "    } ",

      "    return notFalse; ",
      "} ",
      "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
      " ",
      "2.1. Воспользуемся методом array.filter(), чтобы не делать цикл: ",
      "function notFalseValue(array: any) { ",
      "    return array.filter((n: any) => !!n); ",
      "} ",
      "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
      " ",
      "2.2. Воспользуемся методом array.filter() и фунцией Boolean(n): ",
      "function notFalseValue(array: any) { ",
      "    return array.filter((n: any) => Boolean(n)); ",
      "} ",
      "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
      " ",
      "2.3. Воспользуемся методом array.filter() и фунцией Boolean(n): ",
      "function notFalseValue(array: any) { ",
      "    return array.filter(Boolean); ",
      "}",
      "console.log(notFalseValue(arr)); // [7, 'correct', 9] ",
    ],
  },
  {
    heading: "Отформатировать и отсортировать заказы без сортировки ",
    href: "https://www.youtube.com/watch?v=nXT1LnINXIk&list=PLPiq_hi6UrQqH0oQGGP3jbrTrwXmkIqPS&index=27",
    taskCode: [
      "После закрытия самой популярной бургерной, на смену пришёл другой бренд, в котором практически нет системы. Кассиры записывают заказы в одну строку. А кухонный персонал угрожает уйти из-за того, что трудно читать заказы. Они предлагают читаемый вариант с заглавными буквами и разделителями. На кухне ожидают, что блюда будут расположены в том же порядке, в котором они указаны в меню. В названиях пунктов нет дублирований:",
      "// Бургер ",
      "// Картошка ",
      "// Крылышки ",
      "// Ролл ",
      "// Пирожок ",
      "// Печенье ",
      "// Коктейль ",
      "// Кола ",
      " ",
      "const str = 'коктейльпирожокбургербургерколакартошкароллколапирожоккрылышкикола'; ",
      " ",
      "function getOrder(input: string) { ",
      "    const ordered: string[] = []; ",
      "    const menu: any = { ",
      "        Бургер: 0,",
      "        Картошка: 1,",
      "        Крылышки: 2, ",
      "        Ролл: 3,",
      "        Пирожок: 4, ",
      "        Печенье: 5, ",
      "        Коктейль: 6, ",
      "        Кола: 7, ",
      "    }; ",
      " ",
      "    // блюда в заказе ",
      "    let item = ''; ",
      "    // Добавляй в item буквы, пока они не сложатся в слово, которое уже есть в объекте menu.",
      "    for (let i = 0; i < input.length; i++) {",
      "        // Для начала ложим заглавную букву ",
      "        item += item ? input[i] : input[i].toUpperCase(); ",
      " ",
      "        // Если в объекте есть блюда, то индекс будет равен от 0 и до 7. Иначе - undefined. ",
      "        const index = menu[item]; ",
      "        if (index > -1) { ",
      "            ordered[index] = ordered[index] ? `${ordered[index]} ${item}` : item; ",
      "            // После, затри item ",
      "            item = '';",
      "        }",
      "    } ",
      "    return ordered.reduce((result, str) => { ",
      "        if (str) return result ? `${result} ${str}` : str;",
      "        return result;",
      "    }, '');",
      "} ",
      " ",
      "console.log(getOrder(str)); ",
      "// Бургер Бургер Картошка Крылышки Ролл Пирожок Пирожок Коктейль Кола Кола Кола ",
    ],
  },
  {
    heading: "Каждую цифру в числе возвести в квадрат ",
    href: "https://www.youtube.com/watch?v=xa0Pv74CxlM&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=1&t=7s",
    taskCode: [
      "В этой задаче необходимо исходное число разделить посимвольно и каждый символ - число преобразовать в числовое значение и возвести в квадрат. Получившееся количество вычислений сконкантенировать в отдельное число и вывести его.",
      " ",
      "const numeric = 91736491; ",
      " ",
      "function squareDigits(num: number) { ",
      "    // Исходное число переводим в строку, // 91736491 ",
      "    // разделяем посимвольно в массив,    // ['9', '1', '7', '3', '6', '4', '9', '1'] ",
      "    // мапим в новый массив, переводя в число и возведя в квадрат: // [81, 1, 49, 9, 36, 16, 81, 1] ",
      "    // Всё это джойним слитно. // 8114993616811",
      "    return num.toString().split('').map((n) => Number(n) * Number(n)).join('');",
      "} ",
      " ",
      "console.log(squareDigits(numeric)); ",
    ],
  },
  {
    heading: "Посчитать количество гласных в строке. Методы .reduce() .filter() .includes() ",
    href: "https://www.youtube.com/watch?v=qwJKLSTyZPk&list=PLPiq_hi6UrQoIZVVTsHsadUmdMCve5Qdx&index=2",
    taskCode: [
      "Глассными у нас будут: a, e, i, o, u. Не считать глассной 'y'. Во входящей строке будут только буквы в нижнем регистре и пробелы.  ",
      " ",
      "const str = 'asgg sgdsfgh hello dfgadf gfdd qwert'; ",
      " ",
      "function getCount(str: string) { ",
      "    return str.split('').reduce((sum: any, char: string) => { ",
      "        if ('aeiou'.includes(char)) {",
      "            sum += 1;",
      "        }",
      " ",
      "        return sum; ",
      "    }, 0); // Если здесь забудем написать нолик, то функция у нас работать не будет ",
      "} ",
      " ",
      "console.log(getCount(str)); // 5",
    ],
  },
  {
    heading: "Реализовать функцию, которая будет сумировать числа и выводить в логи.",
    href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
    taskCode: [
      "Реализовать функцию, которая будет сумировать числа и выводить в логи. Особенность задачи состоит в том, что мы каждый раз добавляем вызов функции, который передаём число. И это число должно прибавляться к результату, вычисленную в предыдущем вызове.  ",
      "",
      "function sum(n: number) { ",
      "    console.log(n); ",
      "    return function (a: number) { ",
      "        return sum(a + n); ",
      "    }; ",
      "} ",
      "sum(5);           // 5 ",
      "sum(5)(4);       // 9 ",
      "sum(5)(4)(11); // 20 ",
      "-*- ",
    ],
  },
  {
    heading: "Функция принимает два объекта с разными ключами",
    href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
    taskCode: [
      "Функция принимает два объекта с разными ключами, некоторые из которых могут пересекаться. Необходимо вернуть первый объект с обновлёнными значениями из второго объекта (только те, которые совпадают). 1.58 мин ",
      " ",
      "type Obj1  = { foo: string; bar: string }; ",
      "type Obj2 = { bar: string; some: string }; ",
      " ",
      "const object1: Obj1 = { foo: 'foo', bar: 'bar' }; ",
      "const object2: Obj2 = { bar: 'foo', some: 'some' }; ",
      " ",
      "1-ый вариант: ",
      "const mergeSameKeysOfObject = (obj1: any, obj2: any) => { ",
      "    let keysOfObj1 = Object.keys(obj1); ",
      "    let keysOfObj2 = Object.keys(obj2); ",
      "    // console.log(keysOfObj1, keysOfObj2); // ['foo', 'bar'] (2)['bar', 'some'] ",
      " ",
      "    // Объекты из первого цикла будем сравнивать с объектами из второго цикла ",
      "    for (let i = 0; i < keysOfObj1.length; i++) { ",
      "        let key1 = keysOfObj1[i]; ",
      " ",
      "        for (let j = 0; j < keysOfObj2.length; j++) { ",
      "            let key2 = keysOfObj2[j];",
      " ",
      "            if (key1 === key2) { ",
      "                // Если условие выполняется, то мы должны заменить повторяющиеся поля в первом объекте.",
      "                // По ключу обращаемся к этому полю, и меняем значение на то,  ",
      "                // которое мы получаем по ключу из второго объекта. ",
      "                obj1[key1] = obj2[key2]; ",
      "            } ",
      "        } ",
      "    } ",
      "    console.log(obj1); // {foo: 'foo', bar: 'foo'} ",
      "}; ",
      "mergeSameKeysOfObject(object1, object2); ",
      "-*-",
      "2-ой вариант: ",
      "const mergeSameKeysOfObject = (obj1: any, obj2: any) => { ",
      "    for (const key in obj1) { ",
      "        if (obj2.hasOwnProperty(key)) {",
      "            obj1[key] = obj2[key];",
      "        } ",
      "    } ",
      " ",
      "    console.log(obj1); // {foo: 'foo', bar: 'foo'} ",
      "}; ",
      " ",
      "mergeSameKeysOfObject(object1, object2); ",
      "-*-",
    ],
  },
  {
    heading: "Реализовать функцию с ключами объектов. 5.07",
    href: "https://www.youtube.com/watch?v=G7pAP1TvZSw&t=138s",
    taskCode: [
      "Реализовать функцию, которая принимает два параметра:  ",
      "    *  массив значений ",
      "    *  колбэк, по результату которого будут групироваться значения",
      "Функция должна возвращать составной совокупный объект, где ключи - это названия групп, а значения - сами группы. ",
      "const groupBy = (arr: number[], callbackFunction: any) => { ",
      "   const result: any = {}; ",
      " ",
      "       // Проитерируемся по массиву, каждый момент итерации - item. И каждый момент  ",
      "       // итерации нам надо прогнать через функцию, которая передаётся вторым параметром. ",
      "       arr.forEach((item) => { ",
      "           let resultAfterCallback: any = callbackFunction(item);",
      "           result[resultAfterCallback] ",
      "               ? result[resultAfterCallback].push(item)  ",
      "               : (result[resultAfterCallback] = [item]);",
      "       }); ",
      "       console.log(result); ",
      "}; ",
      " ",
      "groupBy(array, Math.floor); // { [4.2], [6.1, 6.3] } ",
      "-*-",
    ],
  },
  {
    heading: "Расширение Function.prototype и типизация этого. ",
    href: "https://www.youtube.com/watch?v=kOTD3gndink&t=97s",
    taskCode: [
      "Нам необходимо расширить интерфейс Function, который находится в стандартной библиотеке typescript, для того, чтобы функция delay() была доступна для каждой функции. ",
      "В стандартной библиотеке typescript есть интерфейс Function, в котором объявлены члены объектов Function. Нам нужно будет ГЛОБАЛЬНО, НА ВЕРХНЕМ УРОВНЕ, объявить 'delay' как член этого интерфейса с нашим собственным дополнением, как показано ниже. Без «объявления глобального» это не работает.",
      "// типизация расширения прототипа функции: ",
      "declare global { ",
      "    interface Function { ",
      "        delay(ms: number): any; ",
      "    } ",
      "} ",
      " ",
      "// время старта функции. ",
      "const START = Date.now(); ",
      " ",
      "// Функция someFn(), которой мы хотим добавить функцию delay():  ",
      "function someFn() { ",
      "    console.log('time', Date.now() - START); // разница времени от старта функции до текущего момента. ",
      "    console.log('args', arguments); // просто выводим в логи. ",
      "} ",
      " ",
      "// Для того, чтобы функция delay() была доступна для каждой функции, объявим её в прототипе функции, тем самым расширим прототип функции. В самом верху описана типизация расширения интерфейса Function. ",

      "Function.prototype.delay = function (ms) { ",
      "    setTimeout(() => { ",
      "        this.call(this, arguments); ",
      "    }, ms); ",
      "}; ",
      " ",
      "// Запустим нашу функцию с расширением delay():",
      "const f = someFn.delay(500); ",
      "// В консоли будет следующее: ",
      "    // time 505 ",
      "    // args  ",
      "    //      Arguments [500, callee: (...), Symbol(Symbol.iterator): ƒ] ",
      "-*-",
    ],
  },
  {
    heading: "Найти сумму объектов в массиве. ",
    href: "https://www.youtube.com/watch?v=kOTD3gndink&t=97s",
    taskCode: [
      "У нас есть дерево, в котором каждый узел может содержать неограниченное количество детей. Суть задачи состоит в том, чтобы обойти всё дерево и просуммировать значения, которые лежат в каждой из вершин. ",
      " ",
      "Наше дерево - это массив, состоящий из объектов. Каждый объект - это узел, у которого есть два поля: ",
      "    -  это v - value (какое-то значение), ",
      "    -  и с - child (потомки).",
      "    const arrayTree = [ ",
      "        { ",
      "            v: 5, ",
      "            c: [",
      "                { v: 18, c: [{ v: 11 }] }, ",
      "                { v: 7, c: [{ v: 5, c: [{ v: 1 }] }] },",
      "                { v: 5, c: [{ v: 18 }, { v: 15 }] }, ",
      "            ],",
      "        }, ",
      "    ]; ",
      " ",
      "1. Решение задачи с помощью рекурсии.",
      "const recursive = ( tree: any ) => { ",
      "    let sum = 0; ",

      "    // Проитерируемся по объектам массива tree: ",
      "    tree.forEach(( node: any ) => { ",
      "        // К сумме прибавим значение этого узла ( node ) ",
      "        sum += node.v; ",

      "        // И поскольку у каждого узла (node) так же есть дети, которые являются являются деревьями,",
      "        // мы можем эту же функцию рекурсивно вызвать и для каждого поддерева. ",
      "        // Параметром передаём массив детей:",
      "        if (!node.c) { ",
      "            return node.v; ",
      "        } ",
      "        sum += recursive(node.c);",
      "    }); ",
      "    // По итогу возвращаем эту сумму: ",
      "    return sum; ",
      "}; ",
      "console.log(recursive(arrayTree)); // 85 ",
      " ",
      "Рекурсивные функции помещаются в стек вызовов и выполняются сверху вниз. И получается, что функция, которая была вызвана самой первой, то есть для всего дерева, будет как раз хранить значение суммы всех элементов. Здесь важно понимать, что эта сумма будет считаться для каждого поддерева и по итогу это всё сложится в одну общую сумму первоначальной функции. ",
      "Каждая рекурсивная функция должна иметь условия выхода из этой рекурсии. У нас база рекурсии - отсутствие детей в некоторых случаях. Поэтому в цикле, для каждого узла делаем проверку: if (!node.c) {}.",
      " ",
      "2. Решение задачи с помощью цикла (итерацией).",
      "Стэк - это такая структура данных, в которой объекты помещаются в конец и в первую же очередь с этого конца забираются. Можно представить пирамиду из кубиков, из которых мы не можем взять и вытащить кубик из середины. Мы можем взять его только сверху. И вот такая структура данных называется стэком. ",
      " ",
      "const iteration = (tree: any) => { ",
      "    // Если дерево пустое, тогда возвращаем ноль ",
      "    if (!tree.length) { ",
      "        return 0; ",
      "    } ",
      " ",
      "    // Без рекурсии с использованием стэка. ",
      "    const stack: any[] = []; ",
      "    let sum = 0; ",
      " ",
      "    tree.forEach((node: any) => {",
      "        // Каждый узел (node) добавляем в стэк:",
      "        stack.push(node); ",
      "        // По окончании этой функции, в стэке будут только вершины дерева.",
      "    }); ",
      " ",
      "    // Делаем бесконечный цикл, которой будет крутиться, пока стэк не пустой: ",
      "    while (stack.length) { ",
      "        // На каждой итерации цикла достаём один из узлов и суммируем его значение: ",
      "        const node = stack.pop();",
      "        sum += node.v; ",
      "        // Если у узла, который мы вытащили на этой итерации, есть дети (проверим это) ",
      "        if (node.c) { ",
      "            // то пробегаемся уже по детям узла:",
      "            node.c.forEach((n: any) => {",
      "                // Каждого ребенка этого узла мы опять добавляем в стэк:",
      "                stack.push(n);",
      "            }); ",
      "        }",
      "    } ",
      "    // По итогу возвращаем сумму: ",
      "    return sum;",
      "}; ",
      "console.log(iteration(arrayTree)); // 85 ",
      " ",
      "Мы создали стэк, добавили в него все вершины, потом в цикле мы эти вершины вытаскиваем, суммируем и добавляем в стэк уже детей этой вершины. Этот цикл будет крутиться до тех пор, пока стэк не пустой.",
    ],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
  {
    heading: " ",
    href: "",
    taskCode: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
  },
];

import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksReactPage: ILinkInfo[] = [
  {
    href: "https://ru.reactjs.org/docs/getting-started.html",
    title: "Официальный справочник React на русском языке.",
  },
  {
    href: "https://reactdev.ru/ ",
    title: "Справочник React на русском языке.",
  },
  {
    href: "https://reactdev.ru/handbook/tutorial/ ",
    title:
      "Документация по React (на русском языке). React – это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами».",
  },
  {
    href: "https://reactdev.ru/types/ ",
    title:
      "React и Typescript (на русском языке). Типизация библиотеки React с помощью Typescript: Типизированный React, Функциональные компоненты, Классовые компоненты, Универсальные компоненты, Типизированные хуки, Контекст (Context), HOC (Higher-Order Components).",
  },
  {
    href: "https://reactdev.ru/libs/cra/",
    title:
      "Create React App (CRA на русском языке) - это интерфейс командной строки (command line interface, CLI), позволяющий создавать предварительно настроенные React-проекты. Предварительная настройка включает в себя, но не исчерпывается, настройкой Webpack и Babel.",
  },
  {
    href: "https://reactdev.ru/graphql/ ",
    title:
      "GraphQL (на русском языке) — это язык запросов к API и среда выполнения этих запросов с имеющимися данными. GraphQL обеспечивает полное и понятное описание данных в вашем API, дает клиентам возможность запрашивать именно то, что им нужно, упрощает обновление API-интерфейсов и предоставляет мощные инструменты для разработчиков ",
  },
  {
    href: "https://reactdev.ru/questions/#shouldcomponentupdate",
    title: "Вопросы про React на собеседовании. Частые вопросы и ответы про React, задаваемые на собеседованиях ",
  },
  {
    href: "https://reactdev.ru/libs/react-router/",
    title: "Справочник React на русском языке. React Router DOM. React Router. Маршрутизатор",
  },
  {
    href: "https://reactdev.ru/libs/redux/ ",
    title: "Redux. Библиотека управления состоянием. Документация redux (на русском языке).",
  },
  {
    href: "https://reactdev.ru/libs/redux-toolkit/",
    title: "Redux Toolkit. Пакет (на русском языке), облегчающий работу с Redux ",
  },
  {
    href: "https://habr.com/ru/post/498860/",
    title: "Введение в Redux & React-redux ",
  },
  {
    href: "https://reactdev.ru/libs/recoil/",
    title: "Recoil - это новый инструмент (на русском языке) для управления состоянием в React-приложениях ",
  },
  {
    href: "https://reactdev.ru/libs/react-query/",
    title:
      "React Query. Библиотека (на русском языке) для получения, кэширования, синхронизации и обновления 'серверного' состояния в React-приложениях ",
  },
  {
    href: "https://reactdev.ru/libs/react-spring/",
    title: "React Spring. Библиотека для анимации интерфейсов (на русском языке)",
  },
  {
    href: "https://reactdev.ru/libs/styled-components/#_1",
    title: "Styled Components. Шпаргалка по библиотеке стилизации (на русском языке)",
  },
  {
    href: "https://reactdev.ru/libs/xstate/",
    title:
      "XState. Библиотека для управления конечными автоматами (на русском языке):  Базовая библиотека конечных автоматов и диаграмм состояний + интерпретатор, Минимальная библиотека конечных автоматов, Утилиты обхода графа для XState, React xуки и утилиты для использования XState в приложениях React, Функции композиции и утилиты Vue для использования XState в приложениях Vue, Утилиты Svelte для использования XState в приложениях Svelte, Утилиты Model-Based-Testing (с использованием XState) для тестирования любого программного обеспечения, Утилиты разработчика (проверки) для XState.",
  },
  {
    href: "https://react-hook-form.com/",
    title: "React Hook Form. Валидация форм.",
  },
  {
    href: "https://www.youtube.com/watch?v=Jxfun6Jnt5Q",
    title: "Валидация форм с react-hook-form в React-приложениях. Михаил Непомнящий. ",
  },
  {
    href: "https://www.youtube.com/watch?v=Nicadhseqos&t=82s",
    title: "Zod для валидации API и форм. Михаил Непомнящий.",
  },
  {
    href: "https://mobx.js.org/react-integration.html",
    title: "MobX and React",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/674",
    title: "MobX — управление состоянием приложения",
  },
  {
    href: "https://www.npmjs.com/package/mobx-react-lite",
    title: "npm i mobx-react-lite",
  },
  {
    href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
    title: "Использование Axios с React",
  },
  {
    href: "https://ru.reactjs.org/docs/hooks-reference.html",
    title: "Справочник API хуков React",
  },
  {
    href: "https://fettblog.eu/typescript-react/hooks/",
    title: "TypeScript и React: хуки",
  },
  {
    href: "https://create-react-app.dev/docs/adding-typescript/",
    title: "npx create-react-app my-app --template typescript",
  },
  {
    href: "https://reactcommunity.org/react-transition-group/transition-group",
    title: "React Transition Group",
  },
  {
    href: "https://www.npmjs.com/package/react-transition-group?activeTab=versions",
    title: "npm i react-transition-group",
  },
  {
    href: "https://www.npmjs.com/package/react-router-dom",
    title: "npm i react-router-dom (6.9.0)",
  },
  {
    href: "https://www.npmjs.com/package/react-router-dom/v/5.3.3",
    title: "npm i react-router-dom@5.3.3",
  },
  {
    href: "https://habr.com/ru/company/kts/blog/598835/",
    title: "Что нового в react-router v6",
  },
  {
    href: "https://www.youtube.com/playlist?list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE",
    title: "React Router v6. Михаил Непомнящий. 10 видео ",
  },
  {
    href: "https://www.npmjs.com/package/@types/react-router-dom",
    title: "npm i @types/react-router-dom  npm install --save @types/react-router-dom (types)",
  },
  {
    href: "https://betterprogramming.pub/12-react-hooks-every-react-developer-should-know-9c6352b81329",
    title: "12 хуков React, которые должен знать каждый разработчик React",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/717",
    title: "React и Redux вместе. Часть 1 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/718",
    title: "React и Redux вместе. Часть 2 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/719",
    title: "React и Redux вместе. Часть 3 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/720",
    title: "React и Redux вместе. Часть 4 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/721",
    title: "React и Redux вместе. Часть 5 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/722",
    title: "React и Redux вместе. Часть 6 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/723",
    title: "React и Redux вместе. Часть 7 из 7 ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/640",
    title: "Использование хуков. Часть 1 из 3. useState(), useEffect(), useRef(), ",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/643",
    title:
      "Использование хуков. Часть 2 из 3. useContext(), useLayoutEffect(), useCallback(),  useMemo(), useImperativeHandle(), useReducer().",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/658",
    title: "Хук useCallback() и массив зависимости.",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/644",
    title:
      "Использование хуков. Часть 3 из 3. Правила хуков, пользовательские хуки: usePrevious(), useLocalStorage(), usePageBottom(), useCounter(), useMergedState(), useEventListener(), useWhatCausedRender(), useDebounce(), useThrottle(), useAsync(), useIsMountedRef(), useWindowSize(), useHistory(), useElementSize(), useHovered(), useInterval(), useTimeout(), useUpdateEffect(), ",
  },
  {
    href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
    title: "Использование Axios с React",
  },
  {
    href: "https://react-spring-io.vercel.app/hooks/use-transition",
    title:
      "Анимация перехода между страницами в React SPA с react-spring Transitioning. В hooks use-transition выбираем: Transitioning between routes",
  },
  {
    href: "https://react-spring.dev/docs/getting-started",
    title: "React Spring — это библиотека ",
  },
  {
    href: "https://www.npmjs.com/package/react-spring",
    title: "Установка анимации react-spring npm i react-spring ",
  },
  {
    href: "https://www.youtube.com/watch?v=BSmXK6z0h3s&t=942s",
    title: "Анимация перехода между страницами в React SPA с react-spring",
  },
  {
    href: "  ",
    title: " ",
  },
];

export const arrayReact: IObjectHeadingAnswers[] = [
  {
    heading: "Что такое React? ",
    answer: [
      "React - это библиотека JavaScript для создания пользовательских интерфейсов, разработанная Facebook в 2011 году",
      "В нем используется компонентный подход, который помогает в создании повторно используемых компонентов пользовательского интерфейса.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Реальный DOM.",
    answer: [
      "1. Обновляется медленно.",
      "2. Можно напрямую обновлять HTML.",
      "3. Создает новый DOM, если элемент обновляется. ",
      "4. Манипуляции с DOM очень дороги.",
      "5. Слишком много потерь памяти. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Виртуальный DOM.",
    answer: [
      "Virtual DOM - легковесный JavaScript объект, который представляет копию реального DOM дерева. Нужен для оптимизации взаимодействия с DOM",
      "1. Обновляется быстрее. ",
      "2. Невозможно напрямую обновить HTML. ",
      "3. Обновляет элемент JSX, если обновляется. ",
      "4. Манипулировать DOM очень просто. ",
      "5. Отсутствие потерь памяти.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Виртуальный DOM?",
    answer: [
      "Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. ",
      "Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что вы понимаете под виртуальным DOM? Объясните его работу. ",
    answer: [
      "Виртуальный DOM - это облегченный объект JavaScript, который изначально является просто копией реального DOM. ",
      "Этот виртуальный DOM работает в три простых шага: ",
      "1. Всякий раз, когда какие-либо базовые данные изменяются, весь пользовательский интерфейс повторно отображается в виртуальном представлении DOM. ",
      "2. Затем вычисляется разница между предыдущим представлением DOM и новым.",
      "3. Как только расчеты будут выполнены, реальный DOM будет обновлен только теми вещами, которые действительно изменились.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию виртуального DOM в React. ",
    answer: [
      "Виртуальный DOM (объектная модель документа) — это облегченное представление в памяти фактического DOM на веб-странице. В React Virtual DOM действует как посредник между выводом рендеринга компонента React и DOM браузера. ",
      "Когда состояние компонента React изменяется, React обновляет виртуальную модель DOM вместо непосредственного обновления фактической модели DOM. Это более эффективно, потому что обновление виртуального DOM происходит быстрее, чем обновление фактического DOM, поскольку он может вычислить разницу между предыдущим и текущим выходными данными рендеринга и обновить только те части, которые изменились. ",
      "Затем React берет обновленный виртуальный DOM и использует его для обновления фактического DOM, сводя к минимуму объем работы, который необходимо выполнить в фактическом DOM, и повышая общую производительность приложения. ",
      "Таким образом, виртуальный DOM в React действует как оптимизация для увеличения скорости и эффективности обновлений пользовательского интерфейса. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Каковы особенности React? ",
    answer: ["Виртуальный ДОМ.", "JSX.", "Однонаправленный поток данных.", "Рендеринг на стороне сервера.", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое JSX?",
    answer: [
      "JSX — это расширение синтаксиса Javascript, которое позволяет нам писать HTML в нашем JavaScript для создания React Elements. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие основные преимущества есть в React?",
    answer: [
      "Увеличивает производительность отрисовки приложений.",
      "Может использоваться и на клиенте и на сервере. ",
      "Из-за JSX читаемость кода увеличивается. ",
      "Легко интегрировать с другими фреймворками. ",
      "Легко писать unit тесты",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие есть ограничения в React?",
    answer: [
      "React - это просто библиотека, а не полноценный фреймворк. ",
      "Его библиотека очень большая, и для ее понимания требуется время. ",
      "Начинающим программистам может быть немного сложно понять.",
      "Кодирование становится сложным, поскольку в нем используются встроенные шаблоны и JSX.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое JSX?",
    answer: [
      "JSX - это сокращение от JavaScript XML.",
      "Это специальный синтаксис, который расширяет JavaScript возможностью писать HTML внутри. ",
      "Это позволяет интегрировать шаблоны компонентов прямо в JavaScript, что делает разработку проще. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему браузеры не могут читать JSX? ",
    answer: [
      "Браузеры могут читать только объекты JavaScript, но JSX не в обычном объекте JavaScript. ",
      "Таким образом, чтобы браузер мог читать JSX, сначала нам нужно преобразовать файл JSX в объект JavaScript с помощью JSX-трансформеров, таких как Babel, а затем передать его браузеру. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое компонент в React и каковы два основных способа их определения??",
    answer: [
      "Компоненты - это независимые, многоразовые строительные блоки пользовательского интерфейса приложения React. Компоненты независимы друг от друга, не влияют на остальную часть пользовательского интерфейса.",
      "Классовый компонент: компонент, реализованный с использованием классов ES6, расширяющих React.Component.",
      "Функциональный компонент в React — это JavaScript-функция, которая на входе получает объект с данными для отрисовки компонента (их называют props), а на выходе возвращает описание интерфейса, который нужно отобразить. Они обладают более высокой производительностью благодаря реализации в среде React.",
      "Функциональные компоненты, в большинстве случаев, заменяют классовые компоненты с помощью React Hooks.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между функциональным компонентом и компонентом класса в React? ",
    answer: [
      "В React есть два основных типа компонентов: функциональные компоненты и компоненты класса. ",
      "Функциональные компоненты, также известные как «без сохранения состояния» или «функциональные» компоненты, представляют собой функции JavaScript, которые принимают реквизиты в качестве входных данных и возвращают элементы React в качестве выходных данных. Они просты, легки для понимания и тестирования и обычно используются для презентационных компонентов, у которых нет собственных методов состояния или жизненного цикла. ",
      "Компоненты класса, с другой стороны, являются классами JavaScript, которые расширяют базовый класс React.Component. Они используются для создания компонентов, которые имеют состояние или нуждаются в доступе к методам жизненного цикла, таким как componentDidMount или shouldComponentUpdate. Компоненты класса более сложны, чем компоненты функций, но предоставляют более продвинутые функции. ",
      "Таким образом, основное различие между функциональными и классовыми компонентами в React заключается в том, что функциональные компоненты проще, понятнее и понятнее, в то время как классовые компоненты более мощные и предоставляют более продвинутые функции, но также и более сложные. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между функциональным компонентом React и классом React?",
    answer: [
      "Компоненты класса определены как классы JavaScript, которые расширяют класс React.Component, имеют метод рендеринга и могут иметь дополнительные методы и состояние жизненного цикла.",
      "Функциональные компоненты определены как простые функции JavaScript, которые возвращают разметку JSX компонента, они могут использовать состояние и другие функции React с перехватчиками.",
      "Наконец, вы можете объяснить компромиссы между компонентами класса и функциональными компонентами, например, что функциональные компоненты обычно проще и легче читаются, в то время как компоненты класса предлагают больше возможностей и гибкости. Демонстрация вашей способности взвешивать плюсы и минусы каждого подхода может продемонстрировать ваши навыки критического мышления и способность писать код, который можно обслуживать. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Когда следует использовать классовые компоненты, а когда функциональные? ",
    answer: [
      "Если нужны жизненные этапы компонента - используем class компоненты. ",
      "Иначе для оптимизации лучше функциональные ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Недостатки функциональных компонентов.",
    answer: [
      "Нет эквивалентов - хуков для жизненных циклов: getSnapshotBeforeUpdate (получить снимок перед обновлением) и componentDidCatch (компонент поймал).",
      "Старые сторонние библиотеки могут быть несовместимы с хуками.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Недостатки компонентов класса.",
    answer: [
      "Классы добавляют ненужную путаницу ради синтаксического сахара. ",
      "Классы приводят к громоздкому иерархическому дереву, особенно во время повторного использования кода, что приводит к снижению производительности и сложности тестирования. ",
      "Методы жизненного цикла класса разделяют связанные фрагменты кода. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Назовите разницу между управляемыми (контролируемым) и неуправляемыми (неконтролируемым) компонентом (Кратко.......) ",
    answer: [
      "Оба являются способами реализации элементов управления формы в React.",
      "Контролируемый компонент обладает своим стейтом. Данные формы обрабатываются компонентом React. Контролируемые компоненты являются рекомендуемым способом реализации форм.",
      "Неконтролируемые компоненты обладают внутренним стейтом (как пример значение тега textarea). Данные формы обрабатываются самим DOM. Неконтролируемые компоненты являются опцией при преобразовании устаревших баз кода в React или интеграции с не-React библиотекой¹",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "В чем разница между управляемыми (контролируемым) и неуправляемыми (неконтролируемым) компонентом в React? (Подробно...) ",
    answer: [
      "В React контролируемый компонент - это компонент, состояние которого контролируется родительским компонентом. Родительский компонент передает состояние в качестве реквизита (props) контролируемому компоненту, а также обрабатывает любые изменения состояния с помощью функций обратного вызова. Контролируемый компонент отображает только полученные пропсы и не имеет собственного состояния. ",
      "С другой стороны, неконтролируемый компонент поддерживает свое собственное внутреннее состояние и обновляет его с помощью событий DOM. Компонент напрямую обновляет DOM и не полагается на родительский компонент для передачи и обновления состояния. ",
      "Примером контролируемого компонента является ввод формы, который получает свое значение от родительского компонента в качестве реквизита и обновляет состояние родительского компонента с помощью функции обратного вызова при изменении ввода. Неконтролируемым компонентом будет ввод формы, который поддерживает свое собственное внутреннее состояние и обновляет значение непосредственно при изменении ввода, без необходимости в функции обратного вызова. ",
      "В целом, контролируемые компоненты считаются более предсказуемыми и их легче отлаживать, чем неконтролируемые компоненты. Они также упрощают реализацию комплексной проверки и обработки ошибок. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "В чем разница между управляемыми (контролируемым) и неуправляемыми (неконтролируемым) компонентами? (Подробно, с примером...) ",
    answer: [
      "В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState(). ",
      "В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange: ",
      "handleChange(event) { ",
      " - - this.setState({value: event.target.value.toUpperCase()});",
      "} ",
      "--------------------------------------------- ",
      "Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф. ",
      "import React, { useState(), useRef() } ",
      "-- ",
      "const NameForm: FC = () => { ",
      "const [ state, setState ] = useState( '' ) ",
      "const inputRef = useRef <HTMLInputElement> ( null ) ",
      " ",
      " - handleSubmit(event) {",
      " - - if( inputRef.current ) {",
      " - - - event.preventDefault();",
      " - - - alert( 'Отправленное имя: ' + inputRef.current.value );  ",
      " - - - alert( 'Отправленное имя: ' + state );",
      " - - }",
      " - }",
      "--",
      " - return (",
      " - - <form onSubmit = { this.handleSubmit }>",
      " - - - <input ",
      " - - - - - - - - type='text' ",
      " - - - - - - - - onChange = {( event ) => setState( event.target.value )}",
      " - - - - - - - - placeholder='Управляемый' />",
      " - - - <input type='text' ref={inputRef} placeholder='Неуправляемый' />",
      " - - -  ",
      " - - - <input type='submit' value='Отправить' />",
      " - - </form>",
      " - );",
      "}  ",
      "--------------------------------------------- ",
      "Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Назовите разницу между презентационным (тупой, немой) и контейнерным (интеллектуальный, умный) компонентом?",
    answer: [
      "В React компонент может быть либо без состояния, либо с состоянием. Основное различие между ними заключается в том, как они управляют своими данными и обновляют их. ",
      "1. Презентационный. Компонент без состояния, также известный как «тупой», «немой» или «презентационный» компонент, — это компонент, который не поддерживает собственное внутреннее состояние. Он получает данные и обратные вызовы через пропсы (сокращение от свойств) и отображает пользовательский интерфейс только на основе этих реквизитов. Компоненты без сохранения состояния обычно используются для простых презентационных элементов, которым не требуется обрабатывать какую-либо сложную логику или обновления внутреннего состояния. Это простые функции, которые принимают пропсы и возвращают JSX.",
      "2. Контейнерный.  Компонент с отслеживанием состояния, также известный как «интеллектуальный», «умный» или «контейнерный» компонент, — это компонент, который поддерживает собственное внутреннее состояние. Он может обрабатывать обновления внутреннего состояния и побочные эффекты, а также может управлять состоянием других дочерних компонентов. Компоненты с отслеживанием состояния обычно используются для более сложных элементов, которым необходимо обрабатывать взаимодействие с пользователем, вызовы API или другую логику. Это компоненты класса, расширяющие React.Component.",
      "В общем, рекомендуется как можно больше использовать компоненты без состояния, чтобы приложение было простым и понятным. Компоненты с состоянием следует использовать только тогда, когда необходимо управлять состоянием или обрабатывать сложную логику. ",
      "-- ",
      "Презентационный (тупой, немой) - Не имеет состояния или логики. Может только получать пропсы, отображать переданные ему данные и генерировать события (работает на входящих параметрах ). Нужен для создания интерфейса. ",
      "Контейнерный (интеллектуальный, умный) - имеет состояние и логику. Может общаться с другими компонентами через пропсы и обратные вызовы. Может совершать вызовы API или выполнять сложную логику.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "В чем разница между компонентом с состоянием («умный» или «контейнерный» компонент,) и компонентом без состояния («немой», «тупой» или «презентационный» компонент) в React? ",
    answer: [
      "В React компонент с отслеживанием состояния, также известный как «умный» или «контейнерный» компонент, — это компонент, который поддерживает собственное внутреннее состояние, обычно с помощью хуков useState или this.state . Он также может управлять данными, которые передаются ему в качестве свойств от других компонентов, и может использовать методы жизненного цикла, такие как componentDidMount , для извлечения данных или выполнения других побочных эффектов. ",
      "С другой стороны, компонент без состояния, также известный как «немой» или «презентационный» компонент, — это компонент, который получает данные только через свойства и не поддерживает собственное внутреннее состояние. Он просто визуализирует полученные данные в визуально привлекательном виде и никоим образом не управляет ими и не манипулирует ими. Эти компоненты считаются «чистыми», поскольку они связаны только с визуализацией данных и не имеют побочных эффектов. ",
      "Ключевое различие между ними заключается в том, как они управляют данными и манипулируют ими. Компоненты с состоянием имеют собственное внутреннее состояние и отвечают за его управление и обновление, в то время как компоненты без состояния просто получают данные через свойства и отображают их без каких-либо манипуляций с данными. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое props? ",
    answer: [
      "Props - это сокращение от Properties.",
      "Props - набор конфигураций, поступающий от родительского компонента в дочерний компонент.",
      "Всегда идут от родителя к ребенку.",
      "Они доступны только для чтения и их нельзя менять.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое state? ",
    answer: [
      "state - это обычный объект JavaScript, управляемый внутри компонента. ",
      "state - источник (структура) данных, который определяет отображение и поведение компонента, изменения и отслеживания пользовательских действий.",
      "В отличие от props, state можно изменять.",
      "Изменение state вызывает обновления для запуска повторного рендеринга.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между state и props? ",
    answer: [
      "State и Props — используются для хранения и управления данными в компоненте React.",
      "State используется для хранения данных и управления ими. Эти данные являются локальными и специфичными для компонента.",
      "Props используются для передачи данных от родительского компонента к его дочерним компонентам. ",
      "Состояние считается динамическим, что означает, что оно может меняться со временем в результате взаимодействия с пользователем или других событий. С другой стороны, реквизиты считаются статическими и не могут быть изменены дочерним компонентом. Вместо этого родительский компонент отвечает за обновление значения своих реквизитов и передачу обновленного значения дочернему компоненту. ",
      "Таким образом, State используется для изменения внутреннего состояния компонента и отслеживания пользовательских действий.",
      "Props — используется для передачи данных от родительского компонента к его дочерним компонентам.  Их нельзя изменять.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что вызывает обновление компонента?",
    answer: [
      "Повторный рендеринг родителя, который может повлечь за собой новые props ",
      "SetState () ",
      "(B) forceUpdate () (и этого следует избегать!) ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое refs в React? Перечислите некоторые случаи, когда вам следует использовать refs.",
    answer: [
      "Сокращенно от References. Специальный атрибут, позволяющий получить доступ до конкретного узла DOM или элемента React. ",
      "Нужен для: ",
      "Возможных измерений DOM элемента, его координат.",
      "Вызова анимаций.",
      "Для задания фокуса или выделения текста.",
      "Взаимодействия со сторонними библиотеками, для добавления методов к компонентам.",
      "Можно возвращать ссылки на определенный элемент или компонент, возвращаемый render().",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое JEST?",
    answer: [
      "JavaScript фреймворк, для юнит тестирования на основе Jasmine. Разработал Facebook. Очень удобен именно для React. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает setState() и как это работает? ",
    answer: [
      "Вначале React соединяет объект стейта с измененными полями.",
      "Когда состояние изменяется, компонент отвечает повторным рендерингом.",
      "На основе нового состояния строит новое дерево React элементов и выясняет, какие именно части приложения должны быть изменены. ",
      "Это нужно для наиболее производительного обновления интерфейса.",
      "Вызовы setState() являются асинхронными и могут быть пакетными. ",
      "Обновления state не отражают новое значение сразу после вызова setState(). Нужен useEffect(). ",
      "Из-за своей асинхронной природы вызов метода setState () путем передачи объекта, содержащего значение текущего состояния, может привести к неожиданному поведению.",
      "Передача setState () функции, а не объекта, позволяет получить доступ к значению текущего состояния, избегая потенциально непредвиденного поведения, вызванного асинхронностью.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Когда следует делать асинхронные запросы на сервер в React? ",
    answer: ["Для этого служит метод componentDidMount. ", "Или useEffect с пустым набором зависимостей.", " "],
    isParagraph: true,
  },
  {
    heading: "Как вы справляетесь с асинхронной загрузкой данных в приложении React? ",
    answer: [
      "Одним из популярных способов обработки асинхронной загрузки данных является использование хука useEffect в сочетании с fetch или библиотекой, такой как axios , для загрузки данных в компонент после его рендеринга. Хук useEffect позволяет синхронизировать компонент с внешней системой, такой как сервер, запустив побочный эффект (загрузку данных) после рендеринга компонента. Хук принимает функцию обратного вызова, содержащую эффект, и массив зависимостей. ",
      "Другой способ — использовать библиотеку, такую ​​как redux-thunk или redux-saga, для обработки асинхронного запроса и сохранения данных в хранилище/состоянии. Эти библиотеки предоставляют простой способ обработки асинхронных действий и поддержания чистоты состояния компонента. ",
      "В любом случае важно следить за состоянием компонента и правильно обновлять его с помощью загруженных данных. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем смысл специального атрибута key?",
    answer: [
      "Атрибут позволяет React понимать, какие именно элементы в списке были модифицированы или удалены, что увеличивает производительность рендеринга.",
      "Лучше всего использовать уникальные значения, такие как ID. Индексы рекомендуется использовать только в тех случаях, когда точно не будет удалений этих элементов и нет возможности использовать id. ",
      "Ключи используются для идентификации уникальных виртуальных элементов DOM с соответствующими данными, управляющими пользовательским интерфейсом. Они помогают React оптимизировать рендеринг, перерабатывая все существующие элементы в DOM. Эти ключи должны быть уникальным номером или строкой, с помощью которых React просто переупорядочивает элементы, а не перерисовывает их. Это приводит к увеличению производительности приложения. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Для чего нужен атрибут key при рендере списков? ",
    answer: [
      "Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени. ",
      "Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Основная задача React",
    answer: [
      "Основная задача React — выяснить, как изменить DOM, чтобы он соответствовал тому, что компоненты хотят отображать на экране. ",
      "React делает это путем «монтирования» (добавления узлов в DOM), «размонтирования» (удаления их из DOM) и «обновления» (внесения изменений в узлы, уже находящиеся в DOM). ",
      "То, как узел React представлен как узел DOM, а также где и когда он появляется в дереве DOM, управляется API верхнего уровня. ",
      "Процесс создания экземпляров и узлов DOM, соответствующих компонентам React, и вставки их в DOM называется монтированием. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что значит компонент mounted?",
    answer: ["Компонент смонтирован, выводится, рендерится. Шаблон компонента соединен с DOM деревом", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое фрагменты?",
    answer: [
      "Специальный элемент в React позволяющий возвращать группу элементов без дополнительного родительского DOM элемента.",
      "<></> ",
      "<React.Fragment></React.Fragment>",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое событие в React? ",
    answer: [
      "В React события - это срабатывающие реакции на определенные действия, такие как наведение курсора мыши, щелчок мышью, нажатие клавиши и т. д. ",
      "Обработка этих событий аналогична обработке событий в элементах DOM. Но есть некоторые синтаксические различия, такие как:",
      "События называются с использованием верблюжьего регистра, а не просто с использованием нижнего регистра. ",
      "События передаются как функции, а не строки.",
      "Аргумент event содержит набор свойств, специфичных для события. Каждый тип события содержит свои собственные свойства и поведение, доступ к которым возможен только через его обработчик событий. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как React обрабатывает пользовательские события?",
    answer: [
      "Добавляет один обработчик события на корневой элемент.",
      "Объект события оборачивает в свою обертку - SyntheticEvent для кроссбраузерности.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В setState можно передавать объект или функцию. В чем разница и что лучше использовать? ",
    answer: [
      "props и state могут изменяться асинхронно. ",
      "Если мы передадим функцию, то мы точно будет знать, что стейт основывается на предыдущем состоянии.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Context? ",
    answer: [
      "Context - позволяет передавать свойства от родителя к ребенку, избегая промежуточных компонентов.",
      "Контекст в React — это концепция, которая позволяет вам снабжать дочерние компоненты глобальными данными, независимо от того, насколько глубоко они находятся в дереве компонентов.",
      "Для использования контекста требуется 3 шага: создание, предоставление и использование контекста. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Context в React и для чего он используется? ",
    answer: [
      "Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык). ",
      "Контекст позволяет избежать передачи пропсов в промежуточные компоненты: ",
      "Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов. ",
      "React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов. ",
      "Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения. ",
      "Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе. ",
      "Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext(). ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Higher-Order компоненты?",
    answer: [
      "Компонент высшего порядка.",
      "Higher-order component (HOC) - функции, у которых входящий параметр компонент. Возвращают новый компонент с добавленным поведением.",
      "Могут быть использованы в следующих случаях: ",
      "1. Переиспользование кода. ",
      "2. Слой абстракции для state и взаимодействия с ним.",
      "3. Управление props",
      "Компонент более высокого порядка - это усовершенствованный способ повторного использования логики компонента. По сути, это шаблон, который вытекает из композиционной природы React. HOC - это пользовательские компоненты, которые включают в себя другой компонент. Они могут принимать любой динамически предоставляемый дочерний компонент, но они не будут изменять или копировать какое-либо поведение своих входных компонентов. Можно сказать, что HOC - это 'чистые' компоненты. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию компонента высшего порядка (HOC) в React и когда его использовать.",
    answer: [
      "Компонент высшего порядка (HOC) в React — это функция, которая принимает компонент в качестве аргумента и возвращает новый компонент с дополнительными параметрами. Целью HOC является повторное использование логики в нескольких компонентах. HOC не является «частью» React, это шаблон React для повторного использования логики компонентов. ",
      "Используйте HOC, когда вам нужно: ",
      "1. Использовать общую логику для нескольких компонентов, например выборку данных или авторизацию. ",
      "2. Абстрактное состояние и поведение, которые можно повторно использовать в вашем приложении в многоразовом HOC.",
      "3. Визуализируйте компонент внутри другого компонента и передайте свойства обернутому компоненту.",
      "Примеры HOC включают withRouter HOC из react-router и connect HOC из react-redux . ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " Что вы можете сделать с HOC?",
    answer: [
      "HOC можно использовать для многих задач, таких как:",
      "1. Повторное использование кода, логика и абстракция начальной загрузки. ",
      "2. Рендеринг с высоким коэффициентом.",
      "3. Абстракция состояния и манипулирование.",
      "4. Манипуляции со свойствами (пропсами).",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает shouldComponentUpdate (следует обновить компонент) и почему он важен? ",
    answer: [
      "Этап жизненного цикла, который решает, будет ли ре-рендер, или нет.",
      "Позволяет оптимизировать приложение",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Redux?",
    answer: [
      "Redux — это стэйт менеджер, библиотека для управления состоянием приложения в JavaScript.",
      "Он хранит состояние в дереве объектов внутри единого стора.",
      "Redux — позволяет передавать данные из единого стора. Миную необходимость передавать пропсы через каждый уровень (так называемое 'prop drilling').",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает Redux? ",
    answer: [
      "Redux хранит состояние в дереве объектов внутри единого стора. ",
      "1. Единственная возможность изменить состояние - отправить action.",
      "2. Action - это объект, который описывает действие (он отвечает на вопрос: 'Что я хочу изменить в состоянии?').",
      "3. Далее action попадает в reducer, где описано, как состояние должно быть изменено. (reducer отвечает на вопрос: 'Как я хочу изменить стэйт?').",
      "4. Корневой редуктор объединяет вывод нескольких редукторов в одно дерево состояний.",
      "5. Store сохраняет новое дерево состояний и уведомляет зарегистрированных слушателей.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Каким трем принципам следует Redux? ",
    answer: [
      "1. Единый источник истины: состояние всего приложения хранится в дереве объектов / состояний в одном хранилище. Единое дерево состояний упрощает отслеживание изменений с течением времени и отладку или проверку приложения.",
      "2. Доступно только для чтения: Состояние Единственный способ изменить состояние - запустить действие. Действие - это простой JS-объект, описывающий изменение. Точно так же, как состояние - это минимальное представление данных, действие - это минимальное представление изменений в этих данных.",
      "3. Изменения вносятся с помощью чистых функций: чтобы указать, как дерево состояний преобразуется действиями, вам нужны чистые функции. Чистые функции - это те, возвращаемое значение которых зависит исключительно от значений их аргументов.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что вы понимаете под “внутренним источником правды”? ",
    answer: [
      "Redux использует ‘Хранилище’ для хранения всего состояния приложения в одном месте. Таким образом, все состояния компонентов хранятся в хранилище, и они получают обновления из самого хранилища. Единое дерево состояний упрощает отслеживание изменений с течением времени и отладку или проверку приложения.",
    ],
    isParagraph: true,
  },
  {
    heading: "Flux-архитектура, Redux и MobX: Что такое Flux (поток) - архитектура? Какие сущности она имеет?",
    answer: [
      "Flux — это архитектурный шаблон или набор шаблонов программирования, обеспечивающий однонаправленный поток данных. Он контролирует производные данные и обеспечивает связь между несколькими компонентами, используя центральное хранилище, которое имеет полномочия для всех данных. Любое обновление данных в приложении должно происходить только здесь. Flux обеспечивает стабильность приложения и снижает количество ошибок во время выполнения. ",
      "Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении. ",
      "В минимальном варианте Flux-архитектура может содержать три слоя, взаимодействующие по порядку: ",
      "1. Действия (англ. actions) — выражение событий (часто для действий используются просто имена — строки, содержащие некоторый «глагол»). Диспетчеры передают действия нижележащим компонентам (хранилищам) по одному. Новое действие не передаётся пока предыдущее полностью не обработано компонентами. Действия из-за работы источника действия, например, пользователя, поступают асинхронно, но их диспетчеризация явлется синхронным процессом. Кроме имени (англ. name), действия могут иметь полезную нагрузку (англ. payload), содержащую относящиеся к действию данные.",
      "2. Диспетчер/Диспатчер (англ. dispatcher) предназначен для передачи действий хранилищам. В упрощённом варианте диспетчер может вообще не выделяться, как единственный на всё приложение. В диспетчере хранилища регистрируют свои функции обратного вызова (callback) и зависимости между хранилищами.",
      "3. Хранилище (англ. store) является местом, где сосредоточено состояние (англ. state) приложения. Остальные компоненты, согласно Flux, не имеют значимого (с точки зрения архитектуры) состояния. Изменение состояния хранилища происходит строго на основе данных действия и старого состояния хранилища при помощи чистых функций.",
      "4. Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю. Во Flux-архитектуре, которая может технически не касаться внутреннего устройства представлений вообще, это — конечная точка потоков данных. Для информационной архитектуры важно только, что данные попадают в систему (то есть, обратно в хранилища) только через действия.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Перечислите основные составляющие Redux.",
    answer: [
      "Redux состоит из следующих компонентов: ",
      "1. Action - это объект со свойством type, указывающие, какой тип действия выполняется. Описывает то, что произошло.",
      "2. Reducers — это функции, которые принимают Action и текущее состояние и возвращают результирующее состояние. Это место, где можно определить, как изменится состояние.",
      "3. Store —  хранилище. Store — это центральный объект, который поддерживает и обновляет состояние приложения. Store также занимается регистрацией и отменой регистрации слушателей",
      "4. dispatch — этот метод позволяет отправить Action диспетчеру и изменить state приложения.",
      "5. Представление (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое action в Redux?",
    answer: [
      "Объект, который обязательно должен содержать ключ type. С помощью него Redux понимает, что именно нужно сделать со state.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните роль Reducer.  Что такое reducer?",
    answer: [
      "Простая чистая функция, принимающая state и action и модифицирующая state.",
      "Должна возвращать новый объект.",
      "Редюсеры работают, принимая предыдущее state и action, а затем возвращают новый state. Он определяет, какое обновление необходимо выполнить, в зависимости от типа action, а затем возвращает новые значения. Он возвращает предыдущее состояние как есть, если не нужно выполнять никакой работы.",
      "-- ",
      "1. Редюсеры — это чистые функции, которые определяют, как изменяется состояние приложения в ответ на ДЕЙСТВИЕ.",
      "2. Редюсеры работают, принимая предыдущее состояние и действие, а затем возвращая новое состояние.",
      "3. Он определяет, какое обновление необходимо выполнить, в зависимости от типа действия, а затем возвращает новые значения.",
      "4. Он возвращает предыдущее состояние как есть, если не нужно выполнять никаких действий.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между редюсером (reducer) и действием (action) в Redux?",
    answer: [
      "В Redux редюсер и действие — это два разных, но связанных понятия. ",
      "Действие — это простой объект JavaScript, описывающий изменение, которое необходимо внести в состояние приложения. У него есть свойство type , определяющее тип выполняемого действия, и свойство payload , предоставляющее любые дополнительные данные, необходимые для выполнения действия. Действия отправляются из приложения в хранилище Redux, которое затем передает действие редюсерам. ",
      "Редюсер — это чистая функция, которая принимает текущее состояние приложения и действие и возвращает следующее состояние приложения. Редуктор отвечает за обработку действий и соответствующее обновление состояния. Он не должен выполнять никаких побочных эффектов, таких как выполнение вызовов API, а вместо этого должен возвращать только следующее состояние. ",
      "Таким образом, действия описывают, что должно измениться, а редюсеры определяют, как должно измениться состояние в ответ на действия. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое store в Redux? ",
    answer: [
      "1. store (хранилище) — это объект JavaScript, который может хранить состояние приложения и предоставлять несколько вспомогательных методов для доступа к состоянию, отправки действий и регистрации слушателей.",
      "2. Все дерево состояний/объектов приложения сохраняется в одном хранилище.",
      "3. Мы можем передать промежуточное ПО в хранилище для обработки данных, а также для ведения журнала различных действий, которые изменяют состояние хранилищ. ",
      "4. Все действия возвращают новое состояние через редюсеры.",
      " - - state может быть получен через getState(). ",
      " - - Изменять state можно через dispatch(action). ",
      " - - Регистрировать изменения через subscribe(listener).",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " Каковы преимущества Redux?",
    answer: [
      "Преимущества Redux перечислены ниже: ",
      "1. Предсказуемость результата - поскольку всегда есть один источник истины, то есть store, нет путаницы в том, как синхронизировать текущее состояние с actions и другими частями приложения. ",
      "2. Ремонтопригодность – код становится легче поддерживать с предсказуемым результатом и строгой структурой.",
      "3. Рендеринг на стороне сервера – вам просто нужно передать хранилище, созданное на сервере, на сторону клиента. Это очень полезно для первоначального рендеринга и обеспечивает лучший пользовательский интерфейс, поскольку оптимизирует производительность приложения.",
      "4. Инструменты разработчика - от действий до изменений состояния, разработчики могут отслеживать все, что происходит в приложении в режиме реального времени.",
      "5. Сообщество и экосистема - за Redux стоит огромное сообщество, что делает его еще более увлекательным в использовании. Большое сообщество талантливых людей вносит свой вклад в улучшение библиотеки и разрабатывает с ее помощью различные приложения.",
      "6. Простота тестирования - код Redux в основном состоит из небольших, чистых и изолированных функций. Это делает код тестируемым и независимым.",
      "7. Организация - Redux точно определяет, как должен быть организован код, это делает код более последовательным и простым, когда с ним работает команда.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Redux Toolkit? ",
    answer: [
      "Redux Toolkit: официальный набор инструментов -Redux, позволяющий быстро приступить к работе с Redux. Поставляется с готовыми функциями и утилитами, которые помогают легко настроить магазин и создавать действия и редукторы.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какова цель функции combReducers в Redux? ",
    answer: [
      "Функция combReducers используется для объединения различных редюсеров, обрабатывающих разные части состояния, в один корневой редюсер. Затем этот корневой редуктор передается функции createStore для создания хранилища Redux. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между подключенным компонентом и компонентом в React-Redux? ",
    answer: [
      "Подключенные компоненты — это компоненты более высокого порядка, которые обернуты вокруг простых компонентов, чтобы предоставить им доступ к хранилищу Redux. Подключенные компоненты используются для доступа к состоянию хранилища и действиям по отправке, тогда как обычные компоненты используются для управления элементами пользовательского интерфейса и состоянием локальных компонентов.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию Saga в Redux. ",
    answer: [
      "Saga в Redux — это способ управления побочными эффектами (например, асинхронными операциями, такими как выборка данных, и нечистыми операциями, такими как доступ к кешу браузера) в приложении Redux. Он реализован как промежуточное программное обеспечение с использованием функций генератора в JavaScript и работает в фоновом режиме, отдельно от основного потока вашего приложения, отслеживая действия, отправленные в хранилище. При обнаружении определенного действия Saga может выполнять различные задачи и инициировать дополнительные действия по мере необходимости, обновляя хранилище на основе результатов асинхронных операций. Основное преимущество использования Sagas заключается в том, что они упрощают анализ, тестирование и управление потоком данных в вашем приложении.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между синхронным действием и асинхронным действием в Redux?",
    answer: [
      "В Redux действие — это простой объект JavaScript, описывающий изменение состояния приложения. Действия могут быть как синхронными, так и асинхронными. ",
      "Синхронное действие — это действие, которое отправляется и немедленно обрабатывается хранилищем Redux. Хранилище обновляет состояние, и обновленное состояние немедленно становится доступным для использования компонентами. ",
      "С другой стороны, асинхронное действие — это действие, которое отправляется, но для его завершения требуется некоторое время. Асинхронные действия обычно используются при выполнении сетевых запросов или выполнении других операций, требующих времени. Эти действия не могут быть немедленно обработаны хранилищем Redux, поэтому для их выполнения требуется дополнительная логика. ",
      "В приложении Redux асинхронные действия часто обрабатываются с помощью промежуточного программного обеспечения, такого как redux-thunk или redux-saga , которые позволяют диспетчеризировать действия, представляющие начало и завершение асинхронных операций. Это ПО промежуточного слоя обеспечивает способ обработки асинхронности операции и обеспечения надлежащего обновления состояния после завершения операции. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое контекстный API?",
    answer: [
      "Как и Redux, Context API — это решение для управления состоянием.",
      " Контекст состоит из 3 основных частей: ",
      "1. Объект Context создается с использованием React.createContext (defaultValue)",
      "2. Провайдер — это компонент, который инициирует повторное рендеринг всех потребителей-потомков при изменении его значения.",
      "3.Потребитель — это компонент, который подписывается на изменения контекста.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что нельзя делать в методе render?",
    answer: [
      "Нельзя изменять состояние компонента (например вызывать setState). ",
      "Должен быть чистой (pure) функцией. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие типы middleware есть в redux для работы с асинхронностью?",
    answer: ["1. Redux Thunk.", "2. Redux Promise. ", "3. Redux Saga. ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: "Зачем нужен Redux Thunk?",
    answer: ["Middleware позволяющая изменять состояние приложения в Redux в асинхронном режиме.", " "],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию Thunk (Преобразователь) в Redux. ",
    answer: [
      "Преобразователь в Redux — это функция, которая возвращает другую функцию вместо простого объекта действия. Он используется для выполнения асинхронных операций и отправки нескольких действий. Преобразователи позволяют вам писать генераторы действий, которые возвращают функцию вместо действия. Это может быть полезно для выполнения асинхронных операций, таких как вызовы API, и диспетчеризации нескольких действий, например, одного, чтобы указать, что вызов API начался, и другого, чтобы указать, что он завершен. Внутренняя функция получает метод отправки хранилища в качестве аргумента, который можно использовать для отправки действий в любой момент в будущем. Преобразователи обычно реализуются с использованием промежуточного программного обеспечения, такого как промежуточное программное обеспечение redux-thunk .",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое PureComponent? (чистый компонент) ",
    answer: [
      "Тоже самое, что и Component, кроме того, что автоматически за вас реализует метод shouldComponentUpdate (следует обновить компонент). ",
      "PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния. ",
      "Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию чистого компонента в React. (PureComponent) ",
    answer: [
      "«Чистый компонент» в React — это компонент, который обновляется только при изменении его свойств или состояния.  ",
      "Напротив, «нечистый компонент» повторно рендерится каждый раз, когда повторно рендерится родительский компонент, независимо от того, изменились ли его пропсы или состояние. ",
      "Чистые компоненты более продуктивны, поскольку они не требуют повторного рендеринга.",
      "Расширяя React, компонент React можно сделать чистым.",
      "React заменяется PureComponent. Компонент.",
      "Это побуждает метод shouldComponentUpdate, который решает, следует ли выполнять повторный рендеринг, обеспечить автоматическое поверхностное сравнение реквизитов и состояния компонента. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему не стоит изменять state напрямую?",
    answer: [
      "Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. ",
      "Корректно использовать метод setState(). ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как изменить state используя динамический ключ? ",
    answer: ["inputChangeHandler(event) {", "setState({", "[event.target.name]: event.target.value  ", "}) ", " ", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое React Hooks? Объясните концепцию хука в React.",
    answer: [
      "Функционал, добавленный в React 16.8. С помощью хуков, можно писать приложения, используя только функциональные компоненты, без классов. ",
      "С помощью хуков можно следить за стейтом, эмулировать жизненные этапы компонента, работа с ссылками (ref) и многое другое.",
      "-- ",
      "Хуки — это новая функция в React, которая позволяет нам добавлять состояние и другие функции React к функциональным компонентам. Они были представлены в React 16.8 и с тех пор стали популярным способом управления состоянием и побочными эффектами в функциональных компонентах. ",
      "Хуки — это именованные функции, которые начинаются со слова use и позволяют нам повторно использовать логику с отслеживанием состояния в компонентах без необходимости писать компонент класса.  ",
      "Например, хук useState позволяет нам добавлять состояние к функциональному компоненту, а хук useEffect позволяет нам выполнять побочные эффекты, такие как выборка данных или обновление заголовка документа. ",
      "Хуки делают наш код более пригодным для повторного использования, более простым для понимания и тестирования.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию пользовательского (кастомного) хука (Custom Hooks,) в React.",
    answer: [
      "Пользовательский хук в React — это функция JavaScript, которая позволяет извлекать логику состояния и поведение из компонента и повторно использовать его в нескольких компонентах. ",
      "Пользовательские хуки называются с использованием префикса (например , useForm , useFetch ) и могут вызывать другие хуки, а также ваши собственные пользовательские хуки. У них те же правила, что и у хуков, и их можно вызывать только на верхнем уровне вашего компонента или ваших собственных пользовательских хуков. ",
      "Пользовательские хуки могут получать аргументы и возвращать значения, как и обычные функции, но они также могут управлять состоянием и выполнять побочные эффекты. Абстрагируя состояние и поведение в Custom Hook, вы можете улучшить читабельность и удобство сопровождения вашего кода. ",
      "Примеры вещей, которые вы можете создать с помощью Custom Hooks: ",
      "1. Получение данных.",
      "2. Управление обновлениями состояния.",
      "3. Обработка отправленных форм.",
      "4. Реализация анимации и переходов.",
      "И многое другое. ",
      "Использование пользовательских хуков может сделать ваши компоненты более чистыми, более удобными для повторного использования и более простыми для тестирования, что делает их мощным инструментом в вашем наборе инструментов React. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "useState()",
    answer: [
      "Кратко: ",
      "1. useState — это хук, который позволяет добавлять состояние React для компонентов функций.",
      "2. useState, как и все хуки, является функцией.",
      "3. Аргумент: исходное состояние (initialState)",
      "4. Возвращает: пара, содержащая текущее состояние и функцию для его обновления.",
      "- ",
      "Подобно: ",
      "const [ state, setState ] = useState( initialState ); ",
      "Возвращает значение с состоянием (state) и функцию для его обновления (setState). ",
      "Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState). ",
      "Функция setState используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента: setState(newState);",
      " ",
      "Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым последним состоянием после применения обновлений. ",
      "Использование в setState объекта: ",
      "setState( initialState ) ",
      "-- ",
      "Использование в setState функции: ",
      "1. setState(( prev) => !prev ) ",
      "2. setState(( prev) => prev + 1 ) ",
      "3. setState(( prev) => prev - 1) ",
      "- ",
      "useState не объединяет объекты обновления автоматически. Вы можете повторить это поведение, комбинируя форму функции обновления с синтаксисом расширения объекта: ",
      "const [state, setState] = useState({}); ",
      "setState(prevState => { ",
      " - // Object.assign также будет работать",
      " - return {...prevState, ...updatedValues};",
      "}); ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "useEffect()",
    answer: [
      "Кратко: ",
      "1. useEffect позволяет выполнять побочные эффекты в компонентах функций.",
      "2. useEffect срабатывает после рендеринга. ",
      "3. Аргументы: вызываемая функция и массив зависимостей.",
      "-- ",
      "Подобно: ",
      "useEffect(() => { функция }, [ массив зависимостей ]) ",
      "Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране. ",
      "По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Очистка эффекта (компонента).",
    answer: [
      "Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку, идентификатор таймера или прослушиватель событий. Чтобы сделать это, функция переданная в useEffect, может вернуть функцию очистки. Например, чтобы создать / удалить прослушиватель событий: ",
      "useEffect(() => { ",
      " - // Добавляем прослушиватель событий",
      " - document.addEventListener('scroll', scrollHandler);",
      " - return function () {",
      " - - // Очищаем компнонент перед тем, как он покинет экран: удаляем прослушиватель событий",
      " - - document.removeEventListener('scroll', scrollHandler);",
      " - };",
      "}, [top]); ",
      "-- ",
      "Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта. В нашем примере это означает, что прослушиватель событий создаётся при каждом обновлении и удаляется перед закрытием.  ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Условное срабатывание эффекта, массив зависимостей хуков.",
    answer: [
      "По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда пересоздаётся, если значение какой-то из зависимости изменилось. ",
      "Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп source.",
      "Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом зависимостей, от которых зависит эффект. Наш обновлённый пример теперь выглядит так: ",
      "useEffect( ",
      " - () => {",
      " - - const subscription = props.source.subscribe();",
      " - - return () => {",
      " - - - subscription.unsubscribe();",
      " - - };",
      " - }, [props.source],",
      "); ",
      "Теперь подписка будет создана повторно только при изменении props.source. ",
      "-- ",
      "Примечание: ",
      "Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом. В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров. Отдельные страницы документации рассказывают о том, как поступить с функциями и что делать с часто изменяющимися массивами. ",
      "Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ([]) вторым аргументом. React посчитает, что ваш эффект не зависит от каких-либо значений из пропсов или состояния и поэтому не будет выполнять повторных запусков эффекта. ",
      "Если вы передадите пустой массив ([]), пропсы и состояние внутри эффекта всегда будут иметь значения, присвоенные им изначально.",
      "Не забывайте, что React откладывает выполнение useEffect, пока браузер не отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой.",
      "Массив зависимостей не передаётся в качестве аргументов функции эффекта. Тем не менее, в теории вот что происходит: каждое значение, на которое ссылается функция эффекта, должно также появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создать этот массив автоматически.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "useContext()",
    answer: [
      "const value = useContext( MyContext );",
      "Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве. ",
      "Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext. Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext. ",
      "Запомните, аргументом для useContext должен быть непосредственно сам объект контекста: ",
      " - Правильно: useContext( MyContext )",
      " - Неправильно: useContext(MyContext.Consumer)",
      " - Неправильно: useContext(MyContext.Provider)",
      "Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации. ",
      "useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста. ",
      "Соединим все вместе с Context.Provider: ",
      "------------------------------------------ ",
      "-- Создадим файл context/index.ts -- ",
      "import { createContext } from 'react'; ",
      "-- ",
      "interface IAuthContext { ",
      " - isAuth: boolean;",
      " - setAuth: React.Dispatch< React.SetStateAction < boolean >>;",
      "} ",
      "-- ",
      "export const AuthContext = createContext< IAuthContext > ({ ",
      " - isAuth: false,",
      " - setAuth: () => {},",
      "}); ",
      "------------------------------------------ ",
      "-- функциональный компонент App -- ",
      "import React, { FC, useState } from 'react'; ",
      "import AppRouter from '../AppRouter'; ",
      "import { AuthContext } from '../../context/index'; ",
      "-- ",
      "const App: FC = () => { ",
      " - const [ isAuth, setAuth ] = useState< boolean >( false ); ",
      "-- ",
      "- return ( ",
      " - - <div>",
      " - - - <AuthContext.Provider value = {{ isAuth, setAuth }} >",
      " - - - - <AppRouter />",
      " - - - </AuthContext.Provider>",
      " - - </div>",
      " - );",
      "}; ",
      "export default App; ",
      "------------------------------------------ ",
      "-- функциональный компонент TopMenu -- ",
      "import React, { FC, useContext } from 'react'; ",
      "- ",
      "const TopMenu: FC = () => { ",
      " - const { isAuth, setAuth } = useContext( AuthContext ); ",
      " - const openAdminLogin = () => { setAuth ( true ) }",
      " - const closeAdminLogin = () => { setAuth ( false ) }",
      " ",
      " - return ( ",
      " - - // .... ",
      " - )",
      "export default TopMenu; ",
      "------------------------------------------ ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию контекста в React.",
    answer: [
      "В React контекст — это способ обмена данными, которые считаются «глобальными» для дерева компонентов. Это позволяет вам передавать данные через дерево компонентов без необходимости вручную передавать пропсы на каждом уровне. ",
      "Компонент, которому требуется доступ к данным контекста, может использовать их с помощью хука useContext или компонента Consumer. Чтобы сделать контекст доступным для компонента, родительский компонент должен предоставить его с помощью компонента Provider. ",
      "Контекст часто используется для данных, которые требуются многим компонентам приложения, таким как текущий авторизованный пользователь, текущая локаль или тема. ",
      "Следует отметить, что контекст следует использовать с осторожностью, так как он может затруднить анализ и тестирование ваших компонентов. Если есть возможность, лучше передавать пропсы по дереву компонентов вручную. ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "useMemo()",
    answer: [
      "const memoizedValue = useMemo(() => { computeExpensiveValue ( a, b ) }, [ a, b ] ",
      "React.memo для оптимизации производительности работы. ",
      "React.memo – это компонент более высокого порядка, который позволяет оптимизировать производительность ваших компонентов, предотвращая ненужную повторную визуализацию. ",
      "Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. ",
      "Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo. ",
      "Если массив не был передан, новое значение будет вычисляться при каждом рендере. ",
      "Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана.",
      "Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.",
      "-- ",
      "Без useMemo: ",
      "const newsFilteredByYear = [ ...news ].filter(( item ) => {",
      " - return new Date( item.date ).getFullYear() === Number( selectedYear );",
      " - });",
      "-- ",
      "С добавлением useMemo: ",
      "const newsFilteredByYear = useMemo( () => { ",
      " - return [ ...news ].filter(( item ) => {",
      " - - return new Date( item.date ).getFullYear() === Number( selectedYear );",
      " });",
      "}, [ news, selectedYear ]); ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "useRef()",
    answer: [
      "import React, { FC, useRef } from 'react'; ",
      "-- ",
      "В функциональном компоненте: ",
      "const refColumn = useRef< HTMLDivElement > ( null ); ",
      "-- ",
      "useEffect(() => { ",
      "if ( refColumn.current ) { ",
      "emitWidthColumn ( refColumn.current?.offsetWidth ); ",
      "} ",
      "}, [ emitWidthColumn ]); ",
      "-- ",
      "В jsx: ",
      " return ( ",
      " - <div ref = { refColumn }> ",
      " - - - <div> {title} </div>",
      " - </div> ",
      "); ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как передавать данные между компонентами в ReactJS ",
    answer: [
      "1. Через пропсы;",
      "2. Используя callback-функцию;",
      "3. Пробросом пропсов от уровня к уровню (prop drilling);",
      "4. При помощи контекста (React Context AP);",
      "5. Через хранилище (store);",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое prop drilling и как этого избежать?",
    answer: [
      "Передача свойств на прямую от родителя к ребенку через сложную и длинную иерархию компонентов.",
      "Избежать можно используя Context или например Redux.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как валидировать props в React? ",
    answer: [
      "Для этого есть дополнительная библиотека - PropTypes",
      "Для осуществления проверки типов рекомендуется использовать TypeScript - расширение JavaScript.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Разница между Flow и PropTypes? ",
    answer: [
      "Flow - статический инструмент для проверки типов. Использует аннотации и позволяет найти ошибки при компиляции (аналог TypeScript) ",
      " PropTypes - проверяет типы входящих параметров в runtime",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Зачем делать eject?",
    answer: ["На случай, если необходимо модифицировать конфигурацию проекта (webpack, babel)", " "],
    isParagraph: true,
  },
  {
    heading: "Что не так с этим кодом?",
    answer: [
      "setState(( prev, props ) => { ",
      " - return {",
      " - - counter: prev.counter + props.counter ",
      " - }  ",
      "}) ",
      "С этим кодом все хорошо. Изменяем state на основе прошлого состояния и входящих параметров.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какой второй аргумент можно опционально передать в setState и какова его цель? (Это для Class) ",
    answer: [
      "Второй аргумент, который при необходимости может быть передан в setState, -это функция обратного вызова, которая вызывается сразу после завершения setState и повторного рендеринга компонентов. ",
      "Если вы хотите, чтобы ваша программа обновила значение состояния с помощью setState, а затем выполнила определенные действия с обновленным значением состояния, вы должны указать эти действия в функции, которая должна быть вторым аргументом setState. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Правда ли, что React делает ре-рендер всех компонентов и дочерних компонентов каждый раз когда вызывается setState? ",
    answer: [
      "По умолчанию - да. И в функциональном и в классовом компонентах.",
      "В классовом компоненте  мы этим можем управлять в shouldComponentUpdate(nextProps, nextState).",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как можно улучшить производительность React приложения? ",
    answer: [
      "Для функциональных компонентов: ",
      "1. Сохранение состояния компонента локальным, где это необходимо. ",
      "2. Использование Hook React.memo() для предотвращения ненужных повторных рендеров. ",
      "3. Разделение кода в React с помощью динамического импорта.",
      "4. Виртуализация окон или списков в React.",
      "5. Ленивая загрузка изображений в React.",
      "-- ",
      "Для класс компонентов: ",
      "1. shouldComponentUpdate в класс компонентах.",
      "2. PureComponent для класс компонентов.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Понимание того, как React обновляет пользовательский интерфейс. ",
    answer: [
      "Когда мы создаем компонент, React создает виртуальный DOM-дерево элементов в компоненте. Когда состояние компонента изменяется, React воссоздает виртуальный DOM-дерево и сравнивает результат с предыдущим рендерингом. ",
      "React использует концепцию виртуального DOM, чтобы минимизировать затраты на производительность повторного рендеринга веб-страницы, потому что фактический DOM требует больших затрат на манипулирование. ",
      "Это здорово, потому что уменьшает время рендеринга пользовательского интерфейса. Однако эта концепция также может замедлить работу сложного приложения, если оно не сконфигурировано должным образом. ",
      "Изменение состояния в компоненте React вызывает повторную визуализацию (рендеринг). Точно так же, когда состояние передается дочернему компоненту в качестве свойства, оно перерисовывается в дочернем компоненте и так далее, что нормально, потому что React должен обновлять пользовательский интерфейс. ",
      "Проблема возникает, когда на дочерние компоненты не влияет изменение состояния. Другими словами, они не получают никаких свойств от родительского компонента. ",
      "Тем не менее React повторно визуализирует эти дочерние компоненты. Итак, пока родительский компонент выполняет повторную визуализацию, все его дочерние компоненты выполняют повторную визуализацию независимо от того, передается ли им свойство или нет, это поведение React по умолчанию. ",
      "Всякий раз, когда состояние компонента обновляется, ChildComponent выполняет повторную визуализацию, даже если на него не влияет изменение состояния напрямую. ",
      "В большинстве случаев повторный рендеринг не должен вызывать проблем с производительностью, и мы не должны замечать никаких задержек в нашем приложении. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " В чем ключевое отличие между React и Angular? ",
    answer: [
      "React - библиотека для отрисовки приложения. Для другого функционала нужны другие решения (например для данных - Redux).",
      "Angular - обширный фреймворк, где все решения есть в ядре (в коробке). ",
      " -  Используя React - можно более гибко создавать приложения и более точечно управлять его частями.",
      " - Используя Angular - проще разрабатывать и поддерживать приложения.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Лучшие рекомендации (оптимизация) для React разработчиков в 2023 году. ",
    answer: [
      "1. Использование функциональных компонентов. ",
      "2. Использование hooks. ",
      "3. Использование React Context для управления состоянием.",
      "4. Использование React.memo для оптимизации производительности работы. React.memo – это компонент более высокого порядка, который позволяет оптимизировать производительность ваших компонентов, предотвращая ненужную повторную визуализацию.",
      "5. Использование библиотеки React Router.",
      "6. Использование расширения React Developer. ",
      "7. Использование линтера для соблюдения стиля кода. ",
      "8. Использование фреймворка для тестирования. ",
      "9. Использование сборщиков модулей. webpack",
      "10. Использование IDE (редактора кода) для повышения производительности. Visual Studio Code ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы справляетесь с оптимизацией кода в большом приложении React? ",
    answer: [
      "Оптимизация кода в большом приложении React может быть достигнута с помощью нескольких подходов: ",
      "1. Разделение кода. Это позволяет разделить код на более мелкие фрагменты, которые можно загружать по требованию, что сокращает время первоначальной загрузки приложения.",
      "2. Отложенная загрузка. Отложенная загрузка позволяет загружать компоненты только тогда, когда они необходимы, уменьшая объем кода, который необходимо загрузить и проанализировать при запуске.",
      "3. Использование сборщика, такого как Webpack: сборщик может помочь вам оптимизировать ваш код, уменьшив размер ваших файлов JavaScript, объединив несколько файлов в один и т. д.",
      "4. Использование кэширования. Вы можете кэшировать данные и компоненты, которые часто используются в вашем приложении, чтобы избежать повторной выборки одних и тех же данных.",
      "5. Использование эффективных алгоритмов и структур данных. Чтобы ваше приложение работало быстро, важно использовать алгоритмы и структуры данных, оптимизированные для повышения производительности.",
      "6. Регулярный мониторинг производительности и профилирование. Регулярный мониторинг производительности и профилирование могут помочь вам определить узкие места в производительности и области, требующие улучшения в вашем коде.",
      "7. Использование методов оптимизации, таких как мемоизация. Используя такие методы, как мемоизация, вы можете уменьшить количество ненужных повторных рендерингов и вычислений в своем приложении, повысив его общую производительность.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Использование линтера для соблюдения стиля кода. ",
    answer: [
      "Общий стиль кода важен для любого проекта, и это особенно важно при работе с командой. Линтер может помочь вам обеспечить согласованный стиль кода, обнаруживая и выделяя такие проблемы, как пропущенные точки с запятой, неиспользуемые переменные и другие распространенные ошибки. ",
      "Чтобы использовать линтер в вашем проекте React, вам сначала нужно установить его с помощью npm: ",
      "npm install eslint",
      "-- ",
      "Затем вы можете создать файл конфигурации для линтера, выполнив следующую команду: ",
      "npx eslint --init ",
      "-- ",
      "На этом этапе вы пройдете через серию подсказок по настройке линтера для вашего проекта. Как только настройка будет завершена, вы можете запустить этот инструмент, используя следующую команду: ",
      "npx eslint . ",
      "-- ",
      "После запуска линтера, он сообщит о любых обнаруженных проблемах. Вы также можете использовать специальные плагины для вашего текстового редактора, чтобы автоматически выделять возникающие проблемы во время работы. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните разницу между рендерингом на стороне сервера и рендерингом на стороне клиента в React.",
    answer: [
      "В приложении React существует два основных способа рендеринга компонентов: рендеринг на стороне сервера (SSR) и рендеринг на стороне клиента (CSR). ",
      "1. Рендеринг на стороне сервера (SSR) — это когда первоначальный рендеринг приложения React выполняется на сервере. Сервер генерирует HTML для начального состояния приложения и отправляет его в браузер. Когда пакет JavaScript загружается, React вступает во владение, и приложение продолжает функционировать как SPA (одностраничное приложение) на стороне клиента. Его преимущества: ",
      " - Улучшена производительность для поисковых систем и пользователей на медленных соединениях. ",
      " - Более быстрое время до первого байта.",
      " - Лучшая доступность для пользователей, у которых отключен JavaScript.",
      "2. Рендеринг на стороне клиента (CSR) — это когда приложение React полностью визуализируется в браузере с использованием JavaScript. Браузер запрашивает пакет JavaScript с сервера, а затем отображает компоненты на стороне клиента. Преимущество этого подхода: ",
      " - более быстрая загрузка для пользователей, с быстрым подключением и более отзывчивом пользовательском интерфейсе.",
      "-- ",
      "В общем, CSR — это более простой вариант реализации и более популярный, но SSR — хороший выбор для определенных случаев использования, например, когда SEO является основной задачей или когда приложение нацелено на пользователей с медленным интернет-соединением. ",
      "Также стоит отметить, что возможен гибридный подход между SSR и CSR, который называется изоморфным или универсальным рендерингом. Такой подход позволяет использовать преимущества как SSR, так и CSR. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обрабатываете рендеринг на стороне сервера в приложении React?",
    answer: [
      "Рендеринг на стороне сервера (SSR) в React включает в себя рендеринг ваших компонентов React на сервере и отправку полученного HTML-кода клиенту. Это дает ряд преимуществ, включая повышение производительности и оптимизацию для поисковых систем (SEO). Чтобы реализовать SSR в приложении React, вы можете использовать библиотеку, например Next.js или Razzle, которая предоставляет простую в использовании структуру для обработки SSR. Кроме того, вы можете использовать API ReactDOMServer для ручного рендеринга ваших компонентов на сервере. Ключевыми этапами процесса являются: ",
      "1. Настройка вашего сервера для обработки входящих запросов и рендеринга соответствующих компонентов.",
      "2. Рендеринг компонентов на сервере с помощью ReactDOMServer.renderToString или ReactDOMServer.renderToStaticMarkup.",
      "3. Отправка полученного HTML-кода клиенту как часть ответа.",
      "4. Увлажнение компонентов на клиенте, чтобы пользователь мог интерактивно управлять ими.",
      "Стоит отметить, что SSR имеет некоторые компромиссы и дополнительную сложность, поэтому важно тщательно взвесить, является ли это правильным выбором для вашего приложения. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обеспечиваете сохранение данных в приложении React? ",
    answer: [
      "В приложении React сохранение данных может быть реализовано различными способами, в том числе: ",
      "1. Локальное хранилище: это позволяет хранить пары ключ-значение в локальном хранилище браузера, которое можно получить даже после того, как пользователь закроет браузер или перезагрузит свое устройство.",
      "2. Файлы cookie: файлы cookie представляют собой небольшие фрагменты данных, которые хранятся в браузере пользователя и могут быть доступны веб-сайту при последующих посещениях.",
      "3. IndexedDB: это низкоуровневый API для хранения на стороне клиента больших объемов структурированных данных, включая файлы и большие двоичные объекты.",
      "4. Веб-база данных SQL: это устаревшая технология хранения данных в базе данных на стороне клиента с использованием SQL.",
      "5. Хранилище на стороне сервера: вы также можете хранить данные на удаленном сервере с помощью API или базы данных, такой как MySQL, MongoDB, PostgreSQL и т. д.",
      "6. Redux или Mobx: библиотеки управления состоянием, такие как Redux или Mobx, можно использовать для управления и сохранения состояния приложения в различных компонентах и ​​сеансах.",
      "Какой из них использовать, зависит от вашего конкретного случая использования и требований. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обрабатываете ошибки в приложении React? ",
    answer: ["Использую блок try-catch", " "],
    isParagraph: true,
  },

  {
    heading: "В чем разница между статическим и динамическим компонентами в React?",
    answer: [
      "В React статический компонент — это компонент, который определен с фиксированным набором свойств или атрибутов и не изменяется в течение своего жизненного цикла. Статический компонент определяется с помощью простой функции JavaScript, которая возвращает дерево элементов, представляющих пользовательский интерфейс компонента. ",
      "С другой стороны, динамический компонент — это компонент, который может изменять свои свойства, состояние или поведение в зависимости от взаимодействия с пользователем или событий, происходящих в приложении. Динамический компонент обычно определяется с использованием компонента класса или функционального компонента с перехватчиками useState или useEffect.",
      "Вот пример статического компонента: ",
      "function welcome ( props ) { ",
      " - - return <h1>Hello, { props.name }</h1>; ",
      "}",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию компонента без рендеринга в React.",
    answer: [
      "Компонент без рендеринга — это компонент, у которого есть логика, но отсутствуют элементы HTML. Этот компонент предоставляет данные и методы другим компонентам через пропсы и обратные вызовы.",
      "Задача компонента без рендеринга — аккумулировать логику, которую можно повторно использовать в нескольких компонентах. ",
      "Другие компоненты, использующие логику, предоставляемую компонентом без рендеринга, могут затем отображать необходимые им HTML-элементы на основе данных и методов, которые они получают от компонента без рендеринга.",
      "Этот подход разделяет логику и визуализацию, упрощая поддержку и тестирование кода.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Специальными возможности в приложении React.",
    answer: [
      "Специальные возможности в React дают доступ к приложению людям с ограниченными способностями. Для этого применяются следующие методы: ",
      "1. Семантический HTML. Используйте семантические элементы HTML, такие как <button> , <nav> и <header> , чтобы четко определить структуру и цель вашего контента.",
      "2. Доступные реквизиты: используйте доступные реквизиты, такие как aria-label , role и tabIndex , чтобы предоставить дополнительную информацию вспомогательным технологиям, таким как программы чтения с экрана.",
      "3. Навигация с помощью клавиатуры. Убедитесь, что все функции доступны с помощью клавиатуры и что фокус клавиатуры управляется правильно.",
      "4. Цветовой контраст: убедитесь, что контраст между текстом и фоном достаточно высок, чтобы его могли прочитать люди с дальтонизмом или слабым зрением.",
      "5. Альтернативный текст. Предоставьте альтернативный текст изображениям, видео и другим нетекстовым элементам, чтобы обеспечить доступность информации для пользователей программ чтения с экрана.",
      "6. Тестирование средств чтения с экрана. Протестируйте приложение с помощью средств чтения с экрана и других вспомогательных технологий, чтобы выявить и устранить любые проблемы с доступностью.",
      "Важно отметить, что доступность — это непрерывный процесс, и его следует учитывать на протяжении всей разработки вашего приложения React. Использование таких инструментов, как правила линтинга и инструменты проверки доступности, также может помочь обеспечить доступность вашего приложения. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обеспечиваете совместимость браузера в приложении React? ",
    answer: [
      "Чтобы обеспечить совместимость браузера в приложении React, вы можете использовать различные методы, такие как: ",
      "1. Полифиллы: для поддержки старых браузеров вы можете использовать полифиллы. Полифиллы — библиотеки JavaScript, которые эмулируют отсутствующие функции в старых браузерах.",
      "2. Обнаружение браузера: вы можете использовать такие библиотеки, как browser-detect , чтобы определить браузер пользователя и его версию и соответствующим образом настроить свой код.",
      "3. Обнаружение функций: вместо того, чтобы полагаться на обнаружение браузера, вы можете использовать обнаружение функций, чтобы проверить, поддерживается ли конкретная функция браузером пользователя, прежде чем использовать ее.",
      "4. Сброс CSS: вы можете использовать сбросы CSS, такие как normalize.css , чтобы убедиться, что все браузеры отображают стили согласованным образом.",
      "5. Тестирование. Регулярное тестирование в различных браузерах и устройствах необходимо для выявления любых проблем совместимости на ранних этапах процесса разработки.",
      "Используя эти методы, вы можете обеспечить бесперебойную работу вашего приложения React в разных браузерах и на разных устройствах. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обеспечиваете безопасность в приложении React? ",
    answer: [
      "Обеспечение безопасности в приложении React включает в себя несколько шагов, в том числе: ",
      "1. Проверка ввода: проверяйте все вводимые пользователем данные на стороне клиента и сервера, чтобы предотвратить обработку любых вредоносных данных.",
      "2. Аутентификация и авторизация пользователей. Используйте безопасный механизм аутентификации, такой как веб-токены JSON (JWT), чтобы гарантировать, что только авторизованные пользователи могут получить доступ к конфиденциальным данным.",
      "3. Безопасное хранение конфиденциальных данных: не храните конфиденциальную информацию, такую ​​как пароли и номера кредитных карт, в локальном хранилище, вместо этого используйте зашифрованное хранилище.",
      "4. Внедрение HTTPS. Используйте HTTPS для обеспечения безопасной связи между клиентом и сервером и защиты от сетевых атак, таких как атаки «человек посередине».",
      "5. Поддержание зависимостей в актуальном состоянии: регулярно обновляйте React и его зависимости, чтобы исправить любые известные уязвимости безопасности.",
      "6. Использование политики безопасности контента (CSP): внедрите политику безопасности контента (CSP), чтобы ограничить типы ресурсов, которые можно загружать в приложение React, и предотвратить атаки межсайтовых сценариев (XSS)",
      "7. Регулярные проверки безопасности. Проводите регулярные проверки безопасности, чтобы своевременно выявлять и устранять потенциальные проблемы безопасности.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию провайдера в React-Redux. ",
    answer: [
      "«Поставщик» в React-Redux — это компонент более высокого порядка, который обертывает ваше приложение React и предоставляет ему возможность доступа к хранилищу Redux. Это позволяет вам передавать хранилище вашим компонентам, используя контекст, без необходимости вручную передавать его в качестве реквизита через каждый уровень дерева компонентов. ",
      "Используя Provider, вы гарантируете, что все ваши компоненты могут подписываться на хранилище и отправлять действия для изменения его состояния. Другими словами, Provider действует как мост между вашими компонентами React и вашим хранилищем Redux, делая хранилище доступным для всех компонентов вашего приложения. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы справляетесь с разделением кода в приложении React? ",
    answer: [
      "Разделение кода в React можно реализовать с помощью следующих подходов: ",
      "Динамический импорт. Динамический импорт позволяет лениво загружать компонент только тогда, когда это необходимо. Это делается с помощью синтаксиса import() и позволяет разделить код на более мелкие фрагменты, которые можно загружать по требованию. ",
      "Webpack Bundle Analyzer: это инструмент, который обеспечивает визуальное представление кода и его размера. Вы можете использовать этот инструмент для определения больших фрагментов кода, которые можно разделить на более мелкие фрагменты и загрузить лениво. ",
      "Используя эти подходы, вы можете эффективно справляться с разделением кода в приложении React и повышать его производительность за счет сокращения времени начальной загрузки и загрузки только необходимого кода по запросу. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Webpack Bundle Analyzer",
    answer: [
      "Если вы используете Create React App, Next.js, Gatsby или похожие инструменты, то у вас уже будет настроенный Webpack для бандлинга приложения. ",
      "Webpack Bundle Analyzer: это инструмент, который обеспечивает визуальное представление кода и его размера. Вы можете использовать этот инструмент для определения больших фрагментов кода, которые можно разделить на более мелкие фрагменты и загрузить лениво. ",
      "Большинство React-приложений «собирают» свои файлы такими инструментами, как Webpack, Rollup или Browserify. Сборка (или «бандлинг») — это процесс выявления импортированных файлов и объединения их в один «собранный» файл (часто называемый «bundle» или «бандл»). Этот бандл после подключения на веб-страницу загружает всё приложение за один раз. ",
      "Иначе, вам нужно будет настроить webpack самостоятельно. Для этого ознакомьтесь со страницами по установке и началу работы в документации по Webpack. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между компонентом React и элементом React? ",
    answer: [
      "Компонент React — это класс или функция JavaScript, которая возвращает элемент React. Это многократно используемый элемент пользовательского интерфейса, описывающий часть пользовательского интерфейса.",
      "С другой стороны, элемент React — это простой объект JavaScript, представляющий узел DOM. Это неизменное представление узла DOM, которое можно создать с помощью React.createElement или JSX. ",
      "Короче говоря, компонент — это план создания элементов, а элемент — экземпляр компонента. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию промежуточного программного обеспечения в Redux. ",
    answer: [
      "В Redux промежуточное программное обеспечение — это программный компонент, который находится между хранилищем и процессом диспетчеризации действий для добавления дополнительных функций, таких как ведение журнала, отчеты о сбоях, обработка асинхронных действий и т. д. Он позволяет расширять поведение хранилища без изменения самого хранилища. . Промежуточное программное обеспечение применяется с использованием метода applyMiddleware и может быть составлено вместе для достижения желаемого поведения. Когда действие отправлено, оно проходит через каждое ПО промежуточного слоя в том порядке, в котором они были составлены, что дает ПО промежуточного слоя возможность взаимодействовать с действием до того, как оно достигнет хранилища. Это дает возможность манипулировать действиями и состоянием, а также выполнять сложные действия, которые могут охватывать несколько действий.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы справляетесь с интернационализацией в приложении React? ",
    answer: [
      "Обработка интернационализации (i18n) в приложении React включает в себя адаптацию пользовательского интерфейса и содержимого приложения для соответствия языковым и культурным требованиям различных регионов. ",
      "Существует несколько библиотек и методов, которые можно использовать для реализации интернационализации в приложении React, в том числе: ",
      "1. react-intl: популярная библиотека для интернационализации приложений React. Он предоставляет компоненты для форматирования дат, чисел и строк, а также обработки множественного числа и извлечения сообщений.",
      "2. Контекстный API: Контекстный API React можно использовать для хранения текущей локали и сделать ее доступной для компонентов, которым она нужна. Язык можно изменить динамически, чтобы переключить язык приложения.",
      "3. Пользовательские хуки: Пользовательские хуки могут быть написаны для инкапсуляции логики форматирования и получения сообщений, а также для упрощения использования в компонентах.",
      "4. Реализация интернационализации в приложении React может значительно улучшить взаимодействие с пользователем, говорящим на разных языках и проживающим в разных регионах. Это важное соображение для любого приложения, которое стремится иметь глобальный охват.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между функциональным компонентом React и классом React?",
    answer: [
      "Когда дело доходит до собеседования, важно понимать разницу между компонентами класса React и функциональными компонентами. Эти знания могут продемонстрировать ваше понимание React и его компонентов, а также показать вашу способность писать эффективный и удобный для сопровождения код. ",
      "Когда вас спросят о компонентах класса, вы можете подчеркнуть, что они определены как классы JavaScript, которые расширяют класс React.Component , имеют метод рендеринга и могут иметь дополнительные методы и состояние жизненного цикла. Вы также можете привести простой пример, чтобы показать свое понимание компонентов класса. ",
      "Когда вас спросят о функциональных компонентах, вы можете подчеркнуть, что они определены как простые функции JavaScript, которые возвращают разметку JSX компонента, и что они могут использовать состояние и другие функции React с перехватчиками. Вы также можете привести пример, показывающий, как написать функциональный компонент, который обеспечивает ту же функциональность, что и компонент класса. ",
      "Наконец, вы можете объяснить компромиссы между компонентами класса и функциональными компонентами, например, что функциональные компоненты обычно проще и легче читаются, в то время как компоненты класса предлагают больше возможностей и гибкости. Демонстрация вашей способности взвешивать плюсы и минусы каждого подхода может продемонстрировать ваши навыки критического мышления и способность писать код, который можно обслуживать. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните концепцию мемоизации в React.",
    answer: [
      "В React мемоизация — это метод, используемый для оптимизации производительности компонента за счет предотвращения ненужных повторных рендерингов. Он включает в себя кэширование результатов рендеринга компонента, поэтому, если входные данные (реквизиты) для компонента не меняются, кэшированный результат можно использовать повторно вместо повторного вычисления результата. ",
      "React предоставляет встроенный хук под названием useMemo для реализации мемоизации. useMemo принимает функцию и массив зависимостей в качестве аргументов и возвращает запомненное значение. Функция выполняется повторно, только если одна или несколько зависимостей изменились. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы обрабатываете события в React? ",
    answer: [
      "При создании приложения React часто требуется реагировать на действия пользователя, такие как нажатия кнопок, отправка форм и другие события. В React это достигается за счет использования обработчиков событий. ",
      "Обработчик событий — это функция обратного вызова, которая прикрепляется к элементу пользовательского интерфейса и выполняется, когда происходит указанное событие. ",
      "Например, чтобы обработать событие нажатия на кнопку, вы должны определить в своем компоненте React функцию, которая обновляет состояние компонента, а затем прикрепить эту функцию к кнопке в качестве обработчика события onClick  ",
      "Обработчики событий являются ключевой частью системы обработки событий React и используются для добавления интерактивности в ваше приложение. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Обработчик событий",
    answer: [
      "Обработчик событий — это функция обратного вызова, которая прикрепляется к элементу пользовательского интерфейса и выполняется, когда происходит указанное событие. ",
      "Обработчики событий являются ключевой частью системы обработки событий React и используются для добавления интерактивности в ваше приложение. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Каковы различные фазы жизненного цикла компонента React? ",
    answer: [
      "1. 'Initial Rendering' - начальная фаза рендеринга :  это фаза, когда компонент собирается начать свой жизненный путь и пробиться в DOM. ",
      "2. 'Updating' - фаза обновления :  как только компонент добавлен в DOM, он потенциально может обновляться и перерисовываться только тогда, когда происходит изменение свойства или состояния. Это происходит только в этой фазе.",
      "3. 'Unmounting' - фаза размонтирования : это заключительная фаза жизненного цикла компонента, на которой  компонент уничтожается и удаляется из DOM.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Назовите основные этапы жизненного цикла компонента ",
    answer: [
      "componentWillMount (компонент будет монтироваться) - выполняется непосредственно перед рендерингом как на стороне клиента, так и на стороне сервера. В основном для настройки компонента.",
      "render - процесс рендеринга (отдачи). ",
      "componentDidMount (компонент смонтировал) - уведомляет, про то, что компонент соединен с DOM деревом. Выполняется на стороне клиента только после первого рендеринга.",
      "componentWillReceiveProps (компонент получает свойства) - уведомляет, про то, что приходят новые входящие свойства в компонент. Вызывается сразу после получения props от родительского класса и перед вызовом другого рендеринга.",
      "shouldComponentUpdate (следует обновить компонент) - возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг.",
      "componentWillUpdate (компонент будет обновляться) - уведомляет, что компонент будет обновлен. Вызывается непосредственно перед рендерингом в DOM.",
      "componentDidUpdate (компонент сделал обновление) - уведомляет, что компонент был обновлен. Вызывается сразу после выполнения рендеринга.",
      "componentWillUnmount (компонент будет размонтирован) - используется для удаления слушателей и очистки памяти компонента. Вызывается перед удалением компонента, после отключения компонента от DOM.",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие методы жизненного цикла компонента существуют в React? ",
    answer: [
      "1. render() — единственный обязательный метод в классовом компоненте. При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null.",
      "2. constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам. Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру. Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().",
      "3. componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.",
      "4. componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().",
      "5. shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.",
      "6. static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.",
      "7. getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().",
      "8. static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().",
      "9. componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "render()",
    answer: [
      "render() — единственный обязательный метод в классовом компоненте.",
      "При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "constructor()",
    answer: [
      "Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам. ",
      "Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру. ",
      "Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState(). ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое React.createContext?",
    answer: [
      "React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Context.Provider?",
    answer: [
      "Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Class.contextType? ",
    answer: [
      "Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Context.Consumer?",
    answer: [
      "Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext(). ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Виртуальный DOM?",
    answer: [
      "Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. ",
      "Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает проп children? ",
    answer: [
      "Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод: ",

      "function FancyBorder(props) { ",
      " -  return (",
      " - -  <div className={'FancyBorder FancyBorder-' + props.color}>",
      " - - - {props.children}",
      " - - </div>",
      " - );",
      "} ",
      "------------------------------------------------------------------ ",
      "Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX: ",
      "function WelcomeDialog() { ",
      " - return (",
      " - - <FancyBorder color='blue'>",
      " - - - <h1 className='Dialog-title'>",
      " - - - - Добро пожаловать",
      " - - - </h1>",
      " - - - <p className='Dialog-message'>",
      " - - - - Спасибо, что посетили наш космический корабль!",
      " - - - </p>",
      " - - </FancyBorder>",
      " - );",
      " }",
      "------------------------------------------------------------------ ",
      "Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое порталы в React?",
    answer: [
      "Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. ",
      "ReactDOM.createPortal(child, container) ",
      "Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент. ",
      "Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое React Reconciliation (Cверка) и как он работает? ",
    answer: [
      "Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента. ",
      "При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. ",
      "Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. ",
      "При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. ",
      "По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Можно создавать анимации в React? ",
    answer: [
      "React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Правила использования хуков.",
    answer: [
      "Нельзя вызывать хуки внутри циклов, условных операторов или вложенных функций. ",
      "Хуки нужно вызывать только внутри React-функций, до возврата какого-либо значения из них.",
      "Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами useState и useEffect. ",
      "Нельзя вызывать хуки из обычных js-функций, но можно: ",
      " - - Вызывать хуки из функционального компонента.",
      " - - Вызывать хуки из пользовательского хука.",
      "Следуя этим правилам, можно гарантировать, что вся логика состояния компонента чётко видна из исходного кода.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
];

/* eslint-disable no-template-curly-in-string */
import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksJavascript: ILinkInfo[] = [
  {
    href: "https://wm-school.ru/js/index.php",
    title: "Шикарный учебник JavaScript на русском языке",
  },
  {
    href: "https://ivan-shamaev.ru/javascript-notes-for-web-development/",
    title: "JavaScript - заметки для web-разработки",
  },
  {
    href: "https://habr.com/ru/post/486820/",
    title: "70 вопросов по JavaScript для подготовки к собеседованию",
  },
  {
    href: "https://www.geeksforgeeks.org/find-the-number-occurring-odd-number-of-times/",
    title: "Задачи по javascript. geeksforgeeks",
  },
  {
    href: "https://dev.to/thepracticaldev/series/1326",
    title: "Задачи по javascript. Daily Challenge Series' Articles",
  },
  {
    href: "https://www.codewars.com/kata/53f40dff5f9d31b813000774/train/javascript",
    title: "Задачи по javascript. Kata Training",
  },
  {
    href: "https://medium.com/nuances-of-programming/var-let-const-%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-dc6c3beb0b12#:~:text=var%20%2D%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%BA%D0%B0%D0%BA,%D0%BE%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%20%D0%BD%D0%B0%D0%B2%D0%B5%D1%80%D1%85%20%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8.",
    title: "Var, Let, Const — в чем разница? (Подробная статья )",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#vsplytie",
    title: "Всплытие и погружение событий",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#prekraschenie-vsplytiya",
    title: "Прекращение всплытия события",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#event-target",
    title: "event.target",
  },
  {
    href: "https://learn.javascript.ru/prototype-inheritance",
    title: "Прототипное наследование",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Glossary/Falsy",
    title: "Ложноподобное (falsy) значение",
  },
  {
    href: "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent",
    title: "Событие Клавиатуры",
  },
  {
    href: "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code",
    title: "KeyboardEvent.code",
  },
  {
    href: "https://www.codingem.com/regex/",
    title: "Регулярное выражение",
  },
  {
    href: "https://itchief.ru/javascript/scope-and-context",
    title: "Область видимости и контекст в JavaScript ",
  },
  {
    href: "https://drbrain.ru/articles/js-spread-vs-rest/",
    title: "SPREAD vs REST. Чем отличаются операторы spread и rest в JavaScript ",
  },
  {
    href: "https://techrocks.ru/2021/08/23/javascript-programming-cheatsheet/",
    title: "Синтаксис и методы JavaScript: шпаргалка",
  },
  {
    href: "https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/",
    title: "Методы строк в JavaScript: простая шпаргалка с примерами",
  },
  {
    href: "https://basicweb.ru/javascript/js_string.php",
    title: "JavaScript строки",
  },
  {
    href: "https://itchief.ru/javascript/numbers ",
    title: "Работа с числами в JavaScript",
  },
  {
    href: "https://date-fns.org/v2.28.0/docs/Locale",
    title: "Формат даты Locale (есть ещё лучше)",
  },
  {
    href: "https://date-fns.org/v2.28.0/docs/format",
    title: "Форматирование даты (есть ещё лучше)",
  },
  {
    href: "http://www.lingoes.net/en/translator/langcode.htm",
    title: "Формат даты Locale",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat",
    title: "Intl.DateTimeFormat. Международный формат даты и времени",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/705",
    title: "Event Loop — макрозадачи и микрозадачи",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/704",
    title: "Promise API",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/703",
    title: "Асинхронный код — callback, promise и async/await",
  },
  {
    href: "https://medium.com/nuances-of-programming/%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-javascript-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-f47cf28fb130",
    title: "Асинхронный JavaScript ― Цикл обработки событий",
  },
  {
    href: "https://learn.javascript.ru/async-await",
    title: "Async/await",
  },
  {
    href: "https://doka.guide/js/async-in-js/",
    title: "Асинхронность в JS",
  },
  {
    href: "https://doka.guide/tools/http-protocol/",
    title: "Протокол HTTP",
  },
  {
    href: "https://doka.guide/js/async-await/",
    title: "async/await",
  },
  {
    href: "https://habr.com/ru/search/?q=axios&target_type=posts&order=relevance",
    title: "Axios или Fetch?",
  },
  {
    href: "https://axios-http.com/",
    title: "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js.",
  },
  {
    href: "https://www.freecodecamp.org/news/axios-react-how-to-make-get-post-and-delete-api-requests/",
    title: "Axios React — как получать(GET), публиковать(post) и удалять(DELETE) запросы API",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/690",
    title: "Браузерные события, часть 1 из 5. Основные сведения",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/691",
    title: "Браузерные события, часть 2 из 5. Погружение и всплытие",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/692",
    title: "Браузерные события, часть 3 из 5. Делегирование",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/693",
    title: "Браузерные события, часть 4 из 5. Действие браузера по умолчанию",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/695",
    title: "Браузерные события, часть 5 из 5. Генерация пользовательских событий",
  },
  {
    href: "https://habr.com/ru/company/hexlet/blog/656003/",
    title: "Как устроены цикл событий (event loop) и стек вызовов в JavaScript ",
  },
  {
    href: "https://www.codewars.com/kata/convert-to-binary ",
    title: "Сборник задач по JavaScript codewars kata",
  },
  {
    href: " ",
    title: " ",
  },
];

export const arrayJavascript: IObjectHeadingAnswers[] = [
  {
    heading: "Что такое JavaScript?",
    answer: [
      "JavaScript — это однопоточный (single threaded) язык программирования с одиночным стеком вызовов. Это означает, что в один момент JavaScript может выполнять только одну операцию (обработать только один кусок кода). ",

      "JavaScript — это язык программирования на стороне клиента/сервера.",
      "JavaScript можно вставить в HTML, чтобы сделать веб-страницу интерактивной и обеспечить взаимодействие с пользователем.",
      "JavaScript имеет динамическую типизацию. Это означает, что тип объектов проверяется во время выполнения . (В статически типизированном языке тип проверяется во время компиляции.) Другими словами, переменные JavaScript не связаны с типом. Это означает, что вы можете без проблем изменить тип данных.",
      "JavaScript — это интерпретируемый язык. Интерпретатор в браузере читает код JavaScript, интерпретирует каждую строку и запускает ее.",
      "JavaScript — это язык, чувствительный к регистру.",
      "JavaScript работает с одним потоком. Это означает, что он выполняет код по порядку и должен завершить выполнение фрагмента кода, прежде чем перейти к следующему.",
      "Это не позволяет писать код, который интерпретатор мог бы выполнять параллельно в нескольких потоках или процессах.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое область видимости и цепочка областей видимости (scope chain?)",
    answer: [
      "Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям.",
      "JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6). ",
      "1. Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде. ",
      "2. Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции. ",
      "3. Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.",
      "Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain). ",
      "Таким образом, цепочкой областей видимости (scope chain) можно назвать последовательность областей видимости, которые интерпретатор JavaScript использует для поиска переменных. При этом поиск всегда начинается с текущей области видимости и если только она не найдена в текущей, то происходит переход к следующей по цепочке и поиск переменной там и т.д. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Var, Let, Const — в чем разница?",
    answer: [
      "Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }).",
      "Если не планируется изменять значение переменной, то объявлять её лучше через «const». Это позволит избежать объявление переменной дважды, случайно изменив её. Переменные, объявленные при помощи «const», нельзя обновить или объявить заново. То есть, значение переменной, объявленной при помощи «const», остается неизменным.",
      "Переменные, объявленные при помощи let, могут обновляться, но не объявляться повторно.",
      "Переменные, объявленные с помощью ключевого слова «var», НЕ имеют блочную область видимости. Переменные, объявленные при помощи «var», могут как объявляться заново, так и обновляться.",
    ],
    isParagraph: true,
  },
  {
    heading: "Поднятие переменных и функций (hoisting) var",
    answer: [
      "Поднятие - это подъем объявления переменной или функции в глобальную или функциональную области видимости..",
      "Это означает, что функцию можно вызвать из любой точки области видимости, даже до того, как они будут определены.",
      "Переменные, объявленные при помощи var, поднимаются в верх своей области видимости и инициализируются присвоением какого-нибудь значения или undefined.",
      "--",
      " 1. Поднятие — подъем переменной или функции в глобальную или функциональную области видимости.",
      " 2. В фазе компиляции переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода).",
      " 3. В фазе выполнения переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.",
      " 4. Запомнить! Поднимаются только переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое поднятие (Hoisting)? (2-ой вариант ответа)",
    answer: [
      "Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости. ",
      "Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения. ",
      "Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. ",
      "Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.). ",
      "Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются. ",
      "Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Контекст выполнения.",
    answer: [
      "Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое замыкание и как/для чего его используют?",
    answer: [
      "Замыкание - это наша функция и её область видимости. Мы имеем доступ к всем переменным, которые находятся внутри неё.",
      "Если одна функция определена внутри другой, то внутренняя функция имеет доступ к области видимости внешней функции. Это называется замыканием.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое всплытие событий?",
    answer: [
      "Всплытие событий, это процесс запуска обработчиков событий на целевом элементе, затем вверх по цепочке предков, пока событие не достигнет самого внешнего элемента - самого document.",
      "--",
      "Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      "Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое погружение события?",
    answer: [
      "Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.",
    ],
    isParagraph: true,
  },
  {
    heading: "event.target – это элемент, на котором произошло событие, называется целевым элементом.",
    answer: [
      "Всегда можно узнать, на каком конкретно элементе произошло событие. Этот элемент доступен через event.target.",
      "event.target, на котором произошло событие, в процессе всплытия неизменен.",
    ],
    isParagraph: true,
  },
  {
    heading: "Методы event.stopPropagation() и event.stopImmediatePropagation()",
    answer: [
      "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию, событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.",
      "На любом промежуточном обработчике может решить, что событие полностью обработано, и остановить всплытие.",
      "Для этого в этом обработчике нужно вызвать метод event.stopPropagation().",
      "Метод event.stopPropagation() останавливает продвижение события дальше, но на текущем элементе все обработчики будут вызваны.",
      "Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.",
      " ",
      "Не прекращайте всплытие без необходимости!",
      "Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.",
      "Зачастую прекращение всплытия через event.stopPropagation() имеет свои подводные камни, которые со временем могут стать проблемами.",
    ],
    isParagraph: true,
  },
  {
    heading: "Делегирование событий.",
    answer: [
      "Всплытие событий позволяет реализовать один из самых важных приёмов разработки - делегирование.",
      "Делегирование событий заключается в том, что мы ставим один обработчик на общего предка (контейнер) элементов, подлежащих однотипной обработке.",

      "Если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком потомке произошло событие и обаботать его.",
      "Алгоритм: вешаем обработчик на контейнер. В обработчике получаем event.target. В обработчике, если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.",
      "Зачем использовать: упрощает инициализацию и экономит память: не нужно вешать много обработчиков. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики. Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как this работает в JavaScript.",
    answer: [
      "Ключевое слово this относится к текущему объекту, внутри которого пишется код.",
      "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.",
      "Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает прототипное наследование",
    answer: [
      "Прототипом объекта А называется объект B, свойства и методы которого доступны для объекта A как собственные.",
      "У любого объекта есть прототип, на который указывает его свойство __proto__ и который также является объектом.",
      "У любой функции есть ассоциированный с ней объект, на который в контексте функции указывает свойство prototype. В него, как в контейнер обычно складывают свойства и методы для работы с определенным классом объектов.",
      "Такой контейнер автоматически становится прототипом объектов, создаваемых функциями-конструкторами Для редактирования прототипной ссылки объекта используют метод Object.create() - он перезаписывает объект заново и выставляет в нем ссылку на нужный прототип.",
      "Ссылки, связанных друг с другом объектов, образуют прототипную цепочку, которая лежит в основе прототипного наследования. Ярким примером такого наследования является цепочка узлов DOM модели.",
    ],
    isParagraph: true,
  },
  {
    heading: "Типы данных в JavaScript",
    answer: [
      " - Строка «string». Строка может содержать ноль или больше символов, нет отдельного символьного типа.",
      " - Число «number» - единый тип для любых чисел: как для целых, так и для дробных чисел; дробные значения ограничены диапазоном ±(253-1). Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.",
      " - «bigint» даёт возможность работать с целыми числами произвольной длины. Тип «number» не может содержать числа больше, чем (253-1), или меньше, чем -(253-1). ",
      " - «boolean» булевый (логический) тип представляет логическое значение true или false",
      " - «null» для неизвестных значений – отдельный тип, имеющий одно значение null. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».",
      " - «undefined» для неприсвоенных значений. Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.",
      " - Символы «symbol» для уникальных идентификаторов. «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.",
      " - Объекты «object» для более сложных структур данных. Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}",

      "Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.",
      "Имеет две формы: typeof x или typeof(x).",
      "Возвращает строку с именем типа. Например, 'string'",
      "Для null возвращается object – это ошибка в языке, на самом деле это не объект.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить тип переменной (данных) в JavaScript?",
    answer: [
      "Воспользуйтесь typeof оператором.",
      " - typeof John Abraham возвращает string",
      " - typeof 100 возвращает number ",
    ],
    isParagraph: true,
  },
  {
    heading: "Typeof оператор",
    answer: ["Оператор typeof используется, в основном, для того, чтобы узнать тип примитивного значения"],
    isParagraph: true,
  },
  {
    heading: "В чём различие между переменными, значение которых: null, undefined и не объявлено?",
    answer: [
      "Прежде всего, это разные типы данных.",
      " - null означает, что значение есть и оно равно null - «значение отсутствия значения». null — это значение, которое присваивается переменной явно.",
      " - undefined - это переменная, которая не определена. Была объявлена, но не было присвоено значение. У нее нет значения.",
      " - undeclared - переменная, объявленная без ключевого слова 'var'.",
      "Для проверки можно использовать console.log() и typeof.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между NULL и undefined?",
    answer: [
      "1. null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно.",
      "2. undefined («неопределенный») представляет собой значение по умолчанию:",
      " - для переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;",
      " - для функции, которая ничего не возвращает явно, например, console.log(1);",
      " - для несуществующего свойства объекта.",
      "В указанных случаях движок JS присваивает значение undefined. ",
      "При сравнении null и undefined мы получаем true, когда используем оператор '==', и false при использовании оператора '==='. О том, почему так происходит, см. ниже. ",
      " - console.log(null == undefined) // true",
      " - console.log(null === undefined) // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие значения в JavaScript являются ложными (falsy)?",
    answer: [
      "const falsyValues = ['', 0, null, undefined, NaN, false] ",
      "Ложными являются те значения, которые в результате преобразования типа в логическое значение, являются false.",
      "Это требуется (например, в условных конструкциях и циклах).",
      " - пустая строка (пустые кавычки: двойные, одинарные, косые),  ",
      " - нули (положительный, отрицательный, BigInt) ",
      " - null — отсутствие какого-либо значения.",
      " - undefined — примитивное значение, переменная, не имеющая присвоенного значения.",
      " - NaN - (en-US) NaN — значение, не являющиеся числом.",
    ],
    isParagraph: true,
  },
  {
    heading: "Основное различие между циклом forEach и циклом .map()? И в каких случаях каждый из них используется?",
    answer: ["forEach перебирает массив и изменяет его.", ".map() создает копию массива и изменяет копию."],
    isParagraph: true,
  },
  {
    heading: "Назовите различные циклы в JavaScript",
    answer: [
      "1. for() - для перебора элементов массива по цифровым индексам.",
      "2. Цикл for..of не предоставляет доступа к индексу текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.",
      "3. for/in- перебирает свойства объекта",
      "4. while- перебирает блок кода, пока заданное условие истинно",
      "5. do/while- также перебирает блок кода, пока заданное условие выполняется",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает оператор «break»?",
    answer: [
      "Оператор break выводит из цикла и продолжает выполнение кода вне цикла.",
      "for (var i = 0; i < 100; i++) {  ",
      " if (i === 5)  ",
      " { break; } ",
      " console.log('Number is ', i); } console.log('Yay');",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает оператор continue?",
    answer: [
      "Оператор continue перескакивает через один раунд цикла.",
      "for (var i = 0; i < 5; i++) { ",
      " if (i === 2 || i === 3) ",
      " { continue; } ",
      " console.log('Number is ', i); }",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое анонимная функция?",
    answer: [
      "Анонимная функция — это функция, не имеющая имени. Анонимные функции часто используются для выполнения какого-то кода в коллбэках, где не нужно создавать отдельную именную функцию под это действие.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между host-объектами и нативными объектами?",
    answer: [
      "Нативные объекты - это основные стандартные объекты, всегда доступные в JavaScript.",
      "Хост-объекты - это объекты, которые предоставляет хост-среда (браузер, Node...).",
      "Большинство объектов хоста являются нативными объектами, и всякий раз, когда вы создаете экземпляр чего-либо с помощью new, вы можете быть на 99,99% уверены, что это собственный объект, если только вы не возитесь со странными объектами хоста.",
      "ПРИМЕЧАНИЕ. Любой объект, который не является нативным, является хост-объектом.",
      "",
      "Нативные объекты: Object (конструктор), Date, Math, строковые методы, методы массивов и т.д. - основные стандартные объекты, всегда доступные в JavaScript.",
      "Объекты хоста (предполагается, что среда браузера): window, document, location, history, XMLHttpRequest, setTimeout, getElementsByTagName, querySelectorAll и т.д.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?",
    answer: [
      "function Person(){} - Мы создаем функцию с именем Person.",
      "var person = Person() - Мы вызываем функцию Person и результат сохраняем в переменную person.",
      "var person = new Person() - Мы создаем новый объект, используя функцию-конструктор Person.",
    ],
    isParagraph: true,
  },
  {
    heading: "Оператор new",
    answer: [
      "Оператор new используется для создания объектов.",
      "--",
      "Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).",
      "Допустим, у нас есть такой код:",
      "function Employee(name, position, yearHired){",
      " - this.name = name",
      " - this.position = position",
      " - this.yearHired = yearHired",
      "}",
      "const emp = new Employee('Marko Polo', 'Software Development', 2017)",
      "Ключевое слово «new» делает 4 вещи:",
      "1. Создает пустой объект.",
      "2. Привязывает к нему значение this.",
      "3. Функция наследует от functionName.prototype.",
      "4. Возвращает значение this, если не указано иное.",
      "Оператор new используется для создания объектов. Операндом этого оператора должна быть функция. Функция, которая создаётся специально для работы с оператором new, называется конструктором. Конструктор используется для инициализации нового созданного объекта:",
      "Работает это всё (оператор new с конструктором) следующим образом: встречая оператор new интерпретатор создаёт новый пустой объект, затем он вызывает конструктор, и передаёт ему новый созданный объект в качестве значения ключевого слова this. Внутри конструктора происходит инициализация свойств вновь созданного объекта. После того, как объект создан и инициализарован, оператор new возвращает созданный объект. Создаём новый экземпляр какого-то класса. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое колбэк-функция?",
    answer: [
      "Callback - это ответ на событие: 'Сделай то, когда произойдёт это...' ",
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие».",
      " Коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершит работу.",
      " Функция обратного вызова — это функция, которая передается в качестве аргумента другой функции.",
      " Коллбэки нужны по одной очень важной причине: JavaScript — это язык, в котором огромную роль играют события. Это означает, что вместо того, чтобы ожидать, скажем, результата выполнения некоей функции, остановив при этом все остальные операции, JavaScript-программа работает, наблюдая за событиями и реагируя на них.",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните разницу между «==» и «===».",
    answer: [
      "«==» используется для сравнения двух значений независимо от типа данных переменной. (сравнивает значения)",
      "«===» используется для сравнения двух значений, но это будет строгая проверка, поэтому будет проверяться соответствие значения и типа данных. (сравнивает как значение, так и тип)",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли значение не числом?",
    answer: [
      "Функция isNaN() определяет, является ли значение не числом.",
      " isNaN(48) //false ",
      " isNaN('123') //false ",
      " isNaN('Привет, я настоящая строка') //true ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как преобразовать строку в число?",
    answer: [
      "parseInt() преобразует строку в целое число: ",
      " parseInt('30', 10) // 30 ",
      " parseInt('55px', 10) // 50  ",
      " parseInt(2.55, 10) // 2",
      " - ",
      " parseFloat()  преобразует строку в число точек (с десятичным числом)",
      " parseFloat('30') // 30 ",
      " parseFloat('55px') // 50 ",
      " Number() преобразует строку в число. Это может быть целое число или десятичное число. Они часто могут быть менее безопасными, чем использование parseInt или parseFloat",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли объект массивом?",
    answer: ["Функция isArray() определяет, является ли объект массивом.", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое параметры функции по умолчанию.",
    answer: [
      "Параметр по умолчанию - это установленное определённое значение для параметра функции, значение которого может не определиться по ходу выполнения кода. Если значение параметра не передано в функцию (неопределилось по ходу выполнения кода), то его значение становится неопределенным. В этом случае компилятор применяет значение по умолчанию, которое мы задаем. ",
      "// b = 1 - устанавливаем значение параметра функции по умолчанию ",
      "function multiply ( a, b = 1 ) { ",
      "return a * b;",
      "}",
      "--",
      "Здесь в качестве значения параметра b передаётся число 2",
      "console.log(multiply ( 5, 2 )); // 10",
      "--",
      "// параметр b не определён, поэтому передаётся значение 1, установленный по умолчанию",
      "console.log(multiply ( 5 )); // 5.   ",

      "Они позволяют инициализировать именованные параметры со значениями по умолчанию, если значение не передается или undefined не передается.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое модули ES6?",
    answer: [
      "Модуль – это просто файл. Один скрипт – это один модуль.",
      "Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. ",
      "Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:",
      "Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта. ",
      " - import позволяет импортировать функциональность из других модулей.",
      " - export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.",
      " - export default (по умолчанию) используется, когда модулю нужно экспортировать только одно значение.",
      "Именованные экспорты отличаются своими именами. В модуле может быть несколько именованных экспортов.",
      "Модуль может содержать переменные и функции. Модуль — это не что иное, как фрагмент кода JavaScript, записанный в файле.",
      " - Своя область видимости переменных",
      "Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое async/await?",
    answer: [
      "async перед функцией означает одну простую вещь: функция всегда возвращает промис (обещание). Другие значения автоматически оборачиваются в разрешенное обещание.",
      "await заставляет JavaScript ждать, пока этот промис не выполнится, и после этого возвращает результат.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы делаете вызов API в JavaScript?",
    answer: [
      "1. XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы. ",
      "2. Метод fetch() - современный и очень мощный способ для выполнения сетевых запросов и получения информации с сервера. ",
      "3. Axios — это простой HTTP-клиент на основе промисов для браузера и node.js",
      "4. jQuery — набор функций JavaScript, фокусирующийся на взаимодействии JavaScript и HTML. Библиотека jQuery помогает легко получать доступ к любому элементу DOM, обращаться к атрибутам и содержимому элементов DOM, манипулировать ими. Также библиотека jQuery предоставляет удобный API для работы с AJAX.  ",
    ],
    isParagraph: true,
  },
  {
    heading: " Назовите методы запросов API, которые вы бы использовали в JavaScript.",
    answer: ["GET", "POST", "PUT", "DELETE", "PATCH"],
    isParagraph: true,
  },
  {
    heading: "Назовите различные селекторы DOM",
    answer: [
      " - getElementsByTagName()",
      " - getElementsByClassName()",
      " - getElementById()",
      " - querySelector()",
      " - querySelectorAll()",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие типы всплывающих окон есть в JavaScript?",
    answer: [
      "В JavaScript есть три типа всплывающих окон: окно предупреждения, окно подтверждения и окно запроса.",
      "Alert - окно предупреждения.",
      "Confirm - окно подтверждения.",
      "Prompt - окно запроса.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое оператор расширения в JavaScript?",
    answer: [
      "Оператор Spread позволяет расширять итерируемые объекты (массивы/объекты/строки) до отдельных аргументов/элементов.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функции высшего порядка в JavaScript?",
    answer: [
      "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.",
      "Функция более высокого порядка воздействует на другую функцию. Она либо принимает функцию в качестве аргумента, либо возвращает другую функцию.",
      "function higherOrderFunction(param, callback) {",
      " return callback(param)",
      "}",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Строгий режим в JavaScript?",
    answer: [
      "Строгий режим позволяет настроить программу для работы в строгом контексте. Это предотвращает выполнение определенных действий. Кроме того, возникает больше исключений.",
      "Выражение 'use strict' указывает браузеру включить строгий режим.",
      "Например: строгий режим не позволяет вам присвоить значение необъявленной переменной.",
    ],
    isParagraph: true,
  },
  {
    heading: "Зачем использовать строгий режим в JavaScript? (директива «use strict»)",
    answer: [
      "Строгий режим помогает писать «безопасный» код JavaScript. Это означает, что плохие синтаксические практики превращаются в настоящие ошибки. Например, строгий режим запрещает создание глобальных переменных. ",
      "Вот какие ограничения накладывает строгий режим:",
      "Нельзя присваивать значения или обращаться к необъявленным переменным.",
      "Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи.",
      "Нельзя удалить «неудаляемое» свойство объекта.",
      "Запрещено дублирование параметров.",
      "Нельзя создавать функции с помощью функции eval.",
      "Значением «this» по умолчанию является undefined.",
      "… и т.д.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое немедленно вызываемая функция? (IIFE)",
    answer: [
      "Немедленно вызываемая функция (IIFE) запускается сразу после определения.",
      "(function() { ... action here })()",
      "Чтобы понять, как работает IIFE, посмотрите на круглые скобки вокруг него:",
      " - Когда JavaScript видит ключевое слово function, он предполагает, что идет объявление функции.",
      " - Но объявление выше неверно, потому что у функции нет имени.",
      " - Чтобы исправить это, используется первый набор скобок вокруг объявления. Это сообщает интерпретатору, что это выражение функции, а не объявление.",
      "Затем, чтобы вызвать функцию, необходимо добавить еще один набор скобок в конце объявления функции. Это похоже на вызов любой другой функции",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функция IIFE? Самовызывающая функция.",
    answer: [
      "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})(). ",
      "(function( ) { }( )) ",
      "(function( ) { })( ) ",
      "(function named(params) { })( ) ",
      "(( ) => { }) ",
      "(function(global) { })(window) ",
      "const utility = (function( ) { return { // утилиты } })",
      "----------------- ",
      "Все эти примеры являются валидными. Предпоследний пример показывает, что мы можем передавать параметры в IIFE. Последний пример показывает, что мы можем сохранить результат IIFE в переменной. ",
      "Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает двойной восклицательный знак?",
    answer: [
      " Двойной восклицательный знак преобразует любое значение в логическое значение в JavaScript.",
      "!!true // true",
      "!!2 // true ",
      "!![] // true",
      "!!'Test' // true",
      "!!false // false",
      "!!0 // false",
      "!! '' // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Как можно удалить свойство и его значение из объекта?",
    answer: [
      "Вы можете использовать ключевое слово delete для удаления свойства и его значения из объекта.",
      "let student = {name: 'John', age: 20};",
      "delete student.age;",
      "console.log(student) // {name: 'John'};",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое глобальная переменная?",
    answer: ["Глобальная переменная доступна везде в коде."],
    isParagraph: true,
  },
  {
    heading: "Что такое события JavaScript?",
    answer: [
      "События — это то, что происходит с элементами HTML. Когда JavaScript используется на HTML-странице, он может реагировать на события, такие как нажатие кнопки.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает метод preventDefault()?",
    answer: [
      "Название preventDefault 'предотвратить дефолт' хорошо описывает поведение. Это предотвращает поведение события по умолчанию.",
      "Например, вы можете запретить отправку формы при нажатии кнопки отправки:",
      " const handleForm = (event) => {",
      " event.preventDefault()",
      " });",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое метод setTimeout()?",
    answer: [
      "Метод setTimeout() вызывает функцию (один раз) через указанное количество миллисекунд. Например, давайте зарегистрируем сообщение через одну секунду ( 1000ms ):",
      "setTimeout(function() { ",
      " console.log('Good day');",
      " }, 1000);",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое метод setInterval()?",
    answer: [
      "Метод setInterval() периодически вызывает функцию с заданным интервалом.",
      "Например, давайте периодически логировать сообщение каждую секунду:",
      " setInterval(function() {",
      " console.log('Добрый день');",
      " }, 1000);",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое ECMAScript?",
    answer: [
      "ECMAScript — это язык сценариев, лежащий в основе JavaScript. ECMAScript стандартизирован Международной организацией по стандартизации ECMA.",
      "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как можно присвоить переменной значение по умолчанию?",
    answer: [
      "Используйте логический оператор || в назначении, чтобы указать значение по умолчанию:",
      "const a = b || c;",
      "Это работает так: если b ложно, то значение c будет присвоено значению a.",
      "(Falsy означает: null, false, undefined, 0, пустую строку, NaN.)",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функция eval()?",
    answer: [
      "Не используйте eval без необходимости!",
      "Warning: Выполнение кода JavaScript с текстовой строки - это невероятный риск для безопасности. Злоумышленнику слишком легко запустить какой угодно код, когда вы используете eval(). Смотрите Никогда не используйте eval()!, ниже.",
      "eval() - функция глобального объекта, оценивает код внутри строки. Возвращает значение выполнения кода, переданного в функцию в виде строки. Если код не возвращает ничего - будет возвращено значение undefined.",
      "Аргумент функции eval() - строка. Строка для оценки может быть выражением, переменной, оператором или последовательностью операторов. eval() исполняет содержащееся в строке выражение, один или несколько операторов JavaScript. Не стоит вызывать eval() для определения значения арифметического выражения; JavaScript вычисляет их автоматически.",
      "eval() можно использовать для вычисления значения арифметического выражения, записанного в строковом виде, на более поздней стадии исполнения. Предположим, существует переменная x. Можно отложить вычисление выражения, в котором содержится х, если присвоить переменной это выражение в виде строки (допустим, '3 * x + 2'), а затем вызвать eval() в более поздней точке кода.",
      "Если аргумент, переданный eval(), не является строкой, eval() возвращает его неизменным. В следующем примере определён конструктор String, и eval() не вычисляет значение выражения, записанного в строковом виде, а возвращает объект типа String.",
      " console.log(eval('2 + 2')); // 4",
      " console.log(eval(new String('2 + 2'))); // 2 + 2",
      " console.log(eval('2 + 2') === eval('4')); // true",
      " console.log(eval('2 + 2') === eval(new String('2 + 2'))); // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое регулярное выражение?",
    answer: [
      "Регулярное выражение представляет собой группу символов, образующих шаблон поиска. Это инструмент сопоставления с образцом, который обычно используется в JavaScript и других языках программирования.",
      "Регулярное выражение можно использовать для поиска адресов электронной почты или телефонных номеров в большом текстовом файле.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое условный оператор?",
    answer: [
      "Условный оператор — это сокращение для написания операторов if-else. Условный оператор иногда называют тернарным оператором.",
      "{age < 18 ? console.log('Незначительный' : console.log('Взрослый') }",
      " Условные операторы можно связать в цепочку. Иногда это может быть полезно, так как делает код более понятным.",
      " function example() {",
      " return condition1 ? value1",
      " : condition2 ? value2",
      " : condition3 ? value3",
      " : value4;",
      " }",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает метод Object.freeze()?",
    answer: [
      "Метод Object.freeze() замораживает объект, делает его неизменным. Замороженный объект больше нельзя изменить; замораживание объекта предотвращает добавление к нему новых свойств, удаление существующих свойств, предотвращает изменение перечислимости, конфигурируемости или возможности записи существующих свойств, а также предотвращает изменение значений существующих свойств. Кроме того, замораживание объекта также предотвращает изменение его прототипа. freeze() возвращает тот же объект, который был передан.",
      "const obj = { prop: 42 };",
      "Object.freeze(obj);",
      "obj.prop = 33; // Выдает ошибку в строгом режиме",
      "console.log(obj.prop); // результат: 42",
    ],
    isParagraph: true,
  },
  {
    heading: "Как получить список ключей объекта?",
    answer: [
      "Используйте Object.keys()метод.",
      "const student = { name: 'Mike', gender: 'male', age: 23 };",
      "console.log(Object.keys(student)); // ['name', 'gender', 'age']",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие примитивные типы данных есть в JavaScript?",
    answer: [
      "Примитивный тип данных имеет примитивное значение. В JavaScript существует семь различных примитивных типов данных:",
      "1. string— строковые значения. Например “John”.",
      "2. number— числовые значения. Например 12.",
      "3. boolean- правда или ложь. Например true.",
      "4. null- отсутствие значения. Например let x = null;",
      "5. undefined— тип, в котором переменная объявлена, но не имеет значения. Например, при создании переменной x таким let x;образом x становится undefined.",
      "6. bigint— Объект, предназначенный для представления целых чисел, превышающих 2^53–1. НапримерBigInt(121031393454720292)",
      "7. symbol— Встроенный объект для создания уникальных символов. Например let sym1 = Symbol(‘test’)",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие существуют способы доступа к свойствам объекта?",
    answer: [
      "Точечное обозначение: obj.property",
      "Обозначение квадратных скобок: obj['property']",
      "Обозначение выражения: obj[expression]",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: [
      "Согласно MDN оператор ' + '  действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое DOM?",
    answer: [
      "Это граф, который описывает структуру HTML документов, соотношение элементов, их вложенность друг в друга.",
      "DOM - дерево позволяет манипулировать элементами через javascript.",
      "------------------------------------------- ",
      "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. ",
      "Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. ",
      "DOM представляет собой древовидную структуру (дерево документа). ",
      "DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между методами event.preventDefault() и event.stopPropagation()? ",
    answer: [
      "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.).",
      "Метод event.stopPropagation() отключает распространение события (его всплытие или погружение). ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как узнать об использовании метода event.preventDefault()?",
    answer: [
      "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое текущая цель события (event.currentTarget)?",
    answer: ["Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий. ", " "],
    isParagraph: true,
  },
  {
    heading: "Почему результатом сравнения двух похожих объектов является false? ",
    answer: [
      "В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как записать несколько выражений в одну строку?",
    answer: [
      "Для этого мы можем использовать оператор ', ' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда. ",
      "let x = 5",
      "x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10) ",
      "function addFive(num) { return num + 5 }",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие значения в JS являются ложными?",
    answer: ["Ложными являются значения, результатом преобразования которых в логическое значение является false."],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли значение ложным? ",
    answer: ["Следует использовать функцию Boolean или оператор '!!' (двойное отрицание)"],
    isParagraph: true,
  },
  {
    heading: "Что такое прототип объекта в JavaScript?",
    answer: [
      "В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. ",
      "const o = {} ",
      "console.log(o.toString()) // [object Object] ",
      "Несмотря на то, что объект «о» не имеет свойства toString, обращение к этому свойству не вызывает ошибки. Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype. ",
      "console.log(o.toString === Object.prototype.toString) // true ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое прототип объекта в JavaScript?",
    answer: [
      "Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__ ",
      "Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-. ",
      "К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype. ",
      "При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора. ",
      "Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    answer: [
      "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются. ",
      "Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования. ",
      "Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива: ",
      "Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback: ",
      "Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив: ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: [
      "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объект arguments?",
    answer: [
      "Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. ",
      "Запомните: в стрелочных функциях объект arguments не работает. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как создать объект, не имеющий прототипа?",
    answer: [
      "Это можно сделать с помощью Object.create: ",
      "const o1 = {} ",
      "console.log(o1.toString) // [object Object] ",
      "const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип ",
      "// нам не нужен объект-прототип, поэтому передаем null ",
      "console.log(o2.toString) // o2.toString is not a function ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему в представленном коде переменная b становится глобальной при вызове функции?",
    answer: [
      "function myFunc(){ let a = (b = 0)}",
      "myFunc() ",
      "Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a». ",
      "Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения: ",
      "function myFunc(){ ",
      " - let a, b",
      " - a = b = 0",
      "} ",
      "myFunc() ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое стрелочные функции (Arrow Functions)?",
    answer: [
      "Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:",
      "const doSomething = (foo) => { ",
      " // сделать что-нибудь",
      "} ",
      "Стрелочные функции (arrow function) особенно удобно использовать в виде так называемых «встроенных функций» (inline function) — в роли аргументов, передаваемых другим функциям (коллбэков). ",
      "В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение: ",
      "Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки: ",
    ],
    isParagraph: true,
  },
  {
    heading: " Что такое классы (Classes)?",
    answer: [
      "Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое шаблонные литералы (Template Literals)?",
    answer: [
      "Литерал шаблонов в ES6 предоставляет новые возможности для создания строки, которая дает больше контроля над динамическими строками. Традиционно строка создается с использованием одинарных кавычек (‘) или двойных кавычек (“). Шаблонные литералы создаются с помощью двойных обратных кавычек (``):  ",
      "Синтаксис: let string = `some string` ",
      "Многострочные строки: для создания многострочной строки была использована escape-последовательность \n для обозначения символа новой строки. Однако в литералах шаблонов нет необходимости добавлять \n строка заканчивается только тогда, когда она получает символ обратной метки (`). ",
      "Выражения: Для динамического добавления значений в новые литералы шаблонов используются выражения. Синтаксис ${} допускает в нем выражение, которое выдает значение. Это значение может быть строкой, хранящейся в переменной, или вычислительной операцией. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объект Set? ",
    answer: [
      "Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue. ",
      "Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании: ",
      "const set1 = new Set() ",
      "const set2 = new Set(['a','b','c','d','d','e']) // вторая 'd' не добавится ",
      "Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может использовать цепочку вызовов: ",
      "set2.add('f') ",
      "set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая 'k' не добавится ",
      "Мы можем удалять значения из Set, используя метод delete: ",
      "set2.delete('k') // true ",
      "set2.delete('z') // false, потому что в set2 нет такого значения ",
      "Мы можем проверить наличие свойства в Set, используя метод has:",
      "set2.has('a') // true ",
      "set2.has('z') // false ",
      "Для получения длины Set используется метод size: ",
      "set2.size // 10 ",
      "Метод clear очищает Set: ",
      "set2.clear() // пусто ",
      "------------------------- ",
      "Мы можем использовать Set для удаления повторяющихся значений в массиве: ",
      "const nums = [1,2,3,4,5,6,6,7,8,8,5] ",
      "const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8] ",
    ],
    isParagraph: true,
  },
  {
    heading: "чем отличаются операторы spread и rest в JavaScript",
    answer: [
      "SPREAD (…) ",
      "Дававйте разберем вариант использования spread-оператора. Для этого достаточно представить, что массив - это контейнер.",
      "spread-оператор позволяет извлечь содержимое контейнера, не прикасаясь к нему. Кроме того, Вы сможете переместить полученное содержимое туда, куда Вам нужно. ",
      "Посмотрим на код, приведенный ниже: ",
      "const animals = [🦁, 🐘, 🐍, 🦍, 🐯] ",
      "const someOtherAnimals = [...animals]; ",
      "// someOtherAnimals теперь содержит элементы 🦁, 🐘, 🐍, 🦍, 🐯 and ",
      "// animals остается неизменным ",
      "Итак, с помощью spread-оператора мы извлекли элементы массива animals и перенесли их в массив someOtherAnimals. ",
      "акже spread-оператор можно применять для сбора данных нескольких массивов в один массив: ",
      "const wild = [🦁, 🐘, 🐍, 🦍, 🐯]; ",
      "const domestic = [🐐, 🐔, 🐱, 🐶]; ",
      "const animals = [...wild, ...domestic]; ",
      "// animals теперь содержит 🦁, 🐘, 🐍, 🦍, 🐯, 🐐, 🐔, 🐱, 🐶 ",
      "// , а wild и domestic остаются неизменными. ",
      "-------------------------------------------------",
      "REST (…) ",
      "rest-оператор позволяет представить неопределенное количество аргументов в виде массива. В отличии от spread-оператора, который извлекает элементы массива, rest-оператор (или, как его еще называют: оператор сбора) группирует множество элементов в один массив. ",
      "Посмотрим, как это работает: ",
      "const addAll = (...numbers) => { ",
      " - return numbers.reduce((acc, num) => acc + num);",
      "}; ",
      "const sum = addAll(1, 2, 3, 4); // сумма 10 ",
      "const sum1 = addAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // сумма 55 ",
      "Таким образом, мы в любом количестве собираем аргументы для параметра numbers функции addAll, после чего функция возвращает сумму этих аргументов. Этот подход позволяет нам манипулировать данными параметра numbers как обычным массивом. ",
      "Еще один пример использования rest-оператора приведен ниже: ",
      "const multiplyByNum = (multiplier, ...numbers) => { ",
      " - return numbers.map(num => num * multiplier);",
      "}; ",
      "const multiplyBy2 = multiplyByNum(2, 1, 2, 3, 4); ",
      "// multiplyBy2 [2, 4, 6, 8] ",
      "В этом случае первым параметром функции multiplyByNum является аргумент multiplier, который выступает в качестве множителя для любого количества аргументов параметра numbers. Функция возвращает массив, каждый элемент которого умножен на multiplier ",
      "-------------------------------------------------",
      "ИТОГИ ",
      "1. spread-оператор извлекает элементы массива, ",
      "2. rest-оператор собирает элементы (например, аргументы функции) в массив.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое параметры по умолчанию (Default Parameters)?",
    answer: [
      "Параметр по умолчанию-это способ установить значения по умолчанию для параметров функции, значение которых не передается (т.е.оно не определено).Если в функции параметр не передан, то его значение становится неопределенным.В этом случае компилятор применяет значение по умолчанию, которое мы задаем.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объектная обертка (Wrapper Objects)?",
    answer: [
      "Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами: ",
      "let name = 'marko' ",
      "console.log(typeof name) // string ",
      "console.log(name.toUpperCase()) // MARKO ",
      "Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(), это приводит не к ошибке, а к «MARKO». ",
      "Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В нашем случае код принимает следующий вид: ",
      "console.log(new String(name).toUpperCase()) // MARKO",
      "Временный объект отбрасывается по завершении работы со свойством или методом.",
    ],
    isParagraph: true,
  },
  {
    heading: "Преобразование типов",
    answer: [
      "Неявное преобразование.",
      "Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия). Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу. Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.",
      "Явное преобразование. ",
      "Явное преобразование предполагает наше участие в приведении значения к другому типу.",
      "Строковое преобразование.",
      "Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. ",
      "let value = true; ",
      "alert(typeof value); // boolean ",
      "value = String(value); // преобразование в строку ",
      "alert(typeof value); // string ",
      "Численное преобразование.",
      "Численное преобразование происходит в математических функциях и выражениях.",
      "Например, когда операция деления / применяется не к числу: ",
      "alert( '6' / '2' ) // 3, строки преобразуются в числа ",
      "Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу: ",
      "let str = '123' ",
      "alert(typeof str); // string ",
      "let num = Number(str); // Численное преобразование, строка становится числом 123 ",
      "alert(typeof num); // number ",
      "Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм. Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. ",
      "let age = Number('Любая строка вместо числа'); ",
      "alert(age); // NaN, преобразование не удалось ",
      "Логическое преобразование",
      "Логическое преобразование самое простое. Происходит в логических операциях, но также может быть выполнено явно с помощью функции Boolean(value).",
      "alert( Boolean(1) ); // true ",
      "alert( Boolean(0) ); // false ",
      "alert( Boolean('Привет!') ); // true ",
      "alert( Boolean('') ); // false ",
      "Заметим, что строчка с нулём '0' — это true ",
      "alert( Boolean('0') ); // true ",
      "alert( Boolean(' ') ); // пробел это тоже true (любая непустая строка это true) ",
    ],
    isParagraph: true,
  },
  {
    heading: "Правила численного преобразования:",
    answer: [
      "Значение	Преобразуется в…  => ",
      "undefined =>	NaN ",
      "null =>	0 ",
      "true =>	1 ",
      "false => 0 ",
      "string =>	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Правило логического преобразования: ",
    answer: [
      "Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false. ",
      "Все остальные значения становятся true. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое NaN?",
    answer: [
      "NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением ",
      "console.log(parseInt('abc')) ",
      "console.log(parseInt(null)) ",
      "console.log(parseInt(undefined)) ",
      "console.log(parseInt(++a)) ",
      "console.log(parseInt({} * 10)) ",
      "console.log(parseInt('abc' - 2)) ",
      "console.log(parseInt(0 / 0)) ",
      "console.log(parseInt('10a' * 10)) ",
    ],
    isParagraph: true,
  },
  {
    heading: " Как проверить, является ли значение NaN?",
    answer: [
      "В JS есть встроенный метод isNaN, позволяющий проверять, является ли значение NaN, но он ведет себя довольно странно: ",
      "console.log(isNaN()) // true // неверно - false",
      "console.log(isNaN(undefined)) // true // неверно - false ",
      "console.log(isNaN({})) // true // неверно - false ",
      "console.log(isNaN(String('a'))) // true // неверно - false ",
      "console.log(isNaN(() => { })) // true // неверно - false ",
      "Результатом всех console.log является true, несмотря на то, что ни одно из значений не является NaN. ",
      "ES6 для проверки, является ли значение NaN, рекомендует использовать метод Number.isNaN. Мы также можем написать вспомогательную функцию для решения проблемы «неравенства NaN самому себе»: ",
      "function checkIsNan(value){ return value !== value } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как определить наличие свойства в объекте?",
    answer: [
      "Существует три способа это сделать. ",
      "1. Первый способ состоит в использовании оператора «in»: ",
      "const o = { 'prop': 'bwahahah', 'prop2': 'hweasa' } ",
      "console.log('prop' in o) // true ",
      "console.log('prop1' in o) // false ",
      "2. Второй — использовать метод hasOwnProperty:",
      "console.log(o.hasOwnProperty('prop2')) // true ",
      "console.log(o.hasOwnProperty('prop1')) // false ",
      "3. Третий — индексная нотация массива:",
      "console.log(o['prop']) // bwahahah ",
      "console.log(o['prop1']) // undefined ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое AJAX?",
    answer: [
      "AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы. ",
      "AJAX использует следующие технологии: ",
      " - HTML — структура веб-страницы.",
      " - CSS — стили веб-страницы.",
      " - JavaScript — поведение страницы и работа с DOM.",
      " - XMLHttpRequest API — отправка и получение данных с сервера.",
      " - PHP, Python, Nodejs — какой-нибудь серверный язык.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как в JS создать объект?",
    answer: [
      "1. Объектный литерал:",
      "const o = { name: 'Mark', age: 35 }",
      "2. Функция-конструктор:",
      "3. Метод Object.create:",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    answer: ["1. Функции обратного вызова (Callbacks)", "2. Промисы (Promises).", "3. Async/await."],
    isParagraph: true,
  },
  {
    heading: "В чем разница между обычной функцией и функциональным выражением? ",
    answer: [
      "Единственное отличие между ними только в том, что у функционального выражения может отсутствовать имя. Т.е. сразу после ключевого слова function идут круглые скобки, а в них параметры. Функциональные выражения без имени называются анонимными функциями. function funcDeclaration() {return 'Обычное объявление функции';}",
    ],
    isParagraph: true,
  },
  {
    heading: "Как в JS вызвать функцию?",
    answer: [
      "В JS существует 4 способа вызвать функцию.",
      "1. Вызов в качестве функции.",
      "Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window: ",
      "2. Вызов в качестве метода.",
      "Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода ",
      "3. Вызов в качестве конструктора.",
      "Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this. ",
      "4. Вызов с помощью методов apply или call.",
      " Мы используем эти методы, когда хотим явно определить значение this или владельца функции. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое запоминание или мемоизация (Memoization)? ",
    answer: [
      "Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему typeof null возвращает object? Как проверить, является ли значение null? ",
    answer: [
      "typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок) ",
      "Для проверки, является ли значение null можно использовать оператор строгого равенства (===): ",
      "function isNull(value){ return value === null } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Синхронное действие (Синхронная функция) ",
    answer: [
      "Синхронное действие — это действие, которое отправляется и немедленно обрабатывается в потоке. Обновляется состояние, и обновленное состояние немедленно становится доступным для использования компонентами. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронное действие (асинхронная функция) ",
    answer: [
      "С другой стороны, асинхронное действие — это действие, которое отправляется, но для его завершения требуется некоторое время. Асинхронные действия обычно используются при выполнении сетевых запросов или выполнении других операций, требующих времени. Эти действия не могут быть немедленно обработаны в потоке, поэтому для их выполнения требуется дополнительная логика. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Парсинг, это автоматизированный сбор и систематизация данных.",
    answer: [
      "Парсинг — автоматизированный сбор и систематизация данных. Его проводят с помощью программ, которые называются парсерами. Парсинг нужен, чтобы ускорить рутинную работу. ",
      "Парсить можно что угодно — цены конкурентов, поисковые фразы, аккаунты в соцсетях, битые ссылки. ",
      "Закон не запрещает парсинг. Но его нельзя использовать для преступлений: чтобы распространять личные данные людей, спамить, перегружать сервер сайта. ",
      "Чтобы парсить данные, можно создать парсер с нуля или использовать готовые решения. Последних много — важно найти подходящее для ваших задач. ",
      "Что такое парсинг простыми словами? Парсинг – это метод индексирования информации с последующей конвертацией ее в иной формат или даже иной тип данных. Парсинг позволяет взять файл в одном формате и преобразовать его данные в более удобоваримую форму, которую можно использовать в своих целях.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что означает компиляятор и компиляция в программировании? ",
    answer: [
      "Компиля́тор — программа, переводящая, написанный на языке программирования, текст в набор машинных кодов. ",
      "Компиля́ция — сборка программы, включающая: трансляцию всех модулей программы, написанных на одном или нескольких исходных языках программирования высокого уровня и/или языке ассемблера, в эквивалентные программные модули на низкоуровневом языке, близком машинному коду (абсолютный код, объектный модуль, иногда на язык ассемблера)... ",
      "Компиляция: это когда код, написанный на языке программирования, «переводят» в машинные команды целиком.",
    ],
    isParagraph: true,
  },
  {
    heading: "Интерпретатор (interpreter), интерпретаация ",
    answer: [
      "Интерпретатор (interpreter) — это программа, которая выполняет код, написанный на языке программирования. Она не переводит его в машинные коды целиком, а построчно принимает команды и сразу выполняет их. Можно отдать интерпретатору команду и сразу понять, сработала ли она. Это один из двух способов перевода кода в понятный компьютеру вид. Второй вариант — компиляция, когда код «переводят» в машинные команды целиком. ",
      "Интерпрета́тор — программа (разновидность транслятора), выполняющая интерпретацию. ",
      "Интерпрета́ция — построчный анализ, обработка и выполнение исходного кода программы или запроса, в отличие от компиляции, где весь текст программы, перед запуском анализируется и транслируется в машинный или байт-код без её выполнения. Первым интерпретированным языком программирования высокого уровня был Lisp.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Способы перевода кода в понятный компьютеру вид. Интерпретация, компиляция. ",
    answer: [
      "1. Интерпретация — это когда код, написанный на языке программирования, проходит построчный анализ, построчную обработку, построчно принимает команды и сразу выполняет их. ",
      "2. Компиляция: это когда код, написанный на языке программирования, «переводят» в машинные команды целиком.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое цикл событий (event loop) и как он работает?",
    answer: [
      "Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций. ",
      "Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop. ",
      "Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности. ",
      "Цикл событий (event loop) — ключ к асинхронному программированию на JavaScript. Сам по себе язык однопоточный, но использование этого механизма позволяет создать дополнительные потоки, чтобы код работал быстрее.  ",
      "-- ",
      "Главная задача циклов событий — следить за стеком и очередью задач. Если стек пуст, цикл берет первый элемент из очереди, помещает его в стек и выполняет. ",
      "Механизм работы цикла событий: он ждет очистки стека и когда это происходит, помещает очередной колбек в стек. Затем выполняются другие функции. ",
      "Установка нулевого времени в функции setTimeout приводит к тому, что она откладывает исполнение колбека и переносит его в конец стека. ",
      "Все web-API работают похожим образом. Например, AJAX-запрос на URL-адрес с обратным вызовом будет выполняться точно также. ",
      "XHR-запрос будет выполняться параллельно — он может быть не выполнен никогда, но стек при этом будет продолжать работать. ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Фрейм в программировании, что это?",
    answer: [
      "Фрейм (от англ. frame — рамка) — отдельный законченный HTML-документ, который вместе с другими HTML-документами может быть отображён в окне браузера. ",
      "Фреймы по своей сути очень похожи на ячейки таблицы, однако более универсальны. Фреймы разбивают веб-страницу на отдельные миникадры, расположенные на одном экране, которые являются независимыми друг от друга. Каждое окно может иметь собственный адрес. При нажатии на любую из ссылок, расположенных в одном фрейме, можно продолжать видеть страницы в других окнах. ",
      "Фреймы часто использовались для навигации по веб-сайту. При этом навигационная страница располагается в одном окне, а страницы с текстом — в другом. ",
      "В настоящее время использование фреймов для публичных сайтов не рекомендовано. Главным образом это связано с принципом работы поисковых машин, которые приводят пользователя к HTML-документу, являющемуся, согласно задумке, лишь одним из фреймов того, что автору сайта хотелось бы представить. Данный недостаток фреймов устраняется средствами JavaScript.[1] ",
      "Фрейм стека-это упакованная информация, связанная с вызовом функции. Эта информация обычно включает аргументы, передаваемые функции, локальные переменные и место возврата при завершении. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Стэк - область памяти.",
    answer: [
      "Стэк - область памяти, выделенная для выполнения JavaScript движком браузера в одном потоке. ",
      "Стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает ключевое слово this?",
    answer: [
      "В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме. ",
      "В пределах функции значение this зависит от того, каким образом вызвана функция: ",
      "1. Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply",
      "2. В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.",
      "3. Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работают методы apply(), call() и bind()? ",
    answer: [
      "Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее. ",
      "Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply. ",
      " - Синтаксис метода call: func.call(context, arg1, arg2, ...) ",
      " - - При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).",
      " - Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.",
      " - - func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);",
      " - Синтаксис встроенного bind: var wrapper = func.bind(context, [arg1, arg2...])",
      " - - Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Promise (Промис)? ",
    answer: [
      "Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). ",
      "Синтаксис создания Promise:",
      "var promise = new Promise(function(resolve, reject) { ",
      " - - // Эта функция будет вызвана автоматически ",
      " - - // В ней можно делать любые асинхронные операции,",
      " - - // А когда они завершатся — нужно вызвать одно из:",
      " - - // resolve(результат) при успешном выполнении",
      " - - // reject(ошибка) при ошибке",
      "}) ",
      "-------------------------------------------------------------------------- ",
      "Универсальный метод для навешивания обработчиков: ",
      "promise.then(onFulfilled, onRejected) ",
      "1. onFulfilled – функция, которая будет вызвана с результатом при resolve.",
      "2. onRejected – функция, которая будет вызвана с ошибкой при reject.",
      "Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое. ",
      "Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»: ",
      "// Создаётся объект promise ",
      "let promise = new Promise((resolve, reject) => { ",
      " - setTimeout(() => { ",
      " - - // переведёт промис в состояние fulfilled с результатом 'result'",
      " - - resolve('result');",
      " -  }, 1000);",
      "}); ",
      "-------------------------------------------------------------------------- ",
      "// promise.then навешивает обработчики на успешный результат или ошибку",
      "promise ",
      " - .then(",
      " - - result => {",
      " - - - // первая функция-обработчик - запустится при вызове resolve",
      " - - - alert('Fulfilled: ' + result); // result - аргумент resolve",
      " - - },",
      " - - error => {",
      " - - - // вторая функция - запустится при вызове reject",
      " - - -  alert('Rejected: ' + error); // error - аргумент reject",
      " - -  }",
      " - );",
      "В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result». ",
      "-------------------------------------------------------------------------- ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое статический метод класса (static)?",
    answer: [
      "Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса. ",
      "Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Set, Map, WeakSet и WeakMap? ",
    answer: [
      "В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap. ",
      "Map – коллекция для хранения записей вида ключ: значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например: ",
      "-------------------------------------------------------------------------- ",
      "'use strict'; ",
      "let map = new Map(); ",
      "map.set('1', 'str1');   // ключ-строка ",
      "map.set(1, 'num1');     // число ",
      "map.set(true, 'bool1'); // булевое значение ",
      "-- ",
      "// в обычном объекте это было бы одно и то же, ",
      "// map сохраняет тип ключа ",
      "alert( map.get(1)   ); // 'num1' ",
      "alert( map.get('1') ); // 'str1' ",
      "alert( map.size ); // 3 ",
      "-------------------------------------------------------------------------- ",
      "Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит: ",
      "-------------------------------------------------------------------------- ",
      "'use strict'; ",
      "let set = new Set(); ",
      "let vasya = {name: 'Вася'}; ",
      "let petya = {name: 'Петя'}; ",
      "let dasha = {name: 'Даша'}; ",
      "-- ",
      "// посещения, некоторые пользователи заходят много раз ",
      "set.add(vasya); ",
      "set.add(petya); ",
      "set.add(dasha); ",
      "set.add(vasya); ",
      "set.add(petya); ",
      "// set сохраняет только уникальные значения",
      "alert( set.size ); // 3 ",
      "set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша ",
      "-------------------------------------------------------------------------- ",
      "WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например: ",
      "// текущие активные пользователи ",
      "let activeUsers = [ ",
      " - {name: 'Вася'},",
      " - {name: 'Петя'},",
      " - {name: 'Маша'}",
      "]; ",
      "-- ",
      "// вспомогательная информация о них, ",
      "// которая напрямую не входит в объект юзера, ",
      "// и потому хранится отдельно ",
      "let weakMap = new WeakMap(); ",
      "weakMap.set(activeUsers[0], 1);",
      "weakMap.set(activeUsers[1], 2); ",
      "weakMap.set(activeUsers[2], 3); ",
      "weakMap.set('Katya', 4); //Будет ошибка TypeError: 'Katya' is not a non-null object ",
      "alert( weakMap.get(activeUsers[0]) ); // 1 ",
      "activeUsers.splice(0, 1); // Вася более не активный пользователь",
      "// weakMap теперь содержит только 2 элемента ",
      "activeUsers.splice(0, 1); // Петя более не активный пользователь ",
      "// weakMap теперь содержит только 1 элемент ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Разница между фундаментальными типами данных и производными типами данных. ",
    answer: [
      "В компьютерном программировании тип данных — это классификация, которая указывает компилятору или интерпретатору, какой тип данных пользователь намеревается использовать.  ",
      "Существует два типа типов данных –  ",
      "1. Примитивный/фундаментальный тип данных : каждая переменная имеет тип данных связанный с ней. Каждый тип данных требует разного объема памяти и имеет определенные операции, которые можно выполнять над ним. ",
      "2. Производный тип данных: эти типы данных определяются самим пользователем. Например, определение класса или структуры. К ним относятся массивы , структуры , класс , объединение , перечисление , указатели и т. д. ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "сматчить это полное соответствие чего-либо с чем-либо",
    answer: [
      "От англ. match (дословно — совпадать) — полное соответствие чего-либо с чем-либо. Процесс приведения к единообразию. Примеры употребления: «Этот стиль вот совсем не матчится с тем, что сейчас на проде» «Нужно сматчить эти два мока» «Отлично матчится с недавно зарелиженной фичей» Пинать. Термин, подобный глаголу «пинать», который также имеет значение «делать» и «работать». ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Синхронный код",
    answer: [
      "Синхронный код — это выполнение кода строка за строкой. Если бы мы запустили синхронную функцию задержки delay(), то движок бы ничем другим заниматься в это время не мог. То есть пока delay() не выполнится до конца, к следующей строке интерпретатор не перейдёт.",
      "А это значит, что пока не пройдёт 5 секунд, и delay() не выполнится, мы вообще ничего сделать не сможем: ни вывести что-то в консоль ещё, ни выполнить другие функции, в особо тяжёлых случаях — даже передвинуть курсор.",
      "Такие операции, которые не дают выполнять ничего кроме них самих, пока они не завершатся, называются блокирующими выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронный код",
    answer: [
      "Асинхронный код - это код, который выполняется не построчно.",
      "Асинхронный код помогает избежать блокирующие выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные события.",
    answer: [
      "Асинхронными событиями являются те, которые возникают независимо от основного потока выполнения программы, отложенные по времени.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронная функция.",
    answer: ["Асинхронная функция, это функция, которая вместо какого-то значения возвращает промис."],
    isParagraph: true,
  },
  {
    heading: "Цикл событий. (Event loop)",
    answer: [
      "Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.",
      "Вызовы из стека работают по принципу «последний зашёл, первый вышел",
      "Цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно",
      "Цикл событий берёт на себя управление тем, как должны вызываться функции Web API.",
    ],
    isParagraph: true,
  },
  {
    heading: "Очередь задач",
    answer: [
      "Очередь задач - структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым. По принципу «первый зашёл, первый вышел» ",
    ],
    isParagraph: true,
  },
  {
    heading: "Колбэк. Callback",
    answer: [
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие».",
      "В целом, событием может быть что угодно:",
      " - ответ от сервера;",
      " - завершение какой-то длительной вычислительной задачи;",
      " - получение доступа к каким-то API устройства, на котором выполняется код.",
      "Таким образом колбэк — это первый способ обработать какое-либо асинхронное действие. ",
      "Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.",
      "Это, в принципе, логично — ментальная модель достаточно простая: «выполни эту функцию, когда случится это событие». ",
      "Однако у колбэков есть неприятный минус, так называемый ад колбэков (callback hell).",
    ],
    isParagraph: true,
  },
  {
    heading: "Ад колбэков (Callback-hell) ",
    answer: [
      "Это когда у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.",
      "Если одна задача запускает другую, та — третью, и так далее, мы можем получить вот такую «башню» из обратных вызовов. И такая башня может получиться где угодно. Если мы делаем несколько последовательных запросов к серверу, зависящих друг от друга, то это может выглядеть, как нечитабельное нагромаждение кода.",
      "Читать такое сложно, не говоря уже о тестировании.",
      "Решить эту проблему были призваны Промисы (Promise).",
    ],
    isParagraph: true,
  },
  {
    heading: "Промисы (Promise)",
    answer: [
      "Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).",
      "В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.",
      "Промисы придумали, чтобы организовывать асинхронный код последовательно.",
      "Использование промисов, при решении ряда асинхронных запросов, избавляют код от лишней вложенности, делают его плоским и более тестируемым.",
      "Дополнительным плюсом стала возможность обрабатывать ошибки от цепочки промисов в одном месте — последним catch.",
      "Если что-то пошло не так, то программа не упадёт, а управление перейдёт к последней строчке с catch(), причём независимо от того, в каком из запросов ошибка появится.",
      "Также из then() можно вернуть не промис, а обычное значение. Оно обернётся в промис самостоятельно и прокинется в следующий then(): ",
      " request('/api/users/1') ",
      " - .then((user) => user.id)",
      " - .then((userId) => request(`/api/photos/${userId}/`)) ",
      " - .then((photo) => request(`/api/crop/${photo.id}/`)) ",
      " - .then((response) => console.log(response)) ",
      " - .catch((error) => console.error(error)) ",

      "Промисы оказались удобными, и появился даже такой термин как «промисификация» — когда асинхронную функциональность на колбэках превращали в промисы.",
      "Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков...  Для решения этих проблем придумали асинхронные функции.",
      " -----------------------------------------------------",
      "Promise (промис) - это объект, в который мы записываем два колбэка вместо того, чтобы передать их функции (resolve, reject).",
      "Промис - это обещание предоставить результат позже. С помощью промиса можно поставить на ожидание получение результата и, когда его получаем, можем его обрабатывать. Так же промис может вернуть ошибку, если результат вернуть не возможно. Промис может вернуть либо результат, либо ошибку. ",
      "Промис- может быть создан:",
      " - путём создания нового экземляра класса Promise ",
      " - методом fetch(), который всегда возвращает промис. ",
      " - асинхронной функцией async (), которая также всегда возвращает промис.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные функции. async",
    answer: [
      "Асинхронные функции — функции, которые возвращают промисы.",
      "Асинхронная функция помечается специальным ключевым словом async",
      "Они всегда возвращают Промис. Даже если мы явно этого не указывали, при вызове они всё равно вернут промис.",
      "Однако с асинхронными функциями можно не обращаться с then() — есть более изящное решение: async/await Скопировать ссылку на секцию ''Связка async/await''",
    ],
    isParagraph: true,
  },
  {
    heading: "Связка async/await",
    answer: [
      "Примечание: async/await является частью ECMAScript 2017 и не поддерживается в Internet Explorer и более старых браузерах, поэтому используйте их осторожностью",
      "Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await.",
      "async function loadPosts() { ",
      " - const response = await fetch('/api/posts/') ",
      " - const data = await response.json()",
      " - return data",
      " - }",
      "В примере выше мы используем метод fetch() внутри функции loadPosts(). ",
      "Все асинхронные функции внутри мы вызываем с await — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было. ",
      "------------------------------------------------",
      "Добавленное перед определением функции ключевое слово async делает функцию асинхронной. Возвращаемое значение такой функции автоматически оборачивается в Promise.",
      "Асинхронные функции нужны для выполнения асинхронных операций: работой с API, базами данных, чтения файлов и т.д. ",
      "Асинхронные операции выполняются не сразу: код отправил запрос к API и ждёт, пока сервер пришлёт ответ. Ключевое слово await используется, чтобы дождаться выполнения асинхронной операции",
      "Движок JavaScript при этом не блокируется и может выполнять другой код. Как только ответ получен, выполнение кода продолжается.",
    ],
    isParagraph: true,
  },
  {
    heading: "Главное в async/await",
    answer: [
      "1. asynk/await - синтаксическая надстройка над промисами, не более.",
      "Asynk (асинхронная) функция ожидает результата инструкции await и не выполняет последующие инструкции. Но при этом, JavaScript может выполнять другие задачи. То есть, (await) - ожидание результата выполнения инструкций, нахождение Promise в состоянии pending, это не блокирующее действие. Промис не блокирует выполнение других частей нашего приложения. И только, когда промис будет либо исполнен, либо отклонён, выполнение функции продолжится.",
      "Это главное в ASYNK/AWAIT синтаксисе.",
      "--",
      "2. await синтаксис возможен только внутри asynk (асинхронных) функций. await заставляет JavaScript ждать, пока этот промис не выполнится, и после этого возвращает результат.",
      "3. asynk (асинхронная) функция всегда возвращает Promise. В асинхронной функции мы можем использовать ключевое слово return и возвращать какой-то результат: строку, объект, число, всё, что угодно. И до момента возврата результата функции с помощью ключевого слова return, Promise, который возвращает функция, будет в состоянии ожидания (pending). И если нигде ошибок не возникло и функция дошла до ключевого слова return, то Promise, возвращённый этой функцией, будет исполнен с теми данными, которые мы возвращаем в инструкции с ключевым словом return. Если возвращаем строку (return 'строка'). то промис будет исполнен и исполнен со строкой 'строка', как данными. Или, если возвращаем объект, будет исполнен с объектом и т.д. Если где-то возникла ошибка, то промис будет отклонён с той ошибкой, которая возникла внутри асинхронной функции.",
      "4. asynk (асинхронная) функция ожидает результата инструкции await и не выполняет последующие инструкции. Это очень важно. То есть, если есть инструкция с ключевым словом asynk, дальше функция не будет выполнятся, пока Promise находится в состоянии pending (ожидания). Но при этом, JavaScript может выполнять другие задачи, например, выполнять какие-то действия при нажатии пользователем какой нибудь кнопки в интерфейсе фронт-энд приложения. То есть, это не блокирующее действие. Промис не блокирует выполнение других частей нашего приложения. И только, когда промис будет resolved или rejected, то есть - либо исполнен, либо отклонён, выполнение функции продолжится. Это главное в ASYNK/AWAIT синтаксисе.",
    ],
    isParagraph: true,
  },
  {
    heading: "Плюсы async/await",
    answer: [
      "Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.",
      "Условия и вложенные конструкции становятся чище и проще читаются.",
      "Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch: ",
      "async function loadPosts() {",
      " - try {",
      " - const response = await fetch('/api/posts/')",
      " - const data = await response.json()",
      " - return data",
      " - } catch (e) {",
      " - console.log(e)",
      " - }",
      "}",
      "При этом в отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.",
      "Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Fetch API? ",
    answer: [
      "fetch() это механизм, который позволяет выполнять простые AJAX (асинхронные JavaScript и XML) вызовы с помощью JavaScript.",
      "Асинхронный означает, что вы можете использовать fetch для вызова внешнего API без остановки выполнения других инструкций. Таким образом, другие функции на сайте будут продолжать выполняться, даже если вызов API не был разрешен. ",
      "Когда ответ (данные) отправляется обратно из API, асинхронные задачи (выборка) возобновляются. ",
      "Важно отметить, однако, что fetch не является частью спецификации JavaScript, а является WWTAG. ",
      "Как использовать fetch()в JavaScript?",
      "Когда мы говорим об API, нам также нужно поговорить о конечных точках. Конечная точка - это просто уникальный URL, который вы вызываете для взаимодействия с другой системой. ",
      "Давайте предположим, что мы делаем запрос к внешнему API, чтобы получить некоторые данные (например, сообщение в блоге). Для этого мы будем использовать простой GET-запрос. ",
      "Просто вызовите fetch()с URL конечной точки в качестве аргумента: ",
      "fetch('https://ubahthebuilder.tech/posts/1'); ",
      "-- ",
      "fetch API возвращает обещание. Из-за этого вам нужно вложить метод then() для обработки разрешения.",
      "Данные, возвращаемые из API, нам нужно преобразовать в форму, с которой может работать ваш JavaScript. Для этого используем метод json() : ",
      "fetch('https://ubahthebuilder.tech/posts/1') ",
      ".then(data => { ",
      "return data.json(); ",
      "}) ",
      ".then(post => { ",
      "console.log(post.title); ",
      "}); ",
      "Извлечение сообщения в блоге из API и извлечение только свойства title ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " "],
    isParagraph: true,
  },
  {
    heading: "fetch(), пример запроса на пупликацию (method: 'POST')",
    answer: [
      "С помощью функции fetch() можно отправлять сетевые запросы на сервер — как получать, так и отправлять данные. Метод возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.",
      "Браузер предоставляет глобальный API для работы с запросами и ответами HTTP. Раньше для подобной работы использовался XMLHttpRequest, однако fetch() более гибкая и мощная альтернатива, он понятнее и проще в использовании из-за того, что использует Promise. ",
      "Функция fetch() принимает два параметра:",
      " - url — адрес, по которому нужно сделать запрос;",
      " - options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.",
      "По умолчанию вызов fetch() делает GET-запрос по указанному адресу. Базовый вызов для получения данных можно записать таким образом: ",
      " - fetch('http://jsonplaceholder.typicode.com/posts')",
      "Результатом вызова fetch() будет Promise, в котором будет содержаться специальный объект ответа Response. У этого объекта есть два важных для нас поля: ",
      " - ok — принимает состояние true или false и сообщает об успешности запроса;",
      " - json — метод, вызов которого, возвращает результат запроса в виде json.",
      "С помощью второго аргумента options можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Так же в запрос можно добавить заголовки в виде объекта или специального класса Headers.",
      " - const newPost = { title: 'foo', body: 'bar', userId: 1 } ",
      " -----------------------------------------------------------------",
      "fetch('https://jsonplaceholder.typicode.com/posts', { ",
      " - method: 'POST', // Здесь так же могут быть GET, PUT, DELETE",
      " - body: JSON.stringify(newPost), // Тело запроса в JSON-формате",
      " - headers: {",
      " - // Добавляем необходимые заголовки",
      " - 'Content-type': 'application/json; charset=UTF-8',",
      " - },",
      "})",
      " - .then((response) => response.json())",
      " - .then((data) => {",
      " - console.log(data)",
      " - // {title: 'foo', body: 'bar', userId: 1, id: 101}",
      " })",
    ],
    isParagraph: true,
  },
  {
    heading: "fetch(), запрос на получение данных с сервера (method: 'GET')",
    answer: [
      "1-ый краткий пример.",
      "fetch('https://jsonplaceholder.typicode.com/todos') ",
      ".then(response => {  ",
      "console.log(response) ",
      "return response.json() ",
      "}) ",

      " ----------------------",
      "2-ой пример через try...catch:  ",
      "const fetchTodos = async function() { ",
      " try { const response = await fetch(",
      "'https://jsonplaceholder.typicode.com/todos?_limit=20';",
      ") ",
      " if (!response.ok) { // Если у меня будет ошибка, то я её поймаю: ",
      "throw new Error('Ошибка на сервере.')",
      "}",
      "// Если ошибки нет,то.... ",
      "const date = await response.json(); ",
      "return date; ",
      "} catch (error: any) { ",
      "return error ",
      " } ",
      "}); ",
      " ----------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios",
    answer: [
      "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js. Axios предоставляет простую в использовании библиотеку в небольшом пакете с очень расширяемым интерфейсом.",
      "Axios может работать в браузере и nodejs с одной и той же кодовой базой). На стороне сервера используется собственный http модуль node.js, а на стороне клиента (браузера) — XMLHttpRequests.",
      "Установка: $ npm install axios",
      " ------------------------------",
      "Функции axios",
      "1. Делает XMLHttpRequests из браузера",
      "2. Делает http- запросы из node.js ",
      "3. Поддерживает promise API ",
      "4. Перехватывает запросы и ответы",
      "5. Преобразует данные запроса и ответа ",
      "6. Отменяет запросы ",
      "7. Автоматические преобразования для данных JSON ",
      "8. Автоматическая сериализация объектов данных multipart/form-dataи x-www-form-urlencodedкодировка тела ",
      "9. Поддержка на стороне клиента для защиты от XSRF",
      " ------------------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "const fetchAlbums = async function() {",
      " try { const response = await axios.get(",
      " `https://jsonplaceholder.typicode.com/albums?_limit=${params.limit}&_page=${params.page}`",
      " );",
      "// console.log(response); ",
      "const totalCount = response.headers['x-total-count']; ",
      "const albums = await response.data; ",
      "const res = { totalCount, albums }; ",
      "return res; ",
      " } catch (error: any) { ",
      " return error",
      " -}",
      "} ",
      ") ",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "async function getTodos() {",
      " - const { data } = await axios.get('http://someapi/todos/')",
      " - setTodos(firstTen;",
      " };",
      "В чём различие между переменными ",
    ],
    isParagraph: true,
  },
  {
    heading: "Метод push() – для добавления одного или нескольких элементов в конец массива ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Метод unshift() – для добавления одного или нескольких элементов в начало массива ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Метод pop() – удаляет последний элемент массива и возвращает его. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Метод shift() – удаляет первый элемент массива и возвращает его. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Метод slice() возвращает новый массив. Предназначен для копирования участка массива. При этом он не изменяет исходный массив, а возвращает в качестве результата новый массив, состоящий из выбранных элементов. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Метод splice предназначен для изменения содержимого массива. Он может использоваться как для добавления элементов в массив, так и для их удаления. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Метод concat() - объединяет два или более массива ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Цикл for () - для перебора элементов массива по цифровым индексам.  ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Цикл for..of не предоставляет доступа к индексу текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading: "Метод forEach() - для перебора элементов, вызывает функцию callback один раз для каждого элемента. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Поиск элемента в массиве. Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве, или -1, если он отсутствует. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Поиск элемента в массиве. Метод lastIndexOf() возвращает последний индекс, по которому данный элемент может быть найден в массиве, или -1, если он отсутствует. Массив просматривается в обратном направлении, начиная с fromIndex.",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Поиск элемента в массиве. Метод includes(item, from) - ищет item начиная с индекса from и возвращает true, если поиск успешен. Или false, если item не найден",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Поиск первого элемента в массиве по заданному условию. Метод find() - позволяет найти первый (один) объект в массиве по заданному условию, иначе возвращается undefined. findLastIndex() и findIndex()",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Поиск всех элементов в массиве, удовлетворящих заданному условию. Метод filter() - создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.",
    answer: [
      "Метод filter() вызывает переданную функцию callback один раз для каждого элемента массива, и создаёт новый массив со всеми значениями, прошедшими проверку. Элементы массива, не прошедшие проверку функцией callback, просто пропускаются и не включаются в новый массив. ",
      "Метод filter() не изменяет массив, для которого он был вызван, метод создаёт новый массив.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Метод map() - создает новый массив из результатов вызванной функции для каждого элемента массива.",
    answer: [
      "Метод вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции. Возвращаемое значение: новый массив, где каждый элемент является результатом callback функции. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Метод sort() сортирует массив на месте, меняя в нём порядок элементов. ",
    answer: [
      "Сортировка массива выполняется с помощью метода sort(). По умолчанию он сортирует массив в порядке следования символов в кодировке Unicode. ",
      "По умолчанию, элементы сортируются как строки. Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что '2' > '15'.",
      "1. Лучше использовать стрелочные функции ",
      "2. Сравнение чисел: arr.sort( (a, b) => a - b ); ",
      "3. Для сравнения строк используйте localeCompare: const sorted = ( array.sort( (a, b) => a.localeCompare(b) ) );",
      "4. Объекты могут быть отсортированы по значению одного из своих свойств:",
      "5. const sorted = array.sort(( a, b ) => a.name - b.name ) // работает;",
      "6. const sorted = items.sort((a, b) => a.name.localeCompare(b.name)) // работает;",
      "7. const sorted = array.sort( (a, b) => a.name > b.name ? 1 : -1) // работает;",
    ],
    isParagraph: true,
  },
  {
    heading: "Метод  reverse() сортирует в обратном порядке.",
    answer: [" ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading:
      "Метод join() - преобразует все элементы массива (или массивоподобного объекта) в новую строку, разделенную запятыми или заданным (separator-разделитель) разделителем. Если в массиве только один элемент, то этот элемент будет возвращен без использования разделителя. ",
    answer: [
      "Элементы массива (строка, число - не важно) объединяются в одну строку. Если элемент равен 'undefined' или 'null', он преобразуется в пустую строку. ",
      "Возвращаемое значение: строка со всеми объединенными элементами массива. Если arr.length равна 0, то возвращается пустая строка. ",
      "separator - (необязательный) задает вид разделителя ( запятая, пробел, строка; любой другой знак, символ, слово) для каждой пары соседних элементов массива. При необходимости разделитель преобразуется в строку. Если он опущен, элементы массива разделяются запятой ('',''). Если separator - пустая строка, все элементы соединяются без каких-либо символов между ними. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Метод split([ separator ]) - преобразует строку в массив по заданному разделителю. ",
    answer: [
      "let array = string.split([ separator ]) - преобразует строку в массив по заданному разделителю: (', '), (' + '), ('/'), (' '), (''), и т.д. ",
      "Метод split() принимает шаблон строк и делит его на упорядоченный список подстрок. Создаёт и возвращает массив из этих подстрок. ",
      "Возвращаемое значение: массив строк, разделенных в каждой точке, где встречается separator в данной строке. ",
      " - separator - шаблон, описывающий вид каждого разделения. Может быть undefined, строкой, регулярным выражением. Если разделитель отсутствует или равен undefined, то создаётся создаёт массив с одним элементом, объединяющим в себя все строки. ",
      " - limit - (необязательный) неотрицательное целое число, указывающее на ограничение количества подстрок, которые должны быть включены в массив. Если предоставлено, разбивает строку при каждом появлении указанного separator, но останавливается, когда limitзаписи помещаются в массив. ",
      " - Оставшийся текст не включается в массив. ",
      " - Если limit = 0, то возвращается пустой массив.",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Методы reduce() и reduceRight() вычисляют одно значение на основе всего массива (суммирование, умножение и т.д...). ",
    answer: [" ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: "Проверка массива. Метод Array.isArray() определяет, является ли переданное значение массивом. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Метод some() позволяет проверить: соответствует ли, по крайней мере один, элемент в массиве условию, заданному в передаваемой функции. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Метод copyWithin() копирует часть массива в тот же массив и возвращает его без изменения размера, т. е. копирует элементы массива в пределах одного массива. ",
    answer: [" "],
    isParagraph: true,
  },
  {
    heading:
      "Метод entry() — это метод Array, который используется для возврата нового объекта-итератора Array, который позволяет перебирать пары ключ/значение в массиве. Поскольку метод entry() является методом объекта Array, его необходимо вызывать через конкретный экземпляр класса Array. ",
    answer: ["Что такое DOM? "],
    isParagraph: true,
  },
  {
    heading: "Способы хранения данных в браузере: localStorage, sessionStorage, файлы cookie  ",
    answer: [
      "1. Локальное хранилище: это позволяет хранить пары ключ-значение в локальном хранилище браузера, которое можно получить даже после того, как пользователь закроет браузер или перезагрузит свое устройство. В нём может храниться до 10 Мб данных.",
      "2. Сессионное хранилище — это разновидность локального хранилища, которое привязано к сессии и удаляется после её завершения. В сессионном хранилище может храниться до 5 Мб данных.",
      "3. Файлы cookie: файлы cookie представляют собой небольшие фрагменты данных, которые хранятся в браузере пользователя и могут быть доступны веб-сайту при последующих посещениях. ",
      "localStorage и файлы cookie привязаны к конкретному домену. ",
      "Данные в localStorage будут сохраняться после того, как пользователь закроет браузер. Данные в sessionStorage стираются каждый раз, когда пользователь закрывает браузере.",
      "Важная особенность у файлов cookie:",
      "1. Файлы cookie имеют время жизни, которое мы сами можем устанавливать.",
      "2. С каждым запросм на сервер у нас эти куки отправляются автоматически и сервер может эти куки так же перезаписывать.",
      "3. У куков есть особенности с безопасностью.",
      "Чем отличаются куки-файлы, сессионное хранилище и локальное хранилище? ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как стек технологий? ",
    answer: [
      "Стек технологий (от англ. stack — «стопка») — это набор технологий, на основе которых разрабатывается сайт или приложение. ",
      "Стек включает в себя языки программирования, фреймворки (программная среда для разработки), системы управления базами данных, компиляторы (переводят текст, написанный на языке программирования, в набор машинных кодов) и так далее. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Storybook",
    answer: [
      "Storybook – это инструмент с открытым исходным кодом для изолированной разработки компонентов пользовательского интерфейса (UI). ",
      "Этот инструмент позволяет разработчикам создавать компоненты пользовательского интерфейса не в среде приложения, а в отдельной среде, где можно не беспокоиться о нестабильных данных, недописанных API или бизнес-логике. ",
      "Storybook можно интегрировать в большинство фронт-энд фреймворков, включая React, Vue и Angular. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое TDD?",
    answer: [
      "TDD расшифровывается как Test Driven Development (разработка через тестирование). Процесс, реализуемый в ходе применения этой методологии очень прост: Тесты выявляют ошибки, тесты завершаются успешно, выполняется рефакторинг. ... Для меня TDD — это гораздо больше, чем просто страховка. Это — возможность постоянного и быстрого, в режиме реального времени, получения сведений о состоянии моего кода. Скрыть ",
      "Что такое TDD. TDD — это аббревиатура от test-driven development (разработка через тестирование). Она широко известна в IT-индустрии благодаря книге Кента Бека по программной инженерии “Экстремальное программирование”. В этом бестселлере представлен новый метод разработки программного обеспечения — экстремальное программирование.  ",
    ],
    isParagraph: true,
  },
  {
    heading: "Функции в JavaScript.",
    answer: [
      "Функция — это самостоятельный блок кода, который можно, один раз объявив, вызывать столько раз, сколько нужно. Функция может принимать параметры (необязательно). Функции возвращают единственное значение. ",
      "Функции в JavaScript являются объектами, объектами типа Function. Их ключевое отличие от обычных объектов заключается в том, что функции можно вызывать.",
      "Кроме того, функции в JavaScript называют «функциями первого класса» так как их можно назначать переменным, их можно передавать другим функциям в качестве аргументов, их можно возвращать из других функций. ",
      "--",

      "1. Function Declaration (Объявление Функции). ",
      "function doSomething(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Function Declaration может быть вызвана раньше, чем она объявлена. ",
      "Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации». ",
      "И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение. ",
      "В результате функции, созданные как Function Declaration, могут быть вызваны раньше своих определений. ",
      "В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее, т.к функция будет видна до своего объявления в коде. Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным",
      "В наши дни такие функции называют «обычными», отличая их от «стрелочных» функций, которые появились в ES6. ",
      "--",

      "2. Функцию можно назначить переменной или константе. Такая конструкция называется функциональным выражением (function expression).",
      "const doSomething = function(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. ",
      "Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. ",
      "После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ). ",
      "Ещё одна важная особенность Function Declaration заключается в их блочной области видимости. ",
      "В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него. ",
      "Можно заметить, что в вышеприведённом примере функция назначена константе, но сама она имени не имеет. Такие функции называют анонимными.",
      "Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи. ",
      "--",

      "3. Можно заметить, что в вышеприведённом примере функция назначена константе, но сама она имени не имеет. Такие функции называют анонимными. Подобным функциям можно назначать имена. В таком случае речь идёт об именованном функциональном выражении (named function expression).",
      "const doSomething = function doSomFn(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Использование таких выражений повышает удобство отладки (в сообщениях об ошибках, где проводится трассировка стека, видно имя функции). Имя функции в функциональном выражении может понадобиться и для того, чтобы функция могла бы сама себя вызывать, без чего не обойтись при реализации рекурсивных алгоритмов. ",
      "--",

      "4. Стрелочные функции (arrow function) особенно удобно использовать в виде так называемых «встроенных функций» (inline function) — в роли аргументов, передаваемых другим функциям (коллбэков).",
      "const doSomething = (foo) => { ",
      " // сделать что-нибудь",
      "} ",
      "--",

      "5. Колбэк. Callback.",
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие». ",
      "--",

      "6. ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",

      "Итого: ",
      "1. Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода. ",
      "2. Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.",
      "3. Если функция была создана как часть выражения, то это “Function Expression”.",
      "4. Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.",
      "5. Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.",
      "В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее, т.к функция будет видна до своего объявления в коде. Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным ",
      "Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Функции Function Declaration (Объявление Функции). Такие функции называют «обычными», отличая их от «стрелочных» функций.",
    answer: [
      "Вот как выглядит Function Declaration (Объявление Функции). ",
      "function doSomething(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Function Declaration может быть вызвана раньше, чем она объявлена.",
      "Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».",
      "И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение. ",
      "В результате функции, созданные как Function Declaration, могут быть вызваны раньше своих определений. ",
      " ",
      "Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.",
      "В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее, т.к функция будет видна до своего объявления в коде. Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Функцию можно назначить переменной или константе. Анонимное функциональное выражение (function expression). ",
    answer: [
      "const doSomething = function(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции",
      "Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них.",
      "После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ). ",
      "Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.",
      "В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.",
      "Можно заметить, что в вышеприведённом примере функция назначена константе, но сама она имени не имеет. Такие функции называют анонимными.",
      "",
      "Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи ",
    ],
    isParagraph: true,
  },
  {
    heading: "Именованное функциональное выражение (named function expression). ",
    answer: [
      "const doSomething = function doSomFn(foo) { ",
      " // сделать что-нибудь",
      "} ",
      "Использование таких выражений повышает удобство отладки (в сообщениях об ошибках, где проводится трассировка стека, видно имя функции). Имя функции в функциональном выражении может понадобиться и для того, чтобы функция могла бы сама себя вызывать, без чего не обойтись при реализации рекурсивных алгоритмов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Поднятие функций ",
    answer: [
      "Перед выполнением JavaScript-кода производится его реорганизация. Мы уже говорили о механизме поднятия (hoisting) переменных, объявленных с использованием ключевого слова var. Похожий механизм действует и при работе с функциями. А именно, речь идёт о том, что объявления функций в ходе обработки кода перед его выполнением перемещаются в верхнюю часть их области видимости. В результате, например, оказывается, что вызвать функцию можно до её объявления. ",
      "doSomething() //  это вызов функции",
      "function doSomething() { // объявление функции ",
      " - console.log('did something')",
      "} ",
      "Если переместить вызов функции так, чтобы он шёл после её объявления, ничего не изменится. ",
      "--",
      "Если же в похожей ситуации воспользоваться функциональным выражением, то похожий код выдаст ошибку. ",
      "doSomething() //  это вызов функции",
      "var doSomething = function () { // функциональное выражение",
      " - console.log('did something')",
      "} ",
      "В данном случае оказывается, что хотя объявление переменной doSomething и поднимается в верхнюю часть области видимости, это не относится к операции присваивания. ",
      "Если вместо var в похожей ситуации использовать ключевые слова let или const, такой код тоже работать не будет, правда, система выдаст другое сообщение об ошибке (ReferenceError а не TypeError), так как при использовании let и const объявления переменных и констант не поднимаются ",
    ],
    isParagraph: true,
  },
  {
    heading: "Способы объявления функции",
    answer: [
      "function A() {};             // Function Declaration (Объявление Функции)",
      "var B = function () {};      // анонимное функциональное выражение ",
      "var C = (function () {});    // функциональное выражение с оператором группировки ",
      "var D = function foo () {};  // именованное функциональное выражение ",
      "var E = (function () {})();  // самовызывающееся функциональное выражение ",
      "var F = new Function();      // конструктор функции ",
      "var G = new function() {};   // вырожденный случай: конструктор объекта ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Неявный и явный возврат ",
    answer: [
      "У нас есть несколько способов написания наших стрелочных функций. Это потому, что стрелочные функции могут иметь ключевое слово «подразумеваемый возврат» или «явный возврат». ",
      "В обычных функциях, если вы хотите что-то вернуть, вам нужно использовать ключевое слово return. В стрелочных функциях тоже есть return. Когда вы используете return, это называется явным возвратом . Тем не менее, стрелка позволяет делать так называемый подразумеваемый возврат, когда return ключевое слово можно пропустить. Давайте посмотрим на несколько примеров: ",
      "Пример 1: нормальное функциональное выражение. ",
      "const sayHi = function(name) {",
      "return name; ",
      "} ",
      "-- ",
      "Пример 2: стрелочная функция с явным возвратом ",
      " - // Multi-line ",
      "const sayHi = (name) => { ",
      "return name; ",
      "}",
      " - // Single-line",
      "const sayHi = (name) => { return name } ",
      "-- ",
      "Пример 3: стрелочная функция с неявным возвратом ",
      " - // Single-line ",
      "const sayHi = (name) => name",
      " - // Multi-line ",
      "const sayHi = (name) => ( name ",
      " ) ",
      "-- ",
      "Когда вы используете фигурные скобки {}, вам нужно явно указать возврат. Однако, когда вы не используете фигурные скобки, return подразумевается, и вам этого делать не нужно. ",
      "Когда вы используете фигурные скобки, как в примере 2 , это называется телом блока . А синтаксис в примере 3 называется кратким телом. ",
      "Скобки ",
      "В обычных функциях нам всегда необходимо использовать круглые скобки для параметров. Однако для стрелочных функций скобки необязательны, если имеется ТОЛЬКО один параметр.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое end point? endPoint? ",
    answer: ["Конечная точка - это просто уникальный URL, который вы вызываете для взаимодействия с другой системой. "],
    isParagraph: true,
  },
  {
    heading: "Что такое стек вызовов? ",
    answer: [
      "Это механизм, предназначенный для отслеживания текущего местонахождения интерпретатора в скрипте. Он вызывает несколько функций и определяет, какая из них выполняется на данный момент, какие функции вызываются внутри выполняемой функции и какая будет вызвана следующей. ",
      "Стек вызовов создается, когда внутри функции (или метода) существуют другие функции. В реальных приложениях таких уровней могут быть сотни. ",
      "Стек вызовов формируется каждый раз, когда вы запускаете код на стороне браузера. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Рендеринг (отрисовка страницы) ",
    answer: [
      "Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Что такое очередь макрозадач (macrotask ). Это очередь задач, поступающих на выполнение в движок JavaScript. ",
    answer: [" ", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое исключение в программировании.",
    answer: [
      "Исключение — это любое состояние ошибки или непредвиденное поведение, возникающее при выполнении программы. Исключения могут возникать из-за сбоя в вашем или вызываемом коде (например, в общей библиотеке), недоступности ресурсов ОС, неожиданных состояний, возникающих в среде выполнения (например, код, который невозможно проверить) и по другим причинам. После некоторых из этих состояний приложение может восстановиться, после других — нет.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что значит возвращает значение в программировании? ",
    answer: [
      "Этот термин означает, что функция, после выполнения своего кода, выдаёт некое значение, которое можно присвоить другой переменной. ",
      " результат = имя_функции (); ",
      "Функция может принимать аргументы, может не принимать, может возвращать какое-то значение, может не возвращать. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое условие в программировании? ",
    answer: [
      "Условие – это логическое выражение, т.е. выражение, результатом которого является логическое значение true (истина) или false (ложь). Оператор if выбирает один из двух вариантов последовательности вычислений. if (условие) оператор1 else оператор2.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое итерация в программировании простыми словами? ",
    answer: [
      "Итерация – это одно повторение чего-либо. В программировании термин используют применительно к циклам: подпрограммам, которые выполняются несколько раз. Одно выполнение называется одной итерацией. ",
      "Итерация в широком смысле — организация обработки данных, при которой действия повторяются многократно, не приводя при этом к вызовам самих себя (в отличие от рекурсии) ",
      "В узком смысле — один шаг итерационного, циклического процесса. Когда какое-то действие необходимо повторить большое количество раз, в программировании используются циклы. Например, нужно вывести 200 раз на экран текст «Hello, World!». ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое рекурсия? Это когда функция вызывает сама себя",
    answer: [
      "Рекурсия – это термин в программировании, означающий вызов функцией самой себя ",
      "Рекурсивные функции могут быть использованы для элегантного решения определённых задач. ",
      "Шагом рекурсии называется вызов функцией самой себя",
      "База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов. ",
      "Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи.  ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Логические операторы: «ИЛИ»  «||», «И» «&&», «НЕ» «!», «??» (Оператор нулевого слияния). ",
    answer: [
      "В JavaScript есть четыре логических оператора: «ИЛИ»  «||», «И» «&&», «НЕ» «!», «??» (Оператор нулевого слияния). ",
      "1. Логический оператор «ИЛИ»  «||» находит первое истинное значение. ",
      "2. Логический оператор «И» «&&» находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные.",
      "Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше. ",
      "3. Логический оператор «НЕ» «!» возвращает противоположное значение.",
      "Приоритет «НЕ» «!». является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||. ",
      "4. Логический оператор нулевого слияния (??) возвращает первый аргумент, если он не null/undefined, иначе второй. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Логический оператор «ИЛИ»  «||» находит первое истинное значение ",
    answer: [
      "Логический оператор «ИЛИ» «||» находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6. ",
      "console.log (null || 1 || undefined ) // 1 ",
      "--",
      "alert( true || true );   // true ",
      "alert( false || true );  // true ",
      "alert( true || false );  // true ",
      "alert( false || false ); // false ",
    ],
    isParagraph: true,
  },
  {
    heading: "Логический оператор «И» «&&» находит первое ложное значение ",

    answer: [
      "Логический оператор «И» «&&» находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: ",
      " - console.log( false && 1 && [] ) // false",
      " - console.log(' ' && true && 5) // 5",
      "--",
      "// Если первый операнд истинный, ",
      "// И возвращает второй: ",
      "alert( 1 && 0 ); // 0 ",
      "alert( 1 && 5 ); // 5 ",
      "-- ",
      "// Если первый операнд ложный, ",
      "// И возвращает его. Второй операнд игнорируется ",
      "alert( null && 5 ); // null ",
      "alert( 0 && 'no matter what' ); // 0 ",
      "--",
      "Приоритет оператора «И» «&&» больше, чем «ИЛИ» «||», так что он выполняется раньше. ",
      "Приоритет «НЕ» «!» является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.",
    ],
    isParagraph: true,
  },
  {
    heading: "Логический оператор «НЕ» «!». Синтаксис довольно прост: result = !value;",

    answer: [
      "Оператор принимает один аргумент и выполняет следующие действия: ",
      "1. Сначала приводит аргумент к логическому типу true/false. ",
      "2. Затем возвращает противоположное значение.",
      "alert( !true ); // false ",
      "alert( !0 ); // true ",
      "-- ",
      "В частности, двойное «НЕ» «!» используют для преобразования значений к логическому типу: ",
      "alert( !!'non-empty string' ); // true",
      "alert( !!null ); // false ",
      "То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Логический оператор нулевого слияния «??»",
    answer: [
      "Результат выражения a ?? b будет следующим: ",
      " - если a определено, то a, ",
      " - если a не определено, то b. ",
      "Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй. ",
    ],
    isParagraph: true,
  },
  {
    heading: "XMLHttpRequest ",
    answer: [
      "XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы. ",
      "Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое. ",
      "На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch. ",
      "В современной веб-разработке XMLHttpRequest используется по трём причинам: ",
      "1. По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.",
      "2. Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).",
      "3. Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Fetch ",
    answer: [
      "Метод fetch() - современный и очень мощный способ для сетевых запросов и получения информации с сервера. ",
    ],
    isParagraph: true,
  },
  {
    heading: "AJAX ",
    answer: [
      "Для сетевых запросов из JavaScript есть широко известный термин «AJAX» (аббревиатура от Asynchronous JavaScript And XML).  ",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios ",
    answer: [
      "Axios — это простой HTTP-клиент на основе промисов для браузера и node.js. Axios предоставляет простую в использовании библиотеку в небольшом пакете с очень расширяемым интерфейсом. ",
    ],
    isParagraph: true,
  },
  {
    heading: "jQuery ",
    answer: [
      "jQuery — набор функций JavaScript, фокусирующийся на взаимодействии JavaScript и HTML. Библиотека jQuery помогает легко получать доступ к любому элементу DOM, обращаться к атрибутам и содержимому элементов DOM, манипулировать ими. Также библиотека jQuery предоставляет удобный API для работы с AJAX.  ",
    ],
    isParagraph: true,
  },
  {
    heading: "Итерируемые объекты js.",
    answer: [
      "JavaScript поддерживает протокол, согласно которому такие объекты, как массивы, могут последовательно перебираться циклами и spread-оператором. ",
      "Такой процесс перебора элементов внутри объекта называется итерацией, а объекты, поддерживающие эту функцию, называются итеративными объектами (также встречаются названия «итерируемые» и «перебираемые» объекты) ",
      "К итеративным объектам в JavaScript относятся карты, массивы и наборы с итерируемым свойством. Простые объекты по умолчанию не являются итеративными. ",
      "Иначе говоря, итеративные объекты – это структуры данных, которые позволяют потребителям данных последовательно получать доступ к своим элементам.",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " "],
    isParagraph: true,
  },
];

/* eslint-disable no-template-curly-in-string */
import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksJavascript: ILinkInfo[] = [
  {
    href: "https://wm-school.ru/js/index.php",
    title: "Шикарный учебник JavaScript на русском языке",
  },
  {
    href: "https://habr.com/ru/post/486820/",
    title: "70 вопросов по JavaScript для подготовки к собеседованию",
  },
  {
    href: "https://www.geeksforgeeks.org/find-the-number-occurring-odd-number-of-times/",
    title: "Задачи по javascript. geeksforgeeks",
  },
  {
    href: "https://dev.to/thepracticaldev/series/1326",
    title: "Задачи по javascript. Daily Challenge Series' Articles",
  },
  {
    href: "https://www.codewars.com/kata/53f40dff5f9d31b813000774/train/javascript",
    title: "Задачи по javascript. Kata Training",
  },
  {
    href: "https://medium.com/nuances-of-programming/var-let-const-%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-dc6c3beb0b12#:~:text=var%20%2D%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%BA%D0%B0%D0%BA,%D0%BE%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%20%D0%BD%D0%B0%D0%B2%D0%B5%D1%80%D1%85%20%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8.",
    title: "Var, Let, Const — в чем разница? (Подробная статья )",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#vsplytie",
    title: "Всплытие и погружение событий",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#prekraschenie-vsplytiya",
    title: "Прекращение всплытия события",
  },
  {
    href: "https://learn.javascript.ru/bubbling-and-capturing#event-target",
    title: "event.target",
  },
  {
    href: "https://learn.javascript.ru/prototype-inheritance",
    title: "Прототипное наследование",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Glossary/Falsy",
    title: "Ложноподобное (falsy) значение",
  },
  {
    href: "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent",
    title: "Событие Клавиатуры",
  },
  {
    href: "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code",
    title: "KeyboardEvent.code",
  },
  {
    href: "https://www.codingem.com/regex/",
    title: "Регулярное выражение",
  },
  {
    href: "https://itchief.ru/javascript/scope-and-context",
    title: "Область видимости и контекст в JavaScript ",
  },
  {
    href: "https://drbrain.ru/articles/js-spread-vs-rest/",
    title: "SPREAD vs REST. Чем отличаются операторы spread и rest в JavaScript ",
  },
  {
    href: "https://techrocks.ru/2021/08/23/javascript-programming-cheatsheet/",
    title: "Синтаксис и методы JavaScript: шпаргалка",
  },
  {
    href: "https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/",
    title: "Методы строк в JavaScript: простая шпаргалка с примерами",
  },
  {
    href: "https://basicweb.ru/javascript/js_string.php",
    title: "JavaScript строки",
  },
  {
    href: "https://itchief.ru/javascript/numbers ",
    title: "Работа с числами в JavaScript",
  },
  {
    href: "https://date-fns.org/v2.28.0/docs/Locale",
    title: "Формат даты Locale (есть ещё лучше)",
  },
  {
    href: "https://date-fns.org/v2.28.0/docs/format",
    title: "Форматирование даты (есть ещё лучше)",
  },
  {
    href: "http://www.lingoes.net/en/translator/langcode.htm",
    title: "Формат даты Locale",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat",
    title: "Intl.DateTimeFormat. Международный формат даты и времени",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/705",
    title: "Event Loop — макрозадачи и микрозадачи",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/704",
    title: "Promise API",
  },
  {
    href: "https://tokmakov.msk.ru/blog/item/703",
    title: "Асинхронный код — callback, promise и async/await",
  },
  {
    href: "https://medium.com/nuances-of-programming/%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-javascript-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-f47cf28fb130",
    title: "Асинхронный JavaScript ― Цикл обработки событий",
  },
  {
    href: "https://learn.javascript.ru/async-await",
    title: "Async/await",
  },
  {
    href: "https://doka.guide/js/async-in-js/",
    title: "Асинхронность в JS",
  },
  {
    href: "https://doka.guide/tools/http-protocol/",
    title: "Протокол HTTP",
  },
  {
    href: "https://doka.guide/js/async-await/",
    title: "async/await",
  },
  {
    href: "https://habr.com/ru/search/?q=axios&target_type=posts&order=relevance",
    title: "Axios или Fetch?",
  },
  {
    href: "https://axios-http.com/",
    title: "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js.",
  },
  {
    href: "https://www.freecodecamp.org/news/axios-react-how-to-make-get-post-and-delete-api-requests/",
    title: "Axios React — как получать(GET), публиковать(post) и удалять(DELETE) запросы API",
  },
  {
    href: " ",
    title: " ",
  },
  {
    href: " ",
    title: " ",
  },
  {
    href: " ",
    title: " ",
  },
];

export const arrayJavascript: IObjectHeadingAnswers[] = [
  {
    heading: "Что такое JavaScript?",
    answer: [
      "JavaScript — это язык программирования на стороне клиента/сервера.",
      "JavaScript можно вставить в HTML, чтобы сделать веб-страницу интерактивной и обеспечить взаимодействие с пользователем.",
      "JavaScript имеет динамическую типизацию. Это означает, что тип объектов проверяется во время выполнения . (В статически типизированном языке тип проверяется во время компиляции.) Другими словами, переменные JavaScript не связаны с типом. Это означает, что вы можете без проблем изменить тип данных.",
      "JavaScript — это интерпретируемый язык. Интерпретатор в браузере читает код JavaScript, интерпретирует каждую строку и запускает ее.",
      "JavaScript — это язык, чувствительный к регистру.",
      "JavaScript работает с одним потоком. Это означает, что он выполняет код по порядку и должен завершить выполнение фрагмента кода, прежде чем перейти к следующему.",
      "Это не позволяет писать код, который интерпретатор мог бы выполнять параллельно в нескольких потоках или процессах.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое область видимости и цепочка областей видимости (scope chain?)",
    answer: [
      "Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям.",
      "JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6). ",
      "1. Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде. ",
      "2. Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции. ",
      "3. Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.",
      "Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain). ",
      "Таким образом, цепочкой областей видимости (scope chain) можно назвать последовательность областей видимости, которые интерпретатор JavaScript использует для поиска переменных. При этом поиск всегда начинается с текущей области видимости и если только она не найдена в текущей, то происходит переход к следующей по цепочке и поиск переменной там и т.д. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Var, Let, Const — в чем разница?",
    answer: [
      "Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }).",
      "Если не планируется изменять значение переменной, то объявлять её лучше через «const». Это позволит избежать объявление переменной дважды, случайно изменив её. Переменные, объявленные при помощи «const» , нельзя обновить или объявить заново. То есть, значение переменной, объявленной при помощи «const» , остается неизменным внутри ее области видимости. Эту переменную нельзя объявить заново или обновить. ",
      "Переменные, объявленные при помощи let, могут обновляться, но не объявляться повторно.",
      "Переменные, объявленные с помощью ключевого слова «var», НЕ имеют блочную область видимости. Переменные, объявленные при помощи «var», могут как объявляться заново, так и обновляться.",
    ],
    isParagraph: true,
  },
  {
    heading: "Поднятие переменных и функций (hoisting) var",
    answer: [
      "В JavaScript поднятие - это механизм, обеспечивающий перемещение объявлений переменных и функций в верх их области видимости до запуска кода.",
      "Для функций это означает, что вы можете вызывать их из любой точки области видимости, даже до того, как они будут определены.",
      "Переменные, объявленные при помощи var, поднимаются в верх своей области видимости и инициализируются присвоением какого-нибудь значения или undefined.",
      " 1. Поднятие — подъем переменной или функции в глобальную или функциональную области видимости.",
      " 2. В фазе компиляции функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления).",
      " 3. В фазе выполнения переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.",
      " 4. Запомнить! Поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое поднятие (Hoisting)? (2-ой вариант ответа)",
    answer: [
      "Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости. ",
      "Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения. ",
      "Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. ",
      "Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.). ",
      "Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются. ",
      "Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Контекст выполнения.",
    answer: [
      "Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое замыкание и как/для чего его используют?",
    answer: [
      "Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. ",
      "Если одна функция определена внутри другой, то внутренняя функция имеет доступ к области видимости внешней функции. Это называется замыканием (также лексической ОВ или статической).",
      "Замыкание в JavaScript означает, что внутренняя функция имеет доступ к переменным внешней функции — даже после возврата внешней функции. Это возможно из-за замыкающей природы JavaScript: внутренняя функция имеет доступ к переменным внешней функции даже после возврата внешней функции.",
      "Например, чтобы создать счетчик, который увеличивается на 1, вы можете использовать замыкание:",
      " function createCounter() { let counter = 0; function increment() { counter++; console.log(counter); } return increment; }",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое всплытие событий?",
    answer: [
      "При всплытии событий, событие начинается с запуска обработчиков событий на самом внутреннем элементе. Затем он запускает обработчики событий родителей, пока не достигнет самого внешнего элемента.",
      "Другими словами: когда на элементе происходит событие, обработчики (например: onclick ) сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков до самого document.",
      "Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.",
      "Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      "Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое погружение события?",
    answer: [
      "Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.",
    ],
    isParagraph: true,
  },
  {
    heading: "event.target",
    answer: [
      "Всегда можно узнать, на каком конкретно элементе произошло событие.",
      "Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.",
      "event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.",
      "event.target будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.",
    ],
    isParagraph: true,
  },
  {
    heading: "Методы event.stopPropagation() и event.stopImmediatePropagation()",
    answer: [
      "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию, событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.",
      "Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.",
      "Для этого нужно вызвать метод event.stopPropagation().",
      "Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.",
      "То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.",
      "Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.",
      " ",
      "Не прекращайте всплытие без необходимости!",
      "Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.",
      "Зачастую прекращение всплытия через event.stopPropagation() имеет свои подводные камни, которые со временем могут стать проблемами.",
    ],
    isParagraph: true,
  },
  {
    heading: "Делегирование событий.",
    answer: [
      "Всплытие событий позволяет реализовать один из самых важных приёмов разработки - делегирование.",
      "Делегирование заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком потомке произошло событие и обаботать его.",
      "Алгоритм: вешаем обработчик на контейнер. В обработчике получаем event.target. В обработчике, если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.",
      "Зачем использовать: упрощает инициализацию и экономит память: не нужно вешать много обработчиков. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики. Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как this работает в JavaScript.",
    answer: [
      "Ключевое слово this относится к текущему объекту, внутри которого пишется код.",
      "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.",
      "Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает прототипное наследование",
    answer: [
      "Прототипом объекта А называется объект B, свойства и методы которого доступны для объекта A как собственные.",
      "У любого объекта есть прототип, на который указывает его свойство __proto__ и который также является объектом.",
      "У любой функции есть ассоциированный с ней объект, на который в контексте функции указывает свойство prototype. В него, как в контейнер обычно складывают свойства и методы для работы с определенным классом объектов.",
      "Такой контейнер автоматически становится прототипом объектов, создаваемых функциями-конструкторами Для редактирования прототипной ссылки объекта используют метод Object.create() - он перезаписывает объект заново и выставляет в нем ссылку на нужный прототип.",
      "Ссылки, связанных друг с другом объектов, образуют прототипную цепочку, которая лежит в основе прототипного наследования. Ярким примером такого наследования является цепочка узлов DOM модели.",
    ],
    isParagraph: true,
  },
  {
    heading: "Типы данных в JavaScript",
    answer: [
      " - Строка «string». Строка может содержать ноль или больше символов, нет отдельного символьного типа.",
      " - Число «number» - единый тип для любых чисел: как для целых, так и для дробных чисел; дробные значения ограничены диапазоном ±(253-1). Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.",
      " - «bigint» даёт возможность работать с целыми числами произвольной длины. Тип «number» не может содержать числа больше, чем (253-1), или меньше, чем -(253-1). ",
      " - «boolean» булевый (логический) тип представляет логическое значение true или false",
      " - «null» для неизвестных значений – отдельный тип, имеющий одно значение null. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».",
      " - «undefined» для неприсвоенных значений. Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.",
      " - Символы «symbol» для уникальных идентификаторов. «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.",
      " - Объекты «object» для более сложных структур данных. Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}",

      "Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.",
      "Имеет две формы: typeof x или typeof(x).",
      "Возвращает строку с именем типа. Например, 'string'",
      "Для null возвращается object – это ошибка в языке, на самом деле это не объект.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить тип переменной (данных) в JavaScript?",
    answer: [
      "Воспользуйтесь typeof оператором.",
      " - typeof John Abraham возвращает string",
      " - typeof 100 возвращает number ",
    ],
    isParagraph: true,
  },
  {
    heading: "Typeof оператор",
    answer: ["Оператор typeof используется, в основном, для того, чтобы узнать тип примитивного значения"],
    isParagraph: true,
  },
  {
    heading: "В чём различие между переменными, значение которых: null, undefined и не объявлено?",
    answer: [
      " - null - это «значение отсутствия значения». null — это значение, которое присваивается переменной явно.",
      " - undefined - это переменная, которая была объявлена, но не было присвоено значение. У нее нет значения.",
      " - undeclared - переменная, объявленная без ключевого слова 'var'.",
      "Для проверки можно использовать console.log() и typeof.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между NULL и undefined?",
    answer: [
      "1. null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно.",
      "2. undefined («неопределенный») представляет собой значение по умолчанию:",
      " - для переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;",
      " - для функции, которая ничего не возвращает явно, например, console.log(1);",
      " - для несуществующего свойства объекта.",
      "В указанных случаях движок JS присваивает значение undefined. ",
      "При сравнении null и undefined мы получаем true, когда используем оператор '==', и false при использовании оператора '==='. О том, почему так происходит, см. ниже. ",
      " - console.log(null == undefined) // true",
      " - console.log(null === undefined) // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие значения в JavaScript являются ложными (falsy)?",
    answer: [
      "Ложное (falsy) значение — значение, которое становится false в булевом контексте. JavaScript использует преобразование типов, чтобы привести значение к булевому типу, там, где это требуется (например, в условных конструкциях и циклах).",
      "0. Ноль Number (к нему также относятся 0.0, 0x0 и т.д.).",
      "-0. Отрицательный ноль типа Number (к нему также относятся -0.0, -0x0 и т.д.).",
      "0n. Ноль типа BigInt (также 0x0n). Обратите внимание, что не может быть негативного нуля типа BigInt — отрицательный 0n равняется 0n.",
      "Значения, содержащие пустую строку. (Пустые кавычки: двойные, одинарные, косые)",
      "null — отсутствие какого-либо значения.",
      "undefined — примитивное значение, переменная, не имеющая присвоенного значения.",
      "NaN - (en-US) NaN — значение, не являющиеся числом.",
      "document.all Объекты считаются ложноподобными тогда и только тогда, когда у них есть внутренний слот [[IsHTMLDDA]]. Этот слот есть только в объекте document.all, и его задать через JavaScript. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Основное различие между циклом forEach и циклом .map()? И в каких случаях каждый из них используется?",
    answer: ["forEach перебирает массив и изменяет его.", ".map() создает копию массива и изменяет копию."],
    isParagraph: true,
  },
  {
    heading: "Назовите различные циклы в JavaScript",
    answer: [
      "for- перебирает блок кода несколько раз",
      "for/in- перебирает свойства объекта",
      "for/of- перебирает значения итерируемого объекта",
      "while- перебирает блок кода, пока заданное условие истинно",
      "do/while- также перебирает блок кода, пока заданное условие выполняется",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает оператор «break»?",
    answer: [
      "Оператор break выводит из цикла и продолжает выполнение кода вне цикла.",
      "for (var i = 0; i < 100; i++) {  ",
      " if (i === 5)  ",
      " { break; } ",
      " console.log('Number is ', i); } console.log('Yay');",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает оператор continue?",
    answer: [
      "Оператор continue перескакивает через один раунд цикла.",
      "for (var i = 0; i < 5; i++) { ",
      " if (i === 2 || i === 3) ",
      " { continue; } ",
      " console.log('Number is ', i); }",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое анонимная функция?",
    answer: [
      "Анонимная функция — это функция, не имеющая имени. Анонимные функции часто используются для выполнения какого-то кода в коллбэках, где не нужно создавать отдельную именную функцию под это действие.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между host-объектами и нативными объектами?",
    answer: [
      "Собственные объекты: Object (конструктор), Date, Math, parseInt, eval, строковые методы, такие как indexOf и replace, методы массивов и т.д. - основные предопределённые объекты, всегда доступные в JavaScript.",
      "Объекты хоста (при условии среды браузера): window, document, location, history, XMLHttpRequest, setTimeout, getElementsByTagName, querySelectorAll и т.д. - Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?",
    answer: [
      "function Person(){} - Мы создаем функцию с именем Person.",
      "var person = Person() - Мы вызываем функцию Person и результат сохраняем в переменную person.",
      "var person = new Person() - Мы создаем новый объект, используя функцию-конструктор Person.",
    ],
    isParagraph: true,
  },
  {
    heading: "Оператор new",
    answer: [
      "Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).",
      "Допустим, у нас есть такой код:",
      "function Employee(name, position, yearHired){",
      " - this.name = name",
      " - this.position = position",
      " - this.yearHired = yearHired",
      "}",
      "const emp = new Employee('Marko Polo', 'Software Development', 2017)",
      "Ключевое слово «new» делает 4 вещи:",
      "1. Создает пустой объект.",
      "2. Привязывает к нему значение this.",
      "3. Функция наследует от functionName.prototype.",
      "4. Возвращает значение this, если не указано иное.",
      "Оператор new используется для создания объектов. Операндом этого оператора должна быть функция. Функция, которая создаётся специально для работы с оператором new, называется конструктором. Конструктор используется для инициализации нового созданного объекта:",
      "Работает это всё (оператор new с конструктором) следующим образом: встречая оператор new интерпретатор создаёт новый пустой объект, затем он вызывает конструктор, и передаёт ему новый созданный объект в качестве значения ключевого слова this. Внутри конструктора происходит инициализация свойств вновь созданного объекта. После того, как объект создан и инициализарован, оператор new возвращает созданный объект. Создаём новый экземпляр какого-то класса. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое колбэк-функция - функция",
    answer: [
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие».",
      " Коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершит работу.",
      " Функция обратного вызова — это функция, которая передается в качестве аргумента другой функции.",
      " Коллбэки нужны по одной очень важной причине: JavaScript — это язык, в котором огромную роль играют события. Это означает, что вместо того, чтобы ожидать, скажем, результата выполнения некоей функции, остановив при этом все остальные операции, JavaScript-программа работает, наблюдая за событиями и реагируя на них.",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните разницу между «==» и «===».",
    answer: [
      " «==» используется для сравнения двух значений независимо от типа данных переменной. (сравнивает значения)",
      "«===» используется для сравнения двух значений, но это будет строгая проверка, поэтому будет проверяться соответствие значения и типа данных. (сравнивает как значение, так и тип)",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли значение не числом?",
    answer: [
      "Функция isNaN() определяет, является ли значение не числом.",
      " isNaN(48) //false ",
      " isNaN('123') //false ",
      " isNaN('Привет, я настоящая строка') //true ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как преобразовать строку в число?",
    answer: [
      "parseInt() преобразует строку в целое число: ",
      " parseInt('30', 10) // 30 ",
      " parseInt('55px', 10) // 50  ",
      " parseInt(2.55, 10) // 2",
      " - ",
      " parseFloat()  преобразует строку в число точек (с десятичным числом)",
      " parseFloat('30') // 30 ",
      " parseFloat('55px') // 50 ",
      " Number() преобразует строку в число. Это может быть целое число или десятичное число. Они часто могут быть менее безопасными, чем использование parseInt или parseFloat",
    ],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли объект массивом?",
    answer: ["Функция isArray() определяет, является ли объект массивом.", " "],
    isParagraph: true,
  },
  {
    heading: "Что такое параметры функции по умолчанию.",
    answer: [
      "Они позволяют инициализировать именованные параметры со значениями по умолчанию, если значение не передается или undefined не передается.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое модули ES6?",
    answer: [
      "Модуль – это просто файл. Один скрипт – это один модуль.",
      "Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. ",
      "Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:",
      "Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта. ",
      " - import позволяет импортировать функциональность из других модулей.",
      " - export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.",
      " - export default (по умолчанию) используется, когда модулю нужно экспортировать только одно значение.",
      "Именованные экспорты отличаются своими именами. В модуле может быть несколько именованных экспортов.",
      "Модуль может содержать переменные и функции. Модуль — это не что иное, как фрагмент кода JavaScript, записанный в файле.",
      " - Своя область видимости переменных",
      "Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое async/await?",
    answer: [
      "async перед функцией означает одну простую вещь: функция всегда возвращает промис (обещание). Другие значения автоматически оборачиваются в разрешенное обещание.",
      "await заставляет JavaScript ждать, пока этот промис не выполнится, и после этого возвращает результат.",
    ],
    isParagraph: true,
  },
  {
    heading: "Главное в ASYNK/AWAIT",
    answer: [
      "1. asynk/await - синтаксическая надстройка над промисами, не более.",
      "2. await синтаксис возможен только внутри asynk (асинхронных) функций. ",
      "3. asynk (асинхронная) функция всегда возвращает Promise. В асинхронной функции мы можем использовать ключевое слово return и возвращать какой-то результат: строку, объект, число, всё, что угодно. И до момента возврата результата функции с помощью ключевого слова return, Promise, который возвращает функция, будет в состоянии ожидания (pending). И если нигде ошибок не возникло и функция дошла до ключевого слова return, то Promise, возвращённый этой функцией, будет исполнен с теми данными, которые мы возвращаем в инструкции с ключевым словом return. Если возвращаем строку (return 'строка'). то промис будет исполнен и исполнен со строкой 'строка', как данными. Или, если возвращаем объект, будет исполнен с объектом и т.д. Если где-то возникла ошибка, то промис будет отклонён с той ошибкой, которая возникла внутри асинхронной функции. ",
      "4. asynk (асинхронная) функция ожидает результата инструкции await и не выполняет последующие инструкции. Это очень важно. То есть, если есть инструкция с ключевым словом asynk, дальше функция не будет выполнятся, пока Promise находится в состоянии pending (ожидания). Но при этом, JavaScript может выполнять другие задачи, например, выполнять какие-то действия при нажатии пользователем какой нибудь кнопки в интерфейсе фронт-энд приложения. То есть, это не блокирующее действие. Промис не блокирует выполнение других частей нашего приложения. И только, когда промис будет resolved или rejected, то есть - либо исполнен, либо отклонён, выполнение функции продолжится. Это главное в ASYNK/AWAIT синтаксисе. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы делаете вызов API в JavaScript?",
    answer: [" 1. XMLHttpRequest", " 2. fetch", " 3. Axios", " 4. jQuery"],
    isParagraph: true,
  },
  {
    heading: " Назовите методы запросов API, которые вы бы использовали в JavaScript.",
    answer: ["GET", "POST", "PUT", "DELETE", "PATCH"],
    isParagraph: true,
  },
  {
    heading: "Назовите различные селекторы DOM",
    answer: [
      " - getElementsByTagName()",
      " - getElementsByClassName()",
      " - getElementById()",
      " - querySelector()",
      " - querySelectorAll()",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие типы всплывающих окон есть в JavaScript?",
    answer: ["Alert", "Confirm", "Prompt"],
    isParagraph: true,
  },
  {
    heading: "Что такое оператор расширения в JavaScript?",
    answer: [
      "Оператор Spread позволяет расширять итерируемые объекты (массивы/объекты/строки) до отдельных аргументов/элементов.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функции высшего порядка в JavaScript?",
    answer: [
      "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.",
      "Функция более высокого порядка воздействует на другую функцию. Она либо принимает функцию в качестве аргумента, либо возвращает другую функцию.",
      "function higherOrderFunction(param, callback) {",
      " return callback(param)",
      "}",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Строгий режим в JavaScript?",
    answer: [
      "Строгий режим позволяет настроить программу для работы в строгом контексте. Это предотвращает выполнение определенных действий. Кроме того, возникает больше исключений.",
      "Выражение 'use strict' указывает браузеру включить строгий режим.",
      "Например: строгий режим не позволяет вам присвоить значение необъявленной переменной.",
    ],
    isParagraph: true,
  },
  {
    heading: "Зачем использовать строгий режим в JavaScript? (директива «use strict»)",
    answer: [
      "Строгий режим помогает писать «безопасный» код JavaScript. Это означает, что плохие синтаксические практики превращаются в настоящие ошибки. Например, строгий режим запрещает создание глобальных переменных. ",
      "Вот какие ограничения накладывает строгий режим:",
      "Нельзя присваивать значения или обращаться к необъявленным переменным.",
      "Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи.",
      "Нельзя удалить «неудаляемое» свойство объекта.",
      "Запрещено дублирование параметров.",
      "Нельзя создавать функции с помощью функции eval.",
      "Значением «this» по умолчанию является undefined.",
      "… и т.д.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое немедленно вызываемая функция? (IIFE)",
    answer: [
      "Немедленно вызываемая функция (IIFE) запускается сразу после определения.",
      "(function() { ... action here })()",
      "Чтобы понять, как работает IIFE, посмотрите на круглые скобки вокруг него:",
      " - Когда JavaScript видит ключевое слово function, он предполагает, что идет объявление функции.",
      " - Но объявление выше неверно, потому что у функции нет имени.",
      " - Чтобы исправить это, используется первый набор скобок вокруг объявления. Это сообщает интерпретатору, что это выражение функции, а не объявление.",
      "Затем, чтобы вызвать функцию, необходимо добавить еще один набор скобок в конце объявления функции. Это похоже на вызов любой другой функции",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функция IIFE? Самовызывающая функция.",
    answer: [
      "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})(). ",
      "(function( ) { }( )) ",
      "(function( ) { })( ) ",
      "(function named(params) { })( ) ",
      "(( ) => { }) ",
      "(function(global) { })(window) ",
      "const utility = (function( ) { return { // утилиты } })",
      "----------------- ",
      "Все эти примеры являются валидными. Предпоследний пример показывает, что мы можем передавать параметры в IIFE. Последний пример показывает, что мы можем сохранить результат IIFE в переменной. ",
      "Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает двойной восклицательный знак?",
    answer: [
      " Двойной восклицательный знак преобразует любое значение в логическое значение в JavaScript.",
      "!!true // true",
      "!!2 // true ",
      "!![] // true",
      "!!'Test' // true",
      "!!false // false",
      "!!0 // false",
      "!! '' // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Как можно удалить свойство и его значение из объекта?",
    answer: [
      "Вы можете использовать ключевое слово delete для удаления свойства и его значения из объекта.",
      "let student = {name: 'John', age: 20};",
      "delete student.age;",
      "console.log(student) // {name: 'John'};",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое глобальная переменная?",
    answer: ["Глобальная переменная доступна везде в коде."],
    isParagraph: true,
  },
  {
    heading: "Что такое события JavaScript?",
    answer: [
      "События — это то, что происходит с элементами HTML. Когда JavaScript используется на HTML-странице, он может реагировать на события, такие как нажатие кнопки.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает метод preventDefault()?",
    answer: [
      "Название preventDefault 'предотвратить дефолт' хорошо описывает поведение. Это предотвращает поведение события по умолчанию.",
      "Например, вы можете запретить отправку формы при нажатии кнопки отправки:",
      " const handleForm = (event) => {",
      " event.preventDefault()",
      " });",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое метод setTimeout()?",
    answer: [
      "Метод setTimeout() вызывает функцию (один раз) через указанное количество миллисекунд. Например, давайте зарегистрируем сообщение через одну секунду ( 1000ms ):",
      "setTimeout(function() { ",
      " console.log('Good day');",
      " }, 1000);",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое метод setInterval()?",
    answer: [
      "Метод setInterval() периодически вызывает функцию с заданным интервалом.",
      "Например, давайте периодически логировать сообщение каждую секунду:",
      " setInterval(function() {",
      " console.log('Добрый день');",
      " }, 1000);",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое ECMAScript?",
    answer: [
      "ECMAScript — это язык сценариев, лежащий в основе JavaScript. ECMAScript стандартизирован Международной организацией по стандартизации ECMA.",
      "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как можно присвоить переменной значение по умолчанию?",
    answer: [
      "Используйте логический оператор || в назначении, чтобы указать значение по умолчанию:",
      "const a = b || c;",
      "Это работает так: если b ложно, то значение c будет присвоено значению a.",
      "(Falsy означает: null, false, undefined, 0, пустую строку, NaN.)",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое функция eval()?",
    answer: [
      "Не используйте eval без необходимости!",
      "Warning: Выполнение кода JavaScript с текстовой строки - это невероятный риск для безопасности. Злоумышленнику слишком легко запустить какой угодно код, когда вы используете eval(). Смотрите Никогда не используйте eval()!, ниже.",
      "eval() - функция глобального объекта, оценивает код внутри строки. Возвращает значение выполнения кода, переданного в функцию в виде строки. Если код не возвращает ничего - будет возвращено значение undefined.",
      "Аргумент функции eval() - строка. Строка для оценки может быть выражением, переменной, оператором или последовательностью операторов. eval() исполняет содержащееся в строке выражение, один или несколько операторов JavaScript. Не стоит вызывать eval() для определения значения арифметического выражения; JavaScript вычисляет их автоматически.",
      "eval() можно использовать для вычисления значения арифметического выражения, записанного в строковом виде, на более поздней стадии исполнения. Предположим, существует переменная x. Можно отложить вычисление выражения, в котором содержится х, если присвоить переменной это выражение в виде строки (допустим, '3 * x + 2'), а затем вызвать eval() в более поздней точке кода.",
      "Если аргумент, переданный eval(), не является строкой, eval() возвращает его неизменным. В следующем примере определён конструктор String, и eval() не вычисляет значение выражения, записанного в строковом виде, а возвращает объект типа String.",
      " console.log(eval('2 + 2')); // 4",
      " console.log(eval(new String('2 + 2'))); // 2 + 2",
      " console.log(eval('2 + 2') === eval('4')); // true",
      " console.log(eval('2 + 2') === eval(new String('2 + 2'))); // false",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое регулярное выражение?",
    answer: [
      "Регулярное выражение представляет собой группу символов, образующих шаблон поиска. Это инструмент сопоставления с образцом, который обычно используется в JavaScript и других языках программирования.",
      "Регулярное выражение можно использовать для поиска адресов электронной почты или телефонных номеров в большом текстовом файле.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое условный оператор?",
    answer: [
      "Условный оператор — это сокращение для написания операторов if-else. Условный оператор иногда называют тернарным оператором.",
      "{age < 18 ? console.log('Незначительный' : console.log('Взрослый') }",
      " Условные операторы можно связать в цепочку. Иногда это может быть полезно, так как делает код более понятным.",
      " function example() {",
      " return condition1 ? value1",
      " : condition2 ? value2",
      " : condition3 ? value3",
      " : value4;",
      " }",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает метод Object.freeze()?",
    answer: [
      "Метод Object.freeze() замораживает объект, делает его неизменным. Замороженный объект больше нельзя изменить; замораживание объекта предотвращает добавление к нему новых свойств, удаление существующих свойств, предотвращает изменение перечислимости, конфигурируемости или возможности записи существующих свойств, а также предотвращает изменение значений существующих свойств. Кроме того, замораживание объекта также предотвращает изменение его прототипа. freeze() возвращает тот же объект, который был передан.",
      "const obj = { prop: 42 };",
      "Object.freeze(obj);",
      "obj.prop = 33; // Выдает ошибку в строгом режиме",
      "console.log(obj.prop); // результат: 42",
    ],
    isParagraph: true,
  },
  {
    heading: "Как получить список ключей объекта?",
    answer: [
      "Используйте Object.keys()метод.",
      "const student = { name: 'Mike', gender: 'male', age: 23 };",
      "console.log(Object.keys(student)); // ['name', 'gender', 'age']",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие примитивные типы данных есть в JavaScript?",
    answer: [
      "Примитивный тип данных имеет примитивное значение. В JavaScript существует семь различных примитивных типов данных:",
      "1. string— строковые значения. Например “John”.",
      "2. number— числовые значения. Например 12.",
      "3. boolean- правда или ложь. Например true.",
      "4. null- отсутствие значения. Например let x = null;",
      "5. undefined— тип, в котором переменная объявлена, но не имеет значения. Например, при создании переменной x таким let x;образом x становится undefined.",
      "6. bigint— Объект, предназначенный для представления целых чисел, превышающих 2^53–1. НапримерBigInt(121031393454720292)",
      "7. symbol— Встроенный объект для создания уникальных символов. Например let sym1 = Symbol(‘test’)",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие существуют способы доступа к свойствам объекта?",
    answer: [
      "Точечное обозначение: obj.property",
      "Обозначение квадратных скобок: obj['property']",
      "Обозначение выражения: obj[expression]",
    ],
    isParagraph: true,
  },
  {
    heading: "Для чего используется оператор '&&' ?",
    answer: [
      "Оператор " &&
        " (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: ",
      " - console.log( false && 1 && [] ) // false",
      " - console.log(' ' && true && 5) // 5",
    ],
    isParagraph: true,
  },
  {
    heading: " Для чего используется оператор '||'?",
    answer: [
      "Оператор || (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6. ",
      "console.log(null || 1 || undefined) // 1 ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: [
      "Согласно MDN оператор ' + '  действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое DOM?",
    answer: [
      "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. ",
      "Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. ",
      "DOM представляет собой древовидную структуру (дерево документа). ",
      "DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чем разница между методами event.preventDefault() и event.stopPropagation()? ",
    answer: [
      "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.).",
      "Метод event.stopPropagation() отключает распространение события (его всплытие или погружение). ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как узнать об использовании метода event.preventDefault()?",
    answer: [
      "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое цель события или целевой элемент (event.target)?",
    answer: [
      "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое текущая цель события (event.currentTarget)?",
    answer: ["Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий. ", " "],
    isParagraph: true,
  },
  {
    heading: "Почему результатом сравнения двух похожих объектов является false? ",
    answer: [
      "В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как записать несколько выражений в одну строку?",
    answer: [
      "Для этого мы можем использовать оператор ', ' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда. ",
      "let x = 5",
      "x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10) ",
      "function addFive(num) { return num + 5 }",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие значения в JS являются ложными?",
    answer: ["Ложными являются значения, результатом преобразования которых в логическое значение является false."],
    isParagraph: true,
  },
  {
    heading: "Как проверить, является ли значение ложным? ",
    answer: ["Следует использовать функцию Boolean или оператор '!!' (двойное отрицание)"],
    isParagraph: true,
  },
  {
    heading: "Что такое прототип объекта в JavaScript?",
    answer: [
      "В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. ",
      "const o = {} ",
      "console.log(o.toString()) // [object Object] ",
      "Несмотря на то, что объект «о» не имеет свойства toString, обращение к этому свойству не вызывает ошибки. Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype. ",
      "console.log(o.toString === Object.prototype.toString) // true ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое прототип объекта в JavaScript?",
    answer: [
      "Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__ ",
      "Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-. ",
      "К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype. ",
      "При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора. ",
      "Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    answer: [
      "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются. ",
      "Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования. ",
      "Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива: ",
      "Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback: ",
      "Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив: ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: [
      "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объект arguments?",
    answer: [
      "Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. ",
      "Запомните: в стрелочных функциях объект arguments не работает. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как создать объект, не имеющий прототипа?",
    answer: [
      "Это можно сделать с помощью Object.create: ",
      "const o1 = {} ",
      "console.log(o1.toString) // [object Object] ",
      "const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип ",
      "// нам не нужен объект-прототип, поэтому передаем null ",
      "console.log(o2.toString) // o2.toString is not a function ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему в представленном коде переменная b становится глобальной при вызове функции?",
    answer: [
      "function myFunc(){ let a = (b = 0)}",
      "myFunc() ",
      "Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a». ",
      "Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения: ",
      "function myFunc(){ ",
      " - let a, b",
      " - a = b = 0",
      "} ",
      "myFunc() ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое стрелочные функции (Arrow Functions)?",
    answer: [
      "Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:",
      "В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение: ",
      "Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки: ",
    ],
    isParagraph: true,
  },
  {
    heading: " Что такое классы (Classes)?",
    answer: [
      "Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое шаблонные литералы (Template Literals)?",
    answer: [
      "Литерал шаблонов в ES6 предоставляет новые возможности для создания строки, которая дает больше контроля над динамическими строками. Традиционно строка создается с использованием одинарных кавычек (‘) или двойных кавычек (“). Шаблонные литералы создаются с помощью двойных обратных кавычек (``):  ",
      "Синтаксис: let string = `some string` ",
      "Многострочные строки: для создания многострочной строки была использована escape-последовательность \n для обозначения символа новой строки. Однако в литералах шаблонов нет необходимости добавлять \n строка заканчивается только тогда, когда она получает символ обратной метки (`). ",
      "Выражения: Для динамического добавления значений в новые литералы шаблонов используются выражения. Синтаксис ${} допускает в нем выражение, которое выдает значение. Это значение может быть строкой, хранящейся в переменной, или вычислительной операцией. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объект Set? ",
    answer: [
      "Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue. ",
      "Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании: ",
      "const set1 = new Set() ",
      "const set2 = new Set(['a','b','c','d','d','e']) // вторая 'd' не добавится ",
      "Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может использовать цепочку вызовов: ",
      "set2.add('f') ",
      "set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая 'k' не добавится ",
      "Мы можем удалять значения из Set, используя метод delete: ",
      "set2.delete('k') // true ",
      "set2.delete('z') // false, потому что в set2 нет такого значения ",
      "Мы можем проверить наличие свойства в Set, используя метод has:",
      "set2.has('a') // true ",
      "set2.has('z') // false ",
      "Для получения длины Set используется метод size: ",
      "set2.size // 10 ",
      "Метод clear очищает Set: ",
      "set2.clear() // пусто ",
      "------------------------- ",
      "Мы можем использовать Set для удаления повторяющихся значений в массиве: ",
      "const nums = [1,2,3,4,5,6,6,7,8,8,5] ",
      "const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8] ",
    ],
    isParagraph: true,
  },
  {
    heading: "чем отличаются операторы spread и rest в JavaScript",
    answer: [
      "SPREAD (…) ",
      "Дававйте разберем вариант использования spread-оператора. Для этого достаточно представить, что массив - это контейнер.",
      "spread-оператор позволяет извлечь содержимое контейнера, не прикасаясь к нему. Кроме того, Вы сможете переместить полученное содержимое туда, куда Вам нужно. ",
      "Посмотрим на код, приведенный ниже: ",
      "const animals = [🦁, 🐘, 🐍, 🦍, 🐯] ",
      "const someOtherAnimals = [...animals]; ",
      "// someOtherAnimals теперь содержит элементы 🦁, 🐘, 🐍, 🦍, 🐯 and ",
      "// animals остается неизменным ",
      "Итак, с помощью spread-оператора мы извлекли элементы массива animals и перенесли их в массив someOtherAnimals. ",
      "акже spread-оператор можно применять для сбора данных нескольких массивов в один массив: ",
      "const wild = [🦁, 🐘, 🐍, 🦍, 🐯]; ",
      "const domestic = [🐐, 🐔, 🐱, 🐶]; ",
      "const animals = [...wild, ...domestic]; ",
      "// animals теперь содержит 🦁, 🐘, 🐍, 🦍, 🐯, 🐐, 🐔, 🐱, 🐶 ",
      "// , а wild и domestic остаются неизменными. ",
      "-------------------------------------------------",
      "REST (…) ",
      "rest-оператор позволяет представить неопределенное количество аргументов в виде массива. В отличии от spread-оператора, который извлекает элементы массива, rest-оператор (или, как его еще называют: оператор сбора) группирует множество элементов в один массив. ",
      "Посмотрим, как это работает: ",
      "const addAll = (...numbers) => { ",
      " - return numbers.reduce((acc, num) => acc + num);",
      "}; ",
      "const sum = addAll(1, 2, 3, 4); // сумма 10 ",
      "const sum1 = addAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // сумма 55 ",
      "Таким образом, мы в любом количестве собираем аргументы для параметра numbers функции addAll, после чего функция возвращает сумму этих аргументов. Этот подход позволяет нам манипулировать данными параметра numbers как обычным массивом. ",
      "Еще один пример использования rest-оператора приведен ниже: ",
      "const multiplyByNum = (multiplier, ...numbers) => { ",
      " - return numbers.map(num => num * multiplier);",
      "}; ",
      "const multiplyBy2 = multiplyByNum(2, 1, 2, 3, 4); ",
      "// multiplyBy2 [2, 4, 6, 8] ",
      "В этом случае первым параметром функции multiplyByNum является аргумент multiplier, который выступает в качестве множителя для любого количества аргументов параметра numbers. Функция возвращает массив, каждый элемент которого умножен на multiplier ",
      "-------------------------------------------------",
      "ИТОГИ ",
      "1. spread-оператор извлекает элементы массива, ",
      "2. rest-оператор собирает элементы (например, аргументы функции) в массив.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое параметры по умолчанию (Default Parameters)?",
    answer: [
      "Параметр по умолчанию-это способ установить значения по умолчанию для параметров функции, значение которых не передается (т.е.оно не определено).Если в функции параметр не передан, то его значение становится неопределенным.В этом случае компилятор применяет значение по умолчанию, которое мы задаем.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое объектная обертка (Wrapper Objects)?",
    answer: [
      "Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами: ",
      "let name = 'marko' ",
      "console.log(typeof name) // string ",
      "console.log(name.toUpperCase()) // MARKO ",
      "Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(), это приводит не к ошибке, а к «MARKO». ",
      "Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В нашем случае код принимает следующий вид: ",
      "console.log(new String(name).toUpperCase()) // MARKO",
      "Временный объект отбрасывается по завершении работы со свойством или методом.",
    ],
    isParagraph: true,
  },
  {
    heading: "Преобразование типов",
    answer: [
      "Неявное преобразование.",
      "Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия). Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу. Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.",
      "Явное преобразование. ",
      "Явное преобразование предполагает наше участие в приведении значения к другому типу.",
      "Строковое преобразование.",
      "Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. ",
      "let value = true; ",
      "alert(typeof value); // boolean ",
      "value = String(value); // преобразование в строку ",
      "alert(typeof value); // string ",
      "Численное преобразование.",
      "Численное преобразование происходит в математических функциях и выражениях.",
      "Например, когда операция деления / применяется не к числу: ",
      "alert( '6' / '2' ) // 3, строки преобразуются в числа ",
      "Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу: ",
      "let str = '123' ",
      "alert(typeof str); // string ",
      "let num = Number(str); // Численное преобразование, строка становится числом 123 ",
      "alert(typeof num); // number ",
      "Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм. Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. ",
      "let age = Number('Любая строка вместо числа'); ",
      "alert(age); // NaN, преобразование не удалось ",
      "Логическое преобразование",
      "Логическое преобразование самое простое. Происходит в логических операциях, но также может быть выполнено явно с помощью функции Boolean(value).",
      "alert( Boolean(1) ); // true ",
      "alert( Boolean(0) ); // false ",
      "alert( Boolean('Привет!') ); // true ",
      "alert( Boolean('') ); // false ",
      "Заметим, что строчка с нулём '0' — это true ",
      "alert( Boolean('0') ); // true ",
      "alert( Boolean(' ') ); // пробел это тоже true (любая непустая строка это true) ",
    ],
    isParagraph: true,
  },
  {
    heading: "Правила численного преобразования:",
    answer: [
      "Значение	Преобразуется в…  => ",
      "undefined =>	NaN ",
      "null =>	0 ",
      "true =>	1 ",
      "false => 0 ",
      "string =>	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Правило логического преобразования: ",
    answer: [
      "Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false. ",
      "Все остальные значения становятся true. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое NaN?",
    answer: [
      "NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением ",
      "console.log(parseInt('abc')) ",
      "console.log(parseInt(null)) ",
      "console.log(parseInt(undefined)) ",
      "console.log(parseInt(++a)) ",
      "console.log(parseInt({} * 10)) ",
      "console.log(parseInt('abc' - 2)) ",
      "console.log(parseInt(0 / 0)) ",
      "console.log(parseInt('10a' * 10)) ",
    ],
    isParagraph: true,
  },
  {
    heading: " Как проверить, является ли значение NaN?",
    answer: [
      "В JS есть встроенный метод isNaN, позволяющий проверять, является ли значение NaN, но он ведет себя довольно странно: ",
      "console.log(isNaN()) // true // неверно - false",
      "console.log(isNaN(undefined)) // true // неверно - false ",
      "console.log(isNaN({})) // true // неверно - false ",
      "console.log(isNaN(String('a'))) // true // неверно - false ",
      "console.log(isNaN(() => { })) // true // неверно - false ",
      "Результатом всех console.log является true, несмотря на то, что ни одно из значений не является NaN. ",
      "ES6 для проверки, является ли значение NaN, рекомендует использовать метод Number.isNaN. Мы также можем написать вспомогательную функцию для решения проблемы «неравенства NaN самому себе»: ",
      "function checkIsNan(value){ return value !== value } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как определить наличие свойства в объекте?",
    answer: [
      "Существует три способа это сделать. ",
      "1. Первый способ состоит в использовании оператора «in»: ",
      "const o = { 'prop': 'bwahahah', 'prop2': 'hweasa' } ",
      "console.log('prop' in o) // true ",
      "console.log('prop1' in o) // false ",
      "2. Второй — использовать метод hasOwnProperty:",
      "console.log(o.hasOwnProperty('prop2')) // true ",
      "console.log(o.hasOwnProperty('prop1')) // false ",
      "3. Третий — индексная нотация массива:",
      "console.log(o['prop']) // bwahahah ",
      "console.log(o['prop1']) // undefined ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое AJAX?",
    answer: [
      "AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы. ",
      "AJAX использует следующие технологии: ",
      " - HTML — структура веб-страницы.",
      " - CSS — стили веб-страницы.",
      " - JavaScript — поведение страницы и работа с DOM.",
      " - XMLHttpRequest API — отправка и получение данных с сервера.",
      " - PHP, Python, Nodejs — какой-нибудь серверный язык.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как в JS создать объект?",
    answer: [
      "1. Объектный литерал:",
      "const o = { name: 'Mark', age: 35 }",
      "2. Функция-конструктор:",
      "3. Метод Object.create:",
    ],
    isParagraph: true,
  },
  {
    heading: "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    answer: ["1. Функции обратного вызова (Callbacks)", "2. Промисы (Promises).", "3. Async/await."],
    isParagraph: true,
  },
  {
    heading: "В чем разница между обычной функцией и функциональным выражением? ",
    answer: [
      "Единственное отличие между ними только в том, что у функционального выражения может отсутствовать имя. Т.е. сразу после ключевого слова function идут круглые скобки, а в них параметры. Функциональные выражения без имени называются анонимными функциями. function funcDeclaration() {return 'Обычное объявление функции';}",
    ],
    isParagraph: true,
  },
  {
    heading: "Как в JS вызвать функцию?",
    answer: [
      "В JS существует 4 способа вызвать функцию.",
      "1. Вызов в качестве функции.",
      "Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window: ",
      "2. Вызов в качестве метода.",
      "Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода ",
      "3. Вызов в качестве конструктора.",
      "Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this. ",
      "4. Вызов с помощью методов apply или call.",
      " Мы используем эти методы, когда хотим явно определить значение this или владельца функции. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое запоминание или мемоизация (Memoization)? ",
    answer: [
      "Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Почему typeof null возвращает object? Как проверить, является ли значение null? ",
    answer: [
      "typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок) ",
      "Для проверки, является ли значение null можно использовать оператор строгого равенства (===): ",
      "function isNull(value){ return value === null } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Синхронное действие (Синхронная функция) ",
    answer: [
      "Синхронное действие — это действие, которое отправляется и немедленно обрабатывается в потоке. Обновляется состояние, и обновленное состояние немедленно становится доступным для использования компонентами. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронное действие (асинхронная функция) ",
    answer: [
      "С другой стороны, асинхронное действие — это действие, которое отправляется, но для его завершения требуется некоторое время. Асинхронные действия обычно используются при выполнении сетевых запросов или выполнении других операций, требующих времени. Эти действия не могут быть немедленно обработаны в потоке, поэтому для их выполнения требуется дополнительная логика. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Парсинг, это автоматизированный сбор и систематизация данных.",
    answer: [
      "Парсинг — автоматизированный сбор и систематизация данных. Его проводят с помощью программ, которые называются парсерами. Парсинг нужен, чтобы ускорить рутинную работу. ",
      "Парсить можно что угодно — цены конкурентов, поисковые фразы, аккаунты в соцсетях, битые ссылки. ",
      "Закон не запрещает парсинг. Но его нельзя использовать для преступлений: чтобы распространять личные данные людей, спамить, перегружать сервер сайта. ",
      "Чтобы парсить данные, можно создать парсер с нуля или использовать готовые решения. Последних много — важно найти подходящее для ваших задач. ",
      "Что такое парсинг простыми словами? Парсинг – это метод индексирования информации с последующей конвертацией ее в иной формат или даже иной тип данных. Парсинг позволяет взять файл в одном формате и преобразовать его данные в более удобоваримую форму, которую можно использовать в своих целях.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что означает компиляятор и компиляция в программировании? ",
    answer: [
      "Компиля́тор — программа, переводящая, написанный на языке программирования, текст в набор машинных кодов. ",
      "Компиля́ция — сборка программы, включающая: трансляцию всех модулей программы, написанных на одном или нескольких исходных языках программирования высокого уровня и/или языке ассемблера, в эквивалентные программные модули на низкоуровневом языке, близком машинному коду (абсолютный код, объектный модуль, иногда на язык ассемблера)... ",
      "Компиляция: это когда код, написанный на языке программирования, «переводят» в машинные команды целиком.",
    ],
    isParagraph: true,
  },
  {
    heading: "Интерпретатор (interpreter), интерпретаация ",
    answer: [
      "Интерпретатор (interpreter) — это программа, которая выполняет код, написанный на языке программирования. Она не переводит его в машинные коды целиком, а построчно принимает команды и сразу выполняет их. Можно отдать интерпретатору команду и сразу понять, сработала ли она. Это один из двух способов перевода кода в понятный компьютеру вид. Второй вариант — компиляция, когда код «переводят» в машинные команды целиком. ",
      "Интерпрета́тор — программа (разновидность транслятора), выполняющая интерпретацию. ",
      "Интерпрета́ция — построчный анализ, обработка и выполнение исходного кода программы или запроса, в отличие от компиляции, где весь текст программы, перед запуском анализируется и транслируется в машинный или байт-код без её выполнения. Первым интерпретированным языком программирования высокого уровня был Lisp.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Способы перевода кода в понятный компьютеру вид. Интерпретация, компиляция. ",
    answer: [
      "1. Интерпретация — это когда код, написанный на языке программирования, проходит построчный анализ, построчную обработку, построчно принимает команды и сразу выполняет их. ",
      "2. Компиляция: это когда код, написанный на языке программирования, «переводят» в машинные команды целиком.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое цикл событий (event loop) и как он работает?",
    answer: [
      "Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций. ",
      "Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop. ",
      "Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Фрейм в программировании, что это?",
    answer: [
      "Фрейм (от англ. frame — рамка) — отдельный законченный HTML-документ, который вместе с другими HTML-документами может быть отображён в окне браузера. ",
      "Фреймы по своей сути очень похожи на ячейки таблицы, однако более универсальны. Фреймы разбивают веб-страницу на отдельные миникадры, расположенные на одном экране, которые являются независимыми друг от друга. Каждое окно может иметь собственный адрес. При нажатии на любую из ссылок, расположенных в одном фрейме, можно продолжать видеть страницы в других окнах. ",
      "Фреймы часто использовались для навигации по веб-сайту. При этом навигационная страница располагается в одном окне, а страницы с текстом — в другом. ",
      "В настоящее время использование фреймов для публичных сайтов не рекомендовано. Главным образом это связано с принципом работы поисковых машин, которые приводят пользователя к HTML-документу, являющемуся, согласно задумке, лишь одним из фреймов того, что автору сайта хотелось бы представить. Данный недостаток фреймов устраняется средствами JavaScript.[1] ",
      "Фрейм стека-это упакованная информация, связанная с вызовом функции. Эта информация обычно включает аргументы, передаваемые функции, локальные переменные и место возврата при завершении. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Стэк - область памяти.",
    answer: [
      "Стэк - область памяти, выделенная для выполнения JavaScript движком браузера в одном потоке. ",
      "Стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работает ключевое слово this?",
    answer: [
      "В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме. ",
      "В пределах функции значение this зависит от того, каким образом вызвана функция: ",
      "1. Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply",
      "2. В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.",
      "3. Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как работают методы apply(), call() и bind()? ",
    answer: [
      "Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее. ",
      "Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply. ",
      " - Синтаксис метода call: func.call(context, arg1, arg2, ...) ",
      " - - При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).",
      " - Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.",
      " - - func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);",
      " - Синтаксис встроенного bind: var wrapper = func.bind(context, [arg1, arg2...])",
      " - - Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Promise (Промис)? ",
    answer: [
      "Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). ",
      "Синтаксис создания Promise:",
      "var promise = new Promise(function(resolve, reject) { ",
      " - - // Эта функция будет вызвана автоматически ",
      " - - // В ней можно делать любые асинхронные операции,",
      " - - // А когда они завершатся — нужно вызвать одно из:",
      " - - // resolve(результат) при успешном выполнении",
      " - - // reject(ошибка) при ошибке",
      "}) ",
      "-------------------------------------------------------------------------- ",
      "Универсальный метод для навешивания обработчиков: ",
      "promise.then(onFulfilled, onRejected) ",
      "1. onFulfilled – функция, которая будет вызвана с результатом при resolve.",
      "2. onRejected – функция, которая будет вызвана с ошибкой при reject.",
      "Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое. ",
      "Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»: ",
      "// Создаётся объект promise ",
      "let promise = new Promise((resolve, reject) => { ",
      " - setTimeout(() => { ",
      " - - // переведёт промис в состояние fulfilled с результатом 'result'",
      " - - resolve('result');",
      " -  }, 1000);",
      "}); ",
      "-------------------------------------------------------------------------- ",
      "// promise.then навешивает обработчики на успешный результат или ошибку",
      "promise ",
      " - .then(",
      " - - result => {",
      " - - - // первая функция-обработчик - запустится при вызове resolve",
      " - - - alert('Fulfilled: ' + result); // result - аргумент resolve",
      " - - },",
      " - - error => {",
      " - - - // вторая функция - запустится при вызове reject",
      " - - -  alert('Rejected: ' + error); // error - аргумент reject",
      " - -  }",
      " - );",
      "В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result». ",
      "-------------------------------------------------------------------------- ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое статический метод класса (static)?",
    answer: [
      "Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса. ",
      "Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое Set, Map, WeakSet и WeakMap? ",
    answer: [
      "В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap. ",
      "Map – коллекция для хранения записей вида ключ: значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например: ",
      "-------------------------------------------------------------------------- ",
      "'use strict'; ",
      "let map = new Map(); ",
      "map.set('1', 'str1');   // ключ-строка ",
      "map.set(1, 'num1');     // число ",
      "map.set(true, 'bool1'); // булевое значение ",
      "-- ",
      "// в обычном объекте это было бы одно и то же, ",
      "// map сохраняет тип ключа ",
      "alert( map.get(1)   ); // 'num1' ",
      "alert( map.get('1') ); // 'str1' ",
      "alert( map.size ); // 3 ",
      "-------------------------------------------------------------------------- ",
      "Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит: ",
      "-------------------------------------------------------------------------- ",
      "'use strict'; ",
      "let set = new Set(); ",
      "let vasya = {name: 'Вася'}; ",
      "let petya = {name: 'Петя'}; ",
      "let dasha = {name: 'Даша'}; ",
      "-- ",
      "// посещения, некоторые пользователи заходят много раз ",
      "set.add(vasya); ",
      "set.add(petya); ",
      "set.add(dasha); ",
      "set.add(vasya); ",
      "set.add(petya); ",
      "// set сохраняет только уникальные значения",
      "alert( set.size ); // 3 ",
      "set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша ",
      "-------------------------------------------------------------------------- ",
      "WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например: ",
      "// текущие активные пользователи ",
      "let activeUsers = [ ",
      " - {name: 'Вася'},",
      " - {name: 'Петя'},",
      " - {name: 'Маша'}",
      "]; ",
      "-- ",
      "// вспомогательная информация о них, ",
      "// которая напрямую не входит в объект юзера, ",
      "// и потому хранится отдельно ",
      "let weakMap = new WeakMap(); ",
      "weakMap.set(activeUsers[0], 1);",
      "weakMap.set(activeUsers[1], 2); ",
      "weakMap.set(activeUsers[2], 3); ",
      "weakMap.set('Katya', 4); //Будет ошибка TypeError: 'Katya' is not a non-null object ",
      "alert( weakMap.get(activeUsers[0]) ); // 1 ",
      "activeUsers.splice(0, 1); // Вася более не активный пользователь",
      "// weakMap теперь содержит только 2 элемента ",
      "activeUsers.splice(0, 1); // Петя более не активный пользователь ",
      "// weakMap теперь содержит только 1 элемент ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Разница между фундаментальными типами данных и производными типами данных. ",
    answer: [
      "В компьютерном программировании тип данных — это классификация, которая указывает компилятору или интерпретатору, какой тип данных пользователь намеревается использовать.  ",
      "Существует два типа типов данных –  ",
      "1. Примитивный/фундаментальный тип данных : каждая переменная имеет тип данных связанный с ней. Каждый тип данных требует разного объема памяти и имеет определенные операции, которые можно выполнять над ним. ",
      "2. Производный тип данных: эти типы данных определяются самим пользователем. Например, определение класса или структуры. К ним относятся массивы , структуры , класс , объединение , перечисление , указатели и т. д. ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "сматчить это полное соответствие чего-либо с чем-либо",
    answer: [
      "От англ. match (дословно — совпадать) — полное соответствие чего-либо с чем-либо. Процесс приведения к единообразию. Примеры употребления: «Этот стиль вот совсем не матчится с тем, что сейчас на проде» «Нужно сматчить эти два мока» «Отлично матчится с недавно зарелиженной фичей» Пинать. Термин, подобный глаголу «пинать», который также имеет значение «делать» и «работать». ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Синхронный код",
    answer: [
      "Синхронный код — это выполнение кода строка за строкой. Если бы мы запустили синхронную функцию задержки delay(), то движок бы ничем другим заниматься в это время не мог. То есть пока delay() не выполнится до конца, к следующей строке интерпретатор не перейдёт.",
      "А это значит, что пока не пройдёт 5 секунд, и delay() не выполнится, мы вообще ничего сделать не сможем: ни вывести что-то в консоль ещё, ни выполнить другие функции, в особо тяжёлых случаях — даже передвинуть курсор.",
      "Такие операции, которые не дают выполнять ничего кроме них самих, пока они не завершатся, называются блокирующими выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронный код",
    answer: [
      "Асинхронный код - это код, который выполняется не построчно.",
      "Асинхронный код помогает избежать блокирующие выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные события.",
    answer: [
      "Асинхронными событиями являются те, которые возникают независимо от основного потока выполнения программы, отложенные по времени.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронная функция.",
    answer: ["Асинхронная функция, это функция, которая вместо какого-то значения возвращает промис."],
    isParagraph: true,
  },
  {
    heading: "Цикл событий. (Event loop)",
    answer: [
      "Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.",
      "Вызовы из стека работают по принципу «последний зашёл, первый вышел",
      "Цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно",
      "Цикл событий берёт на себя управление тем, как должны вызываться функции Web API.",
    ],
    isParagraph: true,
  },
  {
    heading: "Очередь задач",
    answer: [
      "Очередь задач - структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым. По принципу «первый зашёл, первый вышел» ",
    ],
    isParagraph: true,
  },
  {
    heading: "Колбэк. Callback",
    answer: [
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие».",
      "В целом, событием может быть что угодно:",
      " - ответ от сервера;",
      " - завершение какой-то длительной вычислительной задачи;",
      " - получение доступа к каким-то API устройства, на котором выполняется код.",
      "Таким образом колбэк — это первый способ обработать какое-либо асинхронное действие. ",
      "Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.",
      "Это, в принципе, логично — ментальная модель достаточно простая: «выполни эту функцию, когда случится это событие». ",
      "Однако у колбэков есть неприятный минус, так называемый ад колбэков (callback hell).",
    ],
    isParagraph: true,
  },
  {
    heading: "Ад колбэков (Callback-hell) ",
    answer: [
      "Это когда у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.",
      "Если одна задача запускает другую, та — третью, и так далее, мы можем получить вот такую «башню» из обратных вызовов. И такая башня может получиться где угодно. Если мы делаем несколько последовательных запросов к серверу, зависящих друг от друга, то это может выглядеть, как нечитабельное нагромаждение кода.",
      "Читать такое сложно, не говоря уже о тестировании.",
      "Решить эту проблему были призваны Промисы (Promise).",
    ],
    isParagraph: true,
  },
  {
    heading: "Промисы (Promise)",
    answer: [
      "Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).",
      "В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.",
      "Промисы придумали, чтобы организовывать асинхронный код последовательно.",
      "Использование промисов, при решении ряда асинхронных запросов, избавляют код от лишней вложенности, делают его плоским и более тестируемым.",
      "Дополнительным плюсом стала возможность обрабатывать ошибки от цепочки промисов в одном месте — последним catch.",
      "Если что-то пошло не так, то программа не упадёт, а управление перейдёт к последней строчке с catch(), причём независимо от того, в каком из запросов ошибка появится.",
      "Также из then() можно вернуть не промис, а обычное значение. Оно обернётся в промис самостоятельно и прокинется в следующий then(): ",
      " request('/api/users/1') ",
      " - .then((user) => user.id)",
      " - .then((userId) => request(`/api/photos/${userId}/`)) ",
      " - .then((photo) => request(`/api/crop/${photo.id}/`)) ",
      " - .then((response) => console.log(response)) ",
      " - .catch((error) => console.error(error)) ",

      "Промисы оказались удобными, и появился даже такой термин как «промисификация» — когда асинхронную функциональность на колбэках превращали в промисы.",
      "Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков...  Для решения этих проблем придумали асинхронные функции.",
      " -----------------------------------------------------",
      "Promise (промис) - это объект, в который мы записываем два колбэка вместо того, чтобы передать их функции (resolve, reject).",
      "Промис - это обещание предоставить результат позже. С помощью промиса можно поставить на ожидание получение результата и, когда его получаем, можем его обрабатывать. Так же промис может вернуть ошибку, если результат вернуть не возможно. Промис может вернуть либо результат, либо ошибку. ",
      "Промис- может быть создан:",
      " - путём создания нового экземляра класса Promise ",
      " - методом fetch(), который всегда возвращает промис. ",
      " - асинхронной функцией async (), которая также всегда возвращает промис.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные функции. async",
    answer: [
      "Асинхронные функции — функции, которые возвращают промисы.",
      "Асинхронная функция помечается специальным ключевым словом async",
      "Они всегда возвращают Промис. Даже если мы явно этого не указывали, при вызове они всё равно вернут промис.",
      "Однако с асинхронными функциями можно не обращаться с then() — есть более изящное решение: async/await Скопировать ссылку на секцию ''Связка async/await''",
    ],
    isParagraph: true,
  },
  {
    heading: "Связка async/await",
    answer: [
      "Примечание: async/await является частью ECMAScript 2017 и не поддерживается в Internet Explorer и более старых браузерах, поэтому используйте их осторожностью",
      "Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await.",
      "async function loadPosts() { ",
      " - const response = await fetch('/api/posts/') ",
      " - const data = await response.json()",
      " - return data",
      " - }",
      "В примере выше мы используем метод fetch() внутри функции loadPosts(). ",
      "Все асинхронные функции внутри мы вызываем с await — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было. ",
      "------------------------------------------------",
      "Добавленное перед определением функции ключевое слово async делает функцию асинхронной. Возвращаемое значение такой функции автоматически оборачивается в Promise.",
      "Асинхронные функции нужны для выполнения асинхронных операций: работой с API, базами данных, чтения файлов и т.д. ",
      "Асинхронные операции выполняются не сразу: код отправил запрос к API и ждёт, пока сервер пришлёт ответ. Ключевое слово await используется, чтобы дождаться выполнения асинхронной операции",
      "Движок JavaScript при этом не блокируется и может выполнять другой код. Как только ответ получен, выполнение кода продолжается.",
    ],
    isParagraph: true,
  },
  {
    heading: "Главное в ASYNK/AWAIT",
    answer: [
      "1. asynk/await - синтаксическая надстройка над промисами, не более.",
      "2. await синтаксис возможен только внутри asynk (асинхронных) функций. ",
      "3. asynk (асинхронная) функция всегда возвращает Promise. В асинхронной функции мы можем использовать ключевое слово return и возвращать какой-то результат: строку, объект, число, всё, что угодно. И до момента возврата результата функции с помощью ключевого слова return, Promise, который возвращает функция, будет в состоянии ожидания (pending). И если нигде ошибок не возникло и функция дошла до ключевого слова return, то Promise, возвращённый этой функцией, будет исполнен с теми данными, которые мы возвращаем в инструкции с ключевым словом return. Если возвращаем строку (return 'строка'). то промис будет исполнен и исполнен со строкой 'строка', как данными. Или, если возвращаем объект, будет исполнен с объектом и т.д. Если где-то возникла ошибка, то промис будет отклонён с той ошибкой, которая возникла внутри асинхронной функции.",
      "4. asynk (асинхронная) функция ожидает результата инструкции await и не выполняет последующие инструкции. Это очень важно. То есть, если есть инструкция с ключевым словом asynk, дальше функция не будет выполнятся, пока Promise находится в состоянии pending (ожидания). Но при этом, JavaScript может выполнять другие задачи, например, выполнять какие-то действия при нажатии пользователем какой нибудь кнопки в интерфейсе фронт-энд приложения. То есть, это не блокирующее действие. Промис не блокирует выполнение других частей нашего приложения. И только, когда промис будет resolved или rejected, то есть - либо исполнен, либо отклонён, выполнение функции продолжится. Это главное в ASYNK/AWAIT синтаксисе.",
    ],
    isParagraph: true,
  },
  {
    heading: "Плюсы async/await",
    answer: [
      "Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.",
      "Условия и вложенные конструкции становятся чище и проще читаются.",
      "Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch: ",
      "async function loadPosts() {",
      " - try {",
      " - const response = await fetch('/api/posts/')",
      " - const data = await response.json()",
      " - return data",
      " - } catch (e) {",
      " - console.log(e)",
      " - }",
      "}",
      "При этом в отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.",
      "Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.",
    ],
    isParagraph: true,
  },
  {
    heading: "fetch(), пример запроса на пупликацию (method: 'POST')",
    answer: [
      "С помощью функции fetch() можно отправлять сетевые запросы на сервер — как получать, так и отправлять данные. Метод возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.",
      "Браузер предоставляет глобальный API для работы с запросами и ответами HTTP. Раньше для подобной работы использовался XMLHttpRequest, однако fetch() более гибкая и мощная альтернатива, он понятнее и проще в использовании из-за того, что использует Promise. ",
      "Функция fetch() принимает два параметра:",
      " - url — адрес, по которому нужно сделать запрос;",
      " - options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.",
      "По умолчанию вызов fetch() делает GET-запрос по указанному адресу. Базовый вызов для получения данных можно записать таким образом: ",
      " - fetch('http://jsonplaceholder.typicode.com/posts')",
      "Результатом вызова fetch() будет Promise, в котором будет содержаться специальный объект ответа Response. У этого объекта есть два важных для нас поля: ",
      " - ok — принимает состояние true или false и сообщает об успешности запроса;",
      " - json — метод, вызов которого, возвращает результат запроса в виде json.",
      "С помощью второго аргумента options можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Так же в запрос можно добавить заголовки в виде объекта или специального класса Headers.",
      " - const newPost = { title: 'foo', body: 'bar', userId: 1 } ",
      " -----------------------------------------------------------------",
      "fetch('https://jsonplaceholder.typicode.com/posts', { ",
      " - method: 'POST', // Здесь так же могут быть GET, PUT, DELETE",
      " - body: JSON.stringify(newPost), // Тело запроса в JSON-формате",
      " - headers: {",
      " - // Добавляем необходимые заголовки",
      " - 'Content-type': 'application/json; charset=UTF-8',",
      " - },",
      "})",
      " - .then((response) => response.json())",
      " - .then((data) => {",
      " - console.log(data)",
      " - // {title: 'foo', body: 'bar', userId: 1, id: 101}",
      " })",
    ],
    isParagraph: true,
  },
  {
    heading: "fetch(), запрос на получение данных с сервера (method: 'GET')",
    answer: [
      "fetch('https://jsonplaceholder.typicode.com/todos') ",
      ".then(response => {  ",
      "console.log(response) ",
      "return response.json() ",
      "}) ",
      " ----------------------",
      "const fetchTodos() { ",
      " try { ",
      " const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=20');",
      " if (!response.ok) { // Если у меня будет ошибка, то я её поймаю: ",
      "throw new Error('Ошибка на сервере.')",
      "}",
      "// Если ошибки нет,то.... ",
      "const date = await response.json(); ",
      "return date; ",
      "} catch (error: any) { ",
      "return error ",
      " } ",
      "}); ",
      " ----------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios",
    answer: [
      "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js. Axios предоставляет простую в использовании библиотеку в небольшом пакете с очень расширяемым интерфейсом.",
      "Axios может работать в браузере и nodejs с одной и той же кодовой базой). На стороне сервера используется собственный http модуль node.js, а на стороне клиента (браузера) — XMLHttpRequests.",
      "Установка: $ npm install axios",
      " ------------------------------",
      "Функции axios",
      "1. Делает XMLHttpRequests из браузера",
      "2. Делает http- запросы из node.js ",
      "3. Поддерживает promise API ",
      "4. Перехватывает запросы и ответы",
      "5. Преобразует данные запроса и ответа ",
      "6. Отменяет запросы ",
      "7. Автоматические преобразования для данных JSON ",
      "8. Автоматическая сериализация объектов данных multipart/form-dataи x-www-form-urlencodedкодировка тела ",
      "9. Поддержка на стороне клиента для защиты от XSRF",
      " ------------------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "const fetchAlbums = async function() {",
      " try { const response = await axios.get(",
      " `https://jsonplaceholder.typicode.com/albums?_limit=${params.limit}&_page=${params.page}`",
      " );",
      "// console.log(response); ",
      "const totalCount = response.headers['x-total-count']; ",
      "const albums = await response.data; ",
      "const res = { totalCount, albums }; ",
      "return res; ",
      " } catch (error: any) { ",
      " return error",
      " -}",
      "} ",
      ") ",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "async function getTodos() {",
      " - const { data } = await axios.get('http://someapi/todos/')",
      " - setTodos(firstTen;",
      " };",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
];

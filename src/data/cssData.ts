import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksCSS: ILinkInfo[] = [
  {
    href: "https://frontend-stuff.com/blog/styled-components/",
    title: "Что такое Styled components и как его использовать.",
  },
  {
    href: "https://www.npmjs.com/package/node-sass",
    title: "npm i node-sass",
  },
  {
    href: "https://skillbox.ru/media/code/vyravnivanie-po-tsentru-v-css-priyemy-svoystva-podvodnye-kamni/",
    title: "Выравнивание по центру в CSS: приёмы, свойства, подводные камни",
  },
  {
    href: "https://skillbox.ru/media/code/shpargalka-po-flexbox-svoystva-primery-ispolzovaniya-i-besplatnye-trenazhyery/",
    title: "Шпаргалка по Flexbox: свойства, примеры использования и бесплатные тренажёры",
  },
  {
    href: "https://habr.com/ru/articles/467049/",
    title: "Полное руководство по Flexbox. Хабр.",
  },
  {
    href: "https://skillbox.ru/media/code/uchimsya-verstat-v-setke-bolshoy-gayd-po-css-grid/",
    title: "Учимся верстать в сетке: большой гайд по CSS Grid",
  },

  {
    href: "https://meyerweb.com/eric/tools/css/reset/",
    title: "Сброс - reset CSS.",
  },
  {
    href: "https://bobbyhadz.com/",
    title: "Блог боббихадз, статьи о веб-разработке и облачных вычислениях.",
  },
  {
    href: "https://active-vision.ru/icon/box-shadow/",
    title: "CSS BOX-SHADOW ГЕНЕРАТОР",
  },
  {
    href: "https://active-vision.ru/icon/gradient/",
    title: "CSS GRADIENT ГЕНЕРАТОР",
  },
  {
    href: "https://active-vision.ru/blog/youtube-video-na-sayt/",
    title: "Добавляем YouTube видео на сайт",
  },
  {
    href: "https://ru.savefrom.net/1-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B9-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1-%D1%81%D0%BA%D0%B0%D1%87%D0%B0%D1%82%D1%8C-%D1%81-youtube-80/",
    title: "Скачать видео и музыку с Ютуба",
  },
  {
    href: "https://webstool.ru/jquery.maskedinput.html",
    title: "jQuery.Maskedinput js - маска для телефона",
  },
  {
    href: "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors",
    title: "Селекторы CSS",
  },
  {
    href: "https://htmlacademy.ru/blog/css/selectors",
    title: "Селекторы CSS по htmlacademy",
  },
  {
    href: "https://habr.com/ru/company/ruvds/blog/485640/",
    title: "Какими способами можно визуально скрыть элемент?",
  },
  {
    href: "http://htmlbook.ru/samlayout/blochnaya-verstka/strochnye-elementy",
    title: "Строчные элементы в HTML (Языке Гипертекстовой Разметки),",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/HTML/Inline_elements",
    title: "Строчные элементы по 'developer.mozilla'",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements",
    title: "Блочные элементы по 'developer.mozilla'",
  },
  {
    href: "http://htmlbook.ru/css/display",
    title: "Свойство display.",
  },
  {
    href: "http://htmlbook.ru/samlayout/blochnaya-verstka/pozitsionirovanie-elementov",
    title: "Позиционирование элементов",
  },
  {
    href: "https://itchief.ru/html-and-css/positioning-elements",
    title: "Методы позиционирования элементов в CSS",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements",
    title: "Псевдоэлемент в CSS",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-classes",
    title: "Псевдокласс в CSS",
  },
  {
    href: "https://learn.javascript.ru/size-and-scroll-window#zapretit-prokrutku",
    title: "Запретить прокрутку",
  },
  {
    href: "https://active-vision.ru/blog/polosa-prokrutki-css/",
    title: "Как стилизовать или убрать полосу прокрутки — CSS скроллбар",
  },
  {
    href: "https://ru.stackoverflow.com/questions/431590/%D0%A3%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-input-type-number",
    title: "Убрать стрелочки с input type='number'",
  },
  {
    href: "https://html5book.ru/css3-ten-bloka/",
    title: "Как сделать тень блока с помощью свойства box-shadow",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/CSS/transform",
    title: "transform Интерактивный пример",
  },
  {
    href: "https://habr.com/ru/company/ruvds/blog/493660/",
    title: "CSS: полное руководство по функции calc()",
  },
  {
    href: "https://active-vision.ru/blog/css-psevdoklass-is/",
    title: "CSS псевдокласс :is() — как и где его использовать",
  },
  {
    href: "https://active-vision.ru/blog/kak-sdelat-stupenchatuyu-animatsiyu-pri-navedenii-na-chistom-css/",
    title: "Как сделать ступенчатую анимацию при наведении курсора на чистом CSS",
  },

  {
    href: "https://materializecss.com/",
    title: "Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design.",
  },
  {
    href: "https://vk.com/@result.school-17-klassnyh-css-bibliotek",
    title: "17 классных CSS-библиотек. Подборка полезных CSS библиотек, которые помогут вам при разработке веб-сайтов",
  },
  {
    href: "https://animate.style/",
    title: "Библиотека 'Animate.css'",
  },
  {
    href: "https://css-live.ru/articles-css/display-and-formatting-contexts.html",
    title: "CSS-свойство display и контексты форматирования",
  },
  {
    href: "https://get-color.ru/code/2b2b2b ",
    title: "Информация о цвете",
  },
  {
    href: "https://nikitahl.com/style-range-input-css",
    title: "Стилизация range input. Ползунок ",
  },
];

export const linksCSSFishki: ILinkInfo[] = [
  {
    href: "https://active-vision.ru/icon/box-shadow/",
    title: "BOX-SHADOW ГЕНЕРАТОР",
  },
  {
    href: "https://active-vision.ru/icon/gradient/",
    title: "GRADIENT ГЕНЕРАТОР",
  },
];

export const linksFrameworksCSS: ILinkInfo[] = [
  {
    href: "https://www.npmjs.com/package/node-sass",
    title: "npm i node-sass",
  },
  {
    href: "https://storybook.js.org/",
    title:
      "Storybook — это мастер-класс по внешнему интерфейсу для изолированного создания компонентов и страниц пользовательского интерфейса. Тысячи команд используют его для разработки пользовательского интерфейса, тестирования и документации. Это с открытым исходным кодом и бесплатно.",
  },
  {
    href: "https://habr.com/ru/post/340384/",
    title: "Создание библиотеки компонентов с использованием Storybook",
  },
  {
    href: "https://ant.design/docs/react/introduce",
    title:
      "Ant Design of React - библиотека пользовательского интерфейса React antd, которая содержит набор высококачественных компонентов и демонстраций для создания многофункциональных интерактивных пользовательских интерфейсов.",
  },
  {
    href: "https://loading.io/css",
    title: "Pure CSS Loaders",
  },
  {
    href: "https://tailwindcss.com/docs/guides/create-react-app",
    title: "Tailwind CSS - Утилитарный CSS-фреймворк для создания любого дизайна в вашей разметке.",
  },
  {
    href: "https://www.youtube.com/watch?v=_KWNWBhR6Vc",
    title: "Tailwind CSS + React - Проект с нуля. Max Roslow.",
  },
  {
    href: "https://react-bootstrap.netlify.app/components/alerts/",
    title: "bootstrap components (компоненты)",
  },
  {
    href: "https://bootstrap-5.ru/",
    title: "Bootstrap",
  },
  {
    href: "https://react-bootstrap.github.io/getting-started/introduction/",
    title: "React-Bootstrap. npm install react-bootstrap bootstrap",
  },
  {
    href: "https://react-bootstrap-v4.netlify.app/getting-started/introduction/",
    title: "React-Bootstrap. npm install react-bootstrap bootstrap@4.6.0",
  },
  {
    href: "https://react.school/material-ui",
    title:
      "Material UI — библиотека пользовательского интерфейса React. Честно говоря, нет второй библиотеки пользовательского интерфейса для React, которую мы могли бы порекомендовать.",
  },
  {
    href: "https://v4.mui.com/ru/getting-started/installation/",
    title:
      "Инструкция по установке Material-UI, самый популярный в мире фреймворк для пользовательского интерфейса React.",
  },
  {
    href: "https://mui.com/material-ui/getting-started/overview/",
    title:
      "Material UI — это библиотека компонентов пользовательского интерфейса React, реализующая Material Design от Google.",
  },
  {
    href: "https://mui.com/material-ui/about-the-lab/",
    title:
      "О лаборатории. В этом пакете размещаются компоненты инкубатора, которые еще не готовы к перемещению в ядро.",
  },
  {
    href: "https://mui.com/",
    title: "Material UI. React. Typescript. CSS ",
  },
  {
    href: "https://github.com/mui/material-ui",
    title: "mui/material-ui",
  },
  {
    href: "https://mui.com/material-ui/react-rating/#main-content",
    title: "material-ui components (компоненты)",
  },
  {
    href: "https://www.youtube.com/watch?v=OZ_FUaV_xbg&t=6s",
    title: "Библиотека компонентов Material UI. Быстрый старт. Михаил Непомнящий.",
  },
];

export const arrayCSS: IObjectHeadingAnswers[] = [
  {
    heading: "Что такое CSS.",
    answer: [
      "Каскадная таблица стилей (CSS) формально является набором команд и инструментов для работы с внешним видом веб-страницы. Она делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. Как и в случае с языками программирования, существует множество готовых библиотек CSS, созданных профессионалами для удобства работы со стилями.",
      "HTML и CSS – два основных языка, обычно используемых для веб-разработки. Разница между HTML и CSS заключается в том, что HTML – это язык разметки, который используется для создания структуры веб-страницы, а CSS – это язык стилей, который используется для того, чтобы сделать веб-страницы более презентабельными. ",
      "Но главное то, что CSS позволяет делать сайты намного быстрее. CSS может работать с таблицами, шрифтами, изображениями и демонстрирует гораздо большие возможности, чем обычный html. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое селекторы в CSS ",
    answer: [
      "Селектор (от англ. select — выбирать) — это шаблон, который позволяет обратиться к элементу или группе элементов веб-страницы, чтобы применить к ним стили CSS. Его указывают перед блоком со свойствами: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "В примере выше селектор указывает на тег <a> (гиперссылка). Так мы говорим браузеру отключить подчёркивание у всех ссылок на странице, устанавливая для свойства text-decoration значение none. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Виды селекторов CSS",
    answer: [
      "1. Универсальный селектор * ",
      "Он применяет стили ко всем элементам страницы и обозначается символом * (звёздочка). С его помощью удобно сбрасывать отступы и задавать значение box‑sizing для всех блочных элементов: ",
      "      * { ",
      "            margin: 0;",
      "            box-sizing: border-box;",
      "      } ",
      " ",
      "2. Селектор по тегу (элементу)",
      "Этот селектор CSS применяет стили ко всем элементам с одинаковым тегом. Например, для всех <div>, <h2>, <p> и так далее. ",
      "Мы уже познакомились с ним, когда убирали подчёркивание у ссылок: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "3. Селектор по идентификатору (id)",
      "Селектор по идентификатору обозначается символом # (решётка) и применяет стили к элементу, для которого задан атрибут id с соответствующим значением. При этом у элемента может быть только один id, и этот id должен быть уникальным в пределах веб-страницы. ",
      "      <p id='intro'>Сегодня мы расскажем вам об Emmet.</p>  ",
      "      <p id='article_content'>В этой статье вы узнаете:</p> ",
      " ",
      "CSS-код: ",
      "      #intro { ",
      "            color: red;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "      #article_content { ",
      "            font-family: sans-serif;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "4. Селектор по классу (class)",
      "CSS-селектор по классу выбирает элементы, для которых назначен атрибут class с соответствующим значением. При этом один элемент может принадлежать нескольким классам — в таком случае их перечисляют через пробел: ",
      "      <p class='plain_text article'>Сегодня мы расскажем вам про Emmet.</p>  ",
      " ",
      "Абзац входит в классы plain_text и article. Значит, к нему применяются стили обоих классов: ",
      "      .plain_text{ ",
      "            font-size: 20px;",
      "      } ",
      " ",
      "      .article{ ",
      "            font-family: 'Montserrat'; ",
      "      } ",
      " ",
      "5. Группа селекторов",
      "CSS-селекторы можно сгруппировать, чтобы применить стили к нескольким группам и/или классам элементов. Для этого достаточно перечислить их через запятую: ",
      "      .plain_text, p, h1, figure, div { ",
      "            margin-top: 0;",
      "            margin-left: 0;",
      "      } ",
      " ",
      "6. Выбор элементов по отношению и расположению",
      "Есть группа селекторов, которые позволяют выбрать элемент по его отношению к другим элементами (родитель — потомок) и по расположению в DOM (Document Object Model). ",
      " ",
      "6.1. Выбрать всех потомков. ",
      "Чтобы обратиться ко всем потомкам В элемента A, независимо от уровня их вложенности, используют конструкцию A B (селекторы разделяют пробелом): ",
      "      figure img { ",
      "            margin-bottom: 20px;",
      "      } ",
      "В примере выше мы устанавливаем всем изображениям внутри элемента figure значение нижних отступов 20 пикселей. ",
      " ",
      "6.2. Выбрать потомков первого уровня",
      "Если нужно применить CSS-стили к потомкам B элемента A только на первом уровне вложенности, то вместо пробела пишут символ >:",
      "      .container > img { ",
      "            margin-bottom: 40px;",
      "      } ",
      "Здесь мы задали изображениям внутри контейнера с классом .container значение нижних отступов 40 пикселей. ",
      " ",
      "6.3. Выбрать все следующие элементы ",
      "Селектор A ~ B выбирает все элементы B, которые идут после A. Обратите внимание: «идут после», а не вложены в него. Например, так мы задали цвет фона #f2f3f5 всем карточкам, которые идут после блока из класса .about_us: ",
      "      .about_us > .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      " ",
      "6.4. Выбрать первый следующий элемент",
      "Селектор A + B выбирает только первый элемент B, который следует за A: ",
      "      .about_us + .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      "В этом примере цвет фона #f2f3f5 установится только для той карточки, которая идёт сразу после .about_us. ",
      " ",
      "7. CSS-селекторы по атрибуту",
      "Ещё один полезный инструмент — селекторы по атрибуту. Они позволяют выбрать элемент по имени атрибута, его значению или части значения. Кратко расскажем обо всех. ",
      " ",
      "7.1. [attr] ",
      "Применяет стили к элементам, для которых задан этот атрибут: ",
      "[title] { ",
      " font-weight: bold;",
      "} ",
      " ",
      "8. Псевдоклассы и псевдоэлементы",
      "Псевдокласс выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM. ",
      "Вот несколько примеров таких состояний: ",
      "    *  на кнопку наведён курсор мыши;",
      "    *  пользователь перешёл или не перешёл по ссылке;",
      "    *  курсор установлен на поле ввода.",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое специфичность селекторов CSS? ",
    answer: [
      "Если одному и тому же элементу определенно сразу несколько CSS-правил с разными селекторами, то браузер применит тот стиль, который определён по специфичности CSS-селекторов.",
      "Специфичность CSS-селекторов - это алгоритм, основанный на правилах соответствия селекторов CSS, который определяет, какие стили будут примены к данному элементу. ",
      "Специфичность селекторов по возрастанию: ",
      "     - тег и псевдоэлемент имеют специфичность 0001 ",
      "     - класс, псевдокласс, атрибут - 0010",
      "     - id имеет специфичность 0100 ",
      "     - инлайновый стиль (style=''...'') указанный в HTML-коде имеет приоритет 1000 ",
      " ",
      "1. Специфичность CSS важна только тогда, когда несколько селекторов влияют на один и тот же элемент. Браузеру нужен способ выяснить, какой стиль применять к соответствующему элементу, когда существуют противоречивые значения свойств. ",
      "2. Когда два или более совпадающих селектора имеют одно и то же значение (вес) специфичности, браузер выбирает «самый последний» совпадающий селектор, который появляется ближе к нижней части списка совпадающих селекторов. Следующий пункт объясняет, что такое «список подходящих селекторов».",
      "3. Браузер формирует «список подходящих селекторов», комбинируя все стили на веб-странице и отфильтровывая те, которые не соответствуют элементу «currently-being-styled». Первые селекторы в таблице стилей находятся вверху списка, а последние селекторы — внизу.",
      "4. Свойство style для элемента имеет большее значение специфичности, чем селекторы в таблицах стилей, за исключением случаев, когда есть !important в селекторе таблиц стилей.",
      "5. Использование !important (что в некоторых случаях считается плохой практикой) изменяет специфичность селектора. Когда два селектора имеют одинаковую специфичность, выигрывает селектор с !important. И когда они оба имеют !important, «самый последний» селектор выигрывает.",
    ],
    isParagraph: true,
  },
  {
    heading: "Фреймворки CSS.",
    answer: [
      "CSS-фреймворк — фреймворк, созданный для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки (проблемы совместимости различных версий браузеров и т. д.). Готовые к использованию классы являются их основными строительными блоками. Они позволяют применять к элементам HTML заранее определенные правила, а также включают в себя готовые компоненты (меню, кнопки, карточки). Данные фреймворки подразумевают использование различных подходов для корректного отображения сайтов на устройствах любого размера. Многие разработчики предпочитают использование CSS-фреймворков, вместо прописывания всех стилей вручную. Это обусловлено следующими причинами:",
      "    *  Более быстрая разработка ",
      "    *  Поддержка кроссбраузерности",
      "    *  Поддержка различных устройств и размеров экранов",
      "    *  Единообразие кода при работе в команде позволяет снизить число разногласий при разработке. ",
      "    *  Как и библиотеки скриптовых языков программирования, CSS-библиотеки, обычно имеющие вид внешнего CSS-файла, добавляются в заголовок веб-страницы.",
    ],
    isParagraph: true,
  },
  {
    heading: "Псевдоэлементы ::after, ::before и другие. Следует использовать двойное двоеточие (::).",
    answer: [
      "Псевдоэлемент в CSS — это ключевое слово, добавленное к селектору через знак двойного двоеточия ‘::’, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент ::first-line может быть использован для изменения шрифта первой строки абзаца.",
      "Псевдоэлементы — это элементы, которых не существует в HTML-разметке. Они создаются и позиционируются исключительно при помощи CSS. Чаще всего используются для создания различных декоративных элементов (которые не несут содержательного смысла). Также псевдоэлементы приходят на помощь, когда нужно наложить поверх картинки так называемый оверлей (перекрывающий слой). На этом польза от псевдоэлементов не заканчивается. ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Псевдоклассы :hover, :visited, :checked и другие. Следует использовать одинарное двоеточие (:).",
    answer: [
      "1. Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши. ",
      "Псевдоклассы — особый вид селектора, который уточняет тип или состояние. Обычно это какой-то качественный признак: реакция на наведение курсора, порядок следования и другие.",
      "Псевдокласс — это ключевое слово, добавленное к селектору через знак двоеточия ‘:’, которое позволяет стилизовать элемент: ",
      "    -  на основе отношений в DOM-дереве,",
      "    -  истории посещений (например, :visited),",
      "    -  состоянии содержимого (вроде :checked у некоторых элементов формы)",
      "    -  или позиции курсора мыши (например, :hover определяет, находится ли курсор мыши над элементом)... ",
      " ",
      "2. В CSS псевдоклассы используются для описания стилей элементов, находящихся в особых состояниях. Псевдоклассы можно использовать совместно с CSS-селекторами для настройки внешнего вида элементов на основе их состояний. ",
      " ",
      "Вот примеры: ",
      " ",
      "2.1. Любой элемент <a>, на который пользователь наведёт указатель мыши, будет окрашен в цвет. ",
      " ",
      "      a:hover { ",
      "            color: green;",
      "      } ",
      " ",
      "2.2. Выбирает все посещённые элементы <a> и окрашивает их в цвет purple.  ",
      "      a:visited { ",
      "            color: purple;",
      "      } ",
      " ",
      "3. Список некоторых стандартных псевдоклассов.",
      "    -  :active ",
      "    -  :checked ",
      "    -  :default ",
      "    -  :disabled ",
      "    -  :first ",
      "    -  :first-child ",
      "    -  :first-of-type ",
      "    -  :nth-child() ",
      "Их много... ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как задать элементу определенные стили при наведении, при нажатии, при фокусе?",
    answer: [
      "при наведении - с помощью псевдокласса hover ",
      "при нажатии - с помощью псевдокласса active ",
      "при фокусе - с помощью псевдокласса focus ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "У вас есть список покупок. Каждому второму элементу списка необходимо задать синий фон. Как это можно сделать используя псевдоселекторы ",
    answer: ["С помощью псевдокласса tr:nth-child(even) или tr:nth-child(2n) (чётные строки HTML)", " "],
    isParagraph: true,
  },
  {
    heading: "Рассмотрим самые популярные CSS-фреймворки.",
    answer: [
      "    *  Styled Component",
      "https://frontend-stuff.com/blog/styled-components/",
      "    *  Bootstrap",
      "https://getbootstrap.com/",
      "    *  Material Design for Bootstrap",
      "https://mdbootstrap.com/docs/standard/",
      "    *  Materialize. Современный отзывчивый интерфейсный фреймворк на основе Material Design.",
      "https://materializecss.com/",
      "    *  Bulma",
      "https://bulma.io/",
      "    *  Pure",
      "https://purecss.io/",
    ],
    isParagraph: true,
  },
  {
    heading: "Какая разница между селекторами идентификаторов и классов в CSS?",
    answer: [
      "Идентификаторы (id) уникальны. У элемента может быть только один идентификатор. На странице может присутствовать лишь один элемент с конкретным идентификатором.",
      "Имена классов (class) не являются уникальными. Один и тот же класс можно назначать множеству элементов. Элементу может быть назначено несколько классов.",
      "Если некий стиль нужно применить к нескольким элементам страницы — эту задачу нужно решать с использованием классов.",
    ],
    isParagraph: true,
  },
  {
    heading: "Как пользоваться медиазапросами @media в CSS?",
    answer: [
      "Медиа-запросы (media queries) – это правила CSS, которые позволяют управлять стилями элементов в зависимости от значений технических параметров устройств. Иными словами, это конструкции, которые позволяют определять на основании некоторых условий какие стили необходимо использовать на веб-странице, а какие нет.  ",
      "Например, при увеличении размера экрана гаджета, у элемента с селектором класса 'footer' меняются значения паддингов и исчезает border-top:",
      " ",
      "   .footer { ",
      "      width: 100%;",
      "      max-width: 1920px;",
      "      padding: 24px 24px 32px;",
      "      border-top: 1px solid #e4e4e4;",
      " ",
      "      @media (min-width: 576px) {",
      "         padding: 48px 28px 32px;",
      "         border-top: none;",
      "      }",
      "   } ",
      " ",

      "Медиа-запросы @media позволяют задавать различные стили элементам, компонентам вэб-приложения для определенного размера экрана, типа устройства, где данное вэб-приложение просматривается или используется. Все медиа-запросы начинаются с @media, а далее следует условие. ",
      "С помощью медиа-запросов можно задать стили для следующих типов устройств: ",
      "    -  all — все типы (значение используется по умолчанию)",
      "    -  braille — устройства, основанные на системе Брайля, которые предназначены для чтения слепыми людьми",
      "    -  embossed — принтеры, использующие для печати систему Брайля ",
      "    -  handheld — смартфоны и аналогичные им аппараты",
      "    -  print — принтеры и другие печатающие устройства",
      "    -  projection — проекторы",
      "    -  screen — экран монитора",
      "    -  speech — речевые синтезаторы, а также программы для воспроизведения текста вслух",
      "    -  tty — устройства с фиксированным размером символов",
      "    -  tv — телевизоры.",
    ],
    isParagraph: true,
  },
  {
    heading: "reset - «сброс», Normalize - «нормализация». В чем разница между ними?",
    answer: [
      "Сброс (reset) сбрасывает все дефолтно-браузерные стили HTML-элементов.",
      "Normalize приводит стили к единому виду во всех браузерах.",
      "Цели normalize.css: ",
      " - сохранять полезные настройки браузера, а не стирать их;",
      " - нормализовать стили для широкого круга HTML-элементов;",
      " - корректировать ошибки и несоответствия браузера;",
      " - совершенствовать юзабилити незаметными улучшениями;",
      " - объяснять код, используя комментарии и детальную документацию.",
      " Из-за кроссбраузерности следует выбирать Normalize, но я пользуюсь reset",
    ],
    isParagraph: true,
  },
  {
    heading: "Как вы решаете стилевые проблемы, связанные с особенностями браузеров?",
    answer: [" - Использую normalize или reset CSS", " - Использую автопрефиксы (autoprefixer)"],
    isParagraph: true,
  },
  {
    heading: "floats, как они работают",
    answer: [
      "При применении этого свойства происходит следующее:",
      " 1. Элемент позиционируется как обычно, а затем вынимается из потока документа и сдвигается влево (для left) или вправо (для right) до того как коснётся либо границы родителя, либо другого элемента с float. ",
      " 2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться. ",
      " 3. Другие непозиционированные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из потока.  ",
      " 4. Строки (inline-элементы), напротив, «знают» о float и обтекают элемент по сторонам.",
    ],
    isParagraph: true,
  },
  {
    heading: "свойство z-index",
    answer: [
      "Позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы. Их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative (абсолютное, фиксированное или относительное).",
      " - Элементы с большим z-index перекрывают элементы с меньшим. ",
      " - При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML написан ниже.",
      " - Если свойства z-index и позиционирование не заданы явно, то порядок наложения равен порядку следования элементов в HTML.",
    ],
    isParagraph: true,
  },
  {
    heading: "Эффективый CSS, на что обратить внимание?",
    answer: [
      "Для написания эффективного CSS должна быть система. Я использую модификацию БЭМ и препроцессор SASS. Код можно переиспользовать.",
      "Для работы в react, лично для себя, я бы отметил использование CSS - модуля с типизацией. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какими способами можно визуально скрыть элемент?",
    answer: [
      "Элементы, невидимые на странице, могут пребывать в различных состояниях:",
      " - Некий элемент совершенно невидим и, более того, удалён из потока документа.",
      " - Глазами элемент не увидеть, но он присутствует в документе и доступен для ассистивных технологий наподобие средств для чтения с экрана.",
      " - Элемент видим, но скрыт от средств для чтения с экрана.",
    ],
    isParagraph: true,
  },
  {
    heading: "1. HTML5-атрибут hidden ",
    answer: [
      "Hidden — это логический HTML-атрибут, скрывающий элементы, которым он назначен. Когда браузер загружает страницу, он не выведет элементы с атрибутом hidden, за исключением тех случаев, когда видимость элементов будет включена вручную средствами CSS.",
      "<img hidden src=''landscape.jpg'' /> ",
      "Вот CSS-код, который здесь использован:  ",
      " - 1. img[ hidden ] { display: none }",
      " - 2. @media ( min-width: 400px ) { img[ hidden ] { display: block }}",
      "Если рассмотреть 'атрибут hidden' с точки зрения доступности контента, то окажется, что этот атрибут полностью скрывает элемент. В результате с этим элементом не смогут работать средства для чтения с экрана. Не используйте этот атрибут в тех случаях, когда некие элементы страниц нужно делать невидимыми для человека, но не для программ для чтения с экрана. ",
    ],
    isParagraph: true,
  },
  {
    heading: "2. CSS-свойство display",
    answer: [
      " - 1. img { display: none } ",
      " - 2.  @media ( min-width: 400px ) {img { display: block }} ",
      "При использовании свойства 'display: none' элемент становится невидимым и, кроме того, недоступным для средств чтения с экрана. ",
    ],
    isParagraph: true,
  },
  {
    heading: "3. CSS-свойство opacity",
    answer: [
      " - 1. img { opacity: 0 }  ",
      "Элемент, скрытый с помощью opacity: 0, остаётся доступным для средств чтения с экрана. Такой элемент может получить фокус при работе со страницей с помощью клавиатуры. ",
    ],
    isParagraph: true,
  },
  {
    heading: "4. CSS-свойство visibility",
    answer: [
      " - 1. article { visibility: hidden }",
      " - 2. img {  visibility: visible } ",
      "При применении свойства visibility: hidden элемент оказывается скрытым. Он, кроме того, удаляется из дерева доступности и, в результате, его не замечают средства для чтения с экрана. ",
    ],
    isParagraph: true,
  },
  {
    heading: "5.Скрытие элементов и позиционирование",
    answer: [
      " - .container { position: absolute; top: -100%; (left: -100%); (right: -100%); }",
      " - .container:focus { position: absolute; top: 0; (left: 0); (right: 0); }",
      "Элемент, выведенный за пределы области просмотра, доступен для средств чтения с экрана, добраться до него можно и с помощью клавиатуры. Он лишь оказывается невидимым при обычной работе со страницей.",
    ],
    isParagraph: true,
  },
  {
    heading: "6. Размеры компонента",
    answer: ["width: 0px; height: 0px;"],
    isParagraph: true,
  },
  {
    heading: "7. CSS-свойство clip-path",
    answer: [
      "Если к элементу применяется CSS-свойство clip-path — оно позволяет описать область, определяющую то, какая часть элемента должна быть скрытой, а какая — видимой.",
      " -  img { clip-path: circle(0 at 50% 50%) }",
      "Элемент, к которому применено свойство clip-path, скрыт лишь визуально. До него можно добраться с помощью клавиатуры, он доступен для программ чтения с экрана.",
    ],
    isParagraph: true,
  },
  {
    heading: "8. Манипуляции с цветом текста и с размером шрифта",
    answer: [
      "Хотя скрытие текста путём изменения его цвета или размеров шрифта распространено не так широко, как ранее рассмотренные методики скрытия элементов, в некоторых случаях это может пригодиться.",
    ],
    isParagraph: true,
  },
  {
    heading: "9. Настройка прозрачности цвета",
    answer: [
      "Если использовать для текста прозрачный цвет, то этот текст окажется невидимым. Это может оказаться полезным при создании кнопок, на которых используются только значки.",
    ],
    isParagraph: true,
  },
  {
    heading: "10. Настройка размера шрифта",
    answer: ["Кроме того, если установить размер шрифта в значение 0, это тоже позволит скрыть текст."],
    isParagraph: true,
  },
  {
    heading: "Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?",
    answer: ["Использовал сетку Bootstrap, CSS grid, флекс. Предпочитаю флекс."],
    isParagraph: true,
  },
  {
    heading: "Что такое блочный контекст форматирования?",
    answer: [
      "Блочный контекст форматирования — это отображение и взаимодействие компонентов веб-страницы в привычном для блоков порядке.",
      "Блочный контекст форматирования могут создать: ",
      "    *  блочные HTML-элементы",
      "    *  float-элементы, флекс-элементы, грид-элементы",
      "    *  позиционированные элементы",
      "    *  «строчные блоки» (элементы с display: inline-block)",
      "    *  ячейки, анонимные ячейки, заголовки таблицы ",
    ],
    isParagraph: true,
  },
  {
    heading: "Строчная модель. Строчные элементы в HTML (Языке Гипертекстовой Разметки)",
    answer: [
      "Строчные элементы, это те, которые занимают только то пространство, которое ограничено тегами, определяющими строчный элемент (необходимое для отображения их содержимого) и не нарушая потока содержимого (не требующее новой строки после каждого элемента).",
      "Строчный элемент не начинается с новой строки, в ширину занимает столько места, сколько это необходимо для его отображения.",
    ],
    isParagraph: true,
  },
  {
    heading: "img это блочный или строчный элемент?",
    answer: [
      "Несмотря на то, что у изображения есть ширина и высота и визуально это большой прямоугольник, изображение не является блочным элементом HTML, на самом деле это строчный элемент. ",
      "Это связано с элементом <img>, являющимся самозакрывающимся элементом: технически он не может содержать любой другой элемент HTML и, таким образом, считается строчным элементом, таким как <a>, <strong> или <em>. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между строчным, блочным и блочно-строчным элементом?",
    answer: [
      "    *  Блочные элементы (display: block)",
      " ",
      "Блочные элементы в отличие от строчных элементов занимают по умолчанию всю ширину блока-контейнера, в которую они помещены. По этому признаку можно легко определить, к какому способу отображения относится элемент. Высота блочного элемента по умолчанию определяется автоматически и зависит от содержимого, которое в него помещено. Блочный элемент можно представить как прямоугольник, который имеет ширину (width) и высоту (height). Ширину и (или) высоту блочного элемента можно задавать вручную с помощью CSS свойств width и (или) height. Также блочные элементы имеют границы, которые можно оформлять с помощью стилей CSS. Кроме этого блочным элементам можно задавать отступы внешние и внутренние. Внешний отступ (margin) – это отступ от границы до элемента контейнера или до соседних блочных элементов. Внутренний отступ (padding) – это отступ для содержимого блока, который задаётся от границы. ",
      "Блочные элементы могут содержать строчные элементы и другие блочные элементы, для которых их родитель будет являться контейнером. Блочные элементы предназначены для разработки каркаса веб-страницы, разметки больших блоков текста и много другого. ",
      " ",
      "    *  Строчные элементы (display: inline) ",
      " ",
      "Строчными называются такие элементы, которые являются непосредственной частью строкии занимают такое количество пространства, которое необходимо для отображения их содержимого. У них значение свойства display: inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
      "Строчным элементам нельзя установить размеры (width и height), задать верхние и нижние margin отступы. ",
      "Для строчного элемента, размещенного на одной линии, можно использовать padding, margin-left и margin-right, border. ",
      " ",
      "    *  Строчно-блочные элементы (display: inline-block )",
      "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
      "div { display: inline-block } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Строчный элемент - 'inline' ",
    answer: [
      "    *  Размер зависит от контента.",
      "    *  Ширину и высоту задавать нельзя.",
      "    *  Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит - от line-height.",
      "    *  Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.",
      " ",
      "Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено.",
      "Эффект схлопывания отступов не действует. ",
      "Свойства, связанные с размерами (width, height) не применимы.",
      "Ширина равна содержимому плюс значения отступов, полей и границ.",
      "Несколько строчных элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.",
      "Можно выравнивать по вертикали с помощью свойства vertical-align.",
    ],
    isParagraph: true,
  },
  {
    heading: "Блочный элемент - 'block' ",
    answer: [
      "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. ",
      "Такой элемент занимает всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.",
      "К блочным элементам относятся контейнеры div, h1, form и др ",
      "Блочная модель отвечает за определение того, сколько места займет блочный элемент, схлопнутся или нет border или margin, размеры блока. ",
      "Размеры блочного элемента складываются из width, height, padding, border и margin. ",
      "Если высота (height) блока не задана, то высота блока равна: высота контента этого блока + padding'и.",
      "Если ширина блока не задана, то блоки, для которых не задано float, будут иметь ширину: ширина родителя - padding'и родителя.",
      " ",
      "    *  Начинается с новой строки родительского элемента и занимает всю строку. ",
      "    *  Можно задавать ширину и высоту. ",
      "    *  Можно выровнять с помощью vertical-align.",
      "    *  Margins и paddings работают со всех сторон.",
      " ",
      "Блоки располагаются по вертикали друг под другом.",
      "На прилегающих сторонах элементов действует эффект схлопывания отступов. ",
      "Запрещено вставлять блочный элемент внутрь строчного. Например, <a><h1>Заголовок</h1></a> не пройдёт валидацию, правильно вложить теги наоборот — <h1><a>Заголовок</a></h1>. ",
      "По ширине блочные элементы занимают всё допустимое пространство. ",
      "Если задана ширина контента (свойство width), то ширина блока складывается из значений width, полей, границ, отступов слева и справа.",
      "Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.",
      "Если задана высота контента (свойство height), то высота блока складывается из значения height, полей, границ, отступов сверху и снизу. При превышении указанной высоты контент отображается поверх блока. ",
      "На блочные элементы не действуют свойства, предназначенные для строчных элементов, вроде vertical-align. ",
      "Текст по умолчанию выравнивается по левому краю.",
    ],
    isParagraph: true,
  },
  {
    heading: "Блочно-строчный элемент - 'inline-block' ",
    answer: [
      "    *  Размер зависит от контента.",
      "    *  Можно задавать ширину и высоту.",
      "    *  Можно выровнять с помощью vertical-align.",
      "    *  Margins и paddings работают со всех сторон. ",
      " ",
      "Внутрь строчно-блочных элементов допустимо помещать текст, строчные или блочные элементы. ",
      "Высота элемента вычисляется браузером автоматически, исходя из содержимого блока. ",
      "Ширина равна содержимому плюс значения отступов, полей и границ.",
      "Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости. ",
      "Можно выравнивать по вертикали с помощью свойства vertical-align. ",
      "Разрешено задавать ширину и высоту. ",
      "Эффект схлопывания отступов не действует. ",
      " ",
      "Пример использования:",
      "http://htmlbook.ru/samlayout/blochnaya-verstka/strochno-blochnye-elementy",
    ],
    isParagraph: true,
  },
  {
    heading: "Что делает * { box-sizing: border-box; }? В чём его преимущества?",
    answer: [
      "Свойство box-sizing определяет как вычисляется общая ширина и высота элемента. По умолчанию все элементы имеют box-sizing: content-box. - `content-box`. Если мы задаём элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а финальная ширина элемента, в этом случае, увеличится на сумму отступов и толщину бордера. ",
      "Значение свойства `border-box` говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Контексты форматирования в CSS.",
    answer: [
      "Контекст форматирования представляет собой видимую область, которая отображается на веб-странице с раскладкой контента по определённым правилам (блочного, строчного, флексового контекста форматирования). ",
      " ",
      "    *  Инлайновый.",
      "Нужен для форматирования текста и всего, что находится прямо в нем. ",
      "«Участники»: элементы строки (текст, картинки, кнопки, инлайн-блоки, инлайн-таблицы и т.д.).  ",
      "Всё «воспринимается как текст», напр., пробелы в коде часто отображаются как символы. Сложные правила вертикального выравнивания. ",
      " ",
      "    *  Блочный.",
      "Нужен для оформления блоков текста (с отступами и врезками).",
      "«Участники»: блочные боксы (в т.ч. анонимные), float-ы.",
      "«Схлопывание» margin-ов, «проваливание» float-ов через верхние и нижние границы блоков, влияние float-ов в пределах контекста друг на друга. Не-блочные элементы неявно оборачиваются в анонимные блоки. Мало средств для выравнивания/центрирования по вертикали. ",
      " ",
      "    *  Табличный.",
      "Нужен для представления табличных и «таблицеподобных» данных, изредка полезен и для раскладки блоков. ",
      "«Участники»: Ячейки, строки, группы строк (как thead/tbody/etc.) и всё такое, в т.ч. анонимные. ",
      "Иерархия табличной структуры (в строке могут быть только ячейки и т.п.), для недостающих элементов иерархии создаются анонимные обертки соотв. типа. Сложные и плохо документированные алгоритмы расчета размеров. ",
      " ",
      "    *  Флексовый.",
      "Нужен для «гибкой» раскладки и взаимного выравнивания блоков с контентом, в т.ч. для динамичных и адаптивных макетов и их частей. ",
      "«Участники»: флекс-элементы (во флекс-контейнере).",
      "Меняет поведение непосредственных потомков элемента, задающего этот контекст. В частности, свойство float игнорируется. Создает анонимные флекс-обертки для текста, оказавшегося непосредственно в контейнере. ",
      " ",
      "    *  Гридовый (сеточный).",
      "Нужен для расположения блоков в соответствии с заданным «каркасом» страницы или интерфейса.",
      "«Участники»: грид-элементы (в грид-контейнере).",
      "Практически полная независимость порядка отображения элементов от порядка в коде. Элементы могут влиять друг на друга сразу по двум направлениям. Создает анонимные грид-обертки для текста, оказавшегося непосредственно в контейнере. ",
      " ",
      "    *  Ruby. ",
      "Подсказки для чтения текста иероглифами.",
      "«Участники»: иероглифы основного текста и ruby-подсказки к нему.",
      "Вряд ли встретится вам, если вы не будете верстать учебники китайского или японского… но кто знает! ",
    ],
    isParagraph: true,
  },
  {
    heading: "Свойство display определяет тип отображения элемента, как элемент должен быть показан в документе.",
    answer: [
      "По умолчанию почти все элементы в HTML имеют блочный и строчный тип отображения.",
      " ",
      "    *  none - элемент не показывается, вообще. Как будто его и нет.",
      "    *  block - блочные элементы располагаются вертикально один над другим. Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно. Это значение`display`многие элементы имеют по умолчанию:`div` , заголовок`h1,`параграф`p.` ",
      "    *  inline-элементы располагаются на одной строке, последовательно. Ширина и высота элемента определяются по содержимому. Поменять их нельзя.",
      "    *  inline-block - элемент продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока, ему можно указать ширину и высоту явно. ",
      "    *  flex - это свойство, при котором элемент растягивается или сжимается для заполнения собой свободного пространства. ",
      "    *  inline-flex - похоже на флекс, только элементы будут растягиваться или сжиматься инлайново (в строку) для заполнения собой свободного пространства. ",
      "    *  table - Для таблицы целиком`table`, для строки –`table-row`, для ячейки –`table-cell`и т.д. ",
      "    *  grid - Элемент ведет себя как блочный элемент и размещает свое содержимое в соответствии с моделью сетки .",
      "    *  flow - Элемент размещает свое содержимое с использованием потоковой компоновки (блочной и встроенной компоновки).",
      "    *  flow-root - Элемент создает блок-бокс, который устанавливает новый контекст форматирования блока , определяя, где находится корень форматирования.",
      "    *  ruby - Элемент ведет себя как элемент встроенного уровня и размещает свое содержимое в соответствии с моделью форматирования ruby. Он ведет себя как соответствующие <ruby>элементы HTML.",
      "И ещё много, много.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?",
    answer: [
      "Позиционированием называется положение элемента в системе координат. Различают четыре типа позиционирования: нормальное, абсолютное, фиксированное и относительное. В зависимости от типа, который устанавливается через свойство position, изменяется и система координат.",
      "Благодаря комбинации свойств position, left, top, right и bottom элемент можно накладывать один на другой, выводить в точке с определёнными координатами, фиксировать в указанном месте, определить положение одного элемента относительно другого и др. Подобно другим свойствам CSS управление позиционированием доступно через скрипты. Таким образом, можно динамически изменять положение элементов без перезагрузки страницы, создавая анимацию и различные эффекты.",
      " ",
      " - static - Статическое позиционирование — это режим позиционирования, применяемый по умолчанию, при использовании которого элементы выводятся в том порядке, в котором они описаны в документе. Свойства top, right, bottom, left и z-index не применяются.",
      " - relative - Относительное позиционирование — это когда элемент смещается относительно своего положения, задаваемого по умолчанию на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов.",
      " - absolute - Абсолютное позиционирование - элемент выдёргивается из потока (не существует в потоке, его место занимают другие элементы). Элемент со свойством position: absolute позиционируется относительно своего ближайшего позиционированного предка. Это означает, что для того, чтобы абсолютное позиционирование сработало, родительский элемент должен иметь заданное значение свойства position, причем не static. Если ближайший родительский элемент не имеет указанного свойства position, элемент с абсолютным позиционированием будет позиционироваться относительно следующего в иерархии родительского элемента, имеющего это свойство. Если у элемента вообще не будет позиционированных предков, он будет позиционироваться относительно элемента html или viewport. Абсолютно спозиционированные элементы могут иметь margin и padding и не схлопываются с margin и padding других элементов. Никак не влияют на другие элементы.",
      " - fixed - Фиксированное позиционирование — это когда настраивают положение элемента, ориентируясь на края окна браузера. Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. С помощью top, bottom и т.д. его можно прибить соответственно сверху, снизу и т.п.. Остаётся на позиции относительно окна документа и не меняет положение при скроле.",
      " - sticky - смесь relative и fixed. Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент. Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow)",
      " ",
      " - inherit - Значение должно быть унаследовано от элемента родителя",
    ],
    isParagraph: true,
  },
  {
    heading: "Абсолютное позиционирование",
    answer: [
      "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью»",
      "Для режима характерны следующие особенности. ",
      " - Ширина слоя, если она не задана явно, равна ширине контента плюс значения полей, границ и отступов.",
      " - Слой не меняет своё исходное положение, если у него нет свойств right, left, top и bottom.",
      " - Свойства left и top имеют более высокий приоритет по сравнению с right и bottom. Если left и right противоречат друг другу, то значение right игнорируется. То же самое касается и bottom",
      " - Если left задать отрицательное значение, то слой уйдёт за левый край браузера, полосы прокрутки при этом не возникнет. Это один из способов спрятать элемент от просмотра. То же относится и к свойству top, только слой уйдёт за верхний край.",
      " - Если left задать значение больше ширины видимой области или указать right с отрицательным значением, появится горизонтальная полоса прокрутки. Подобное правило работает и с top, только речь пойдёт о вертикальной полосе прокрутки.",
      " - Одновременно указанные свойства left и right формируют ширину слоя, но только если width не указано. Стоит добавить свойство width и значение right будет проигнорировано. Аналогично произойдёт и с высотой слоя, только уже участвуют свойства top, bottom и height.",
      " - Элемент с абсолютным позиционированием перемещается вместе с документом при его прокрутке.",
      "Свойство position со значением absolute можно использовать для создания эффекта фреймов. Кроме абсолютного позиционирования для элементов необходимо назначить свойство overflow со значением auto. Тогда при превышении контентом высоты видимой области появится полоса прокрутки. Высота и ширина «фреймов» формируется автоматически путём одновременного использования свойств left, right для ширины и top, bottom для высоты ",
      " - В браузере IE6 для абсолютно позиционированных элементов нельзя одновременно задать свойства left, right и top, bottom.",
      "Абсолютное позиционирование также применяется для создания различных эффектов, например, всплывающей подсказки к фотографиям. В отличие от атрибута title тега <img> который также выводит текст подсказки, через стили можно управлять видом текста выводимого с помощью скрипта. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Фиксированное положение",
    answer: [
      "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю",
    ],
    isParagraph: true,
  },
  {
    heading: "Относительное позиционирование",
    answer: [
      "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. ",
      "Свойства bottom и right производят обратный эффект. При положительном значении right сдвигает элемент влево от его правого края, при отрицательном — сдвигает вправо (рис. 3.47). При положительном значении bottom элемент поднимается вверх, при отрицательном опускается вниз.",
      "Для относительного позиционирования характерны следующие особенности ",
      " - Этот тип позиционирования не применим к элементам таблицы вроде ячеек, строк, колонок и др.",
      " - При смещении элемента относительно исходного положения, место, которое занимал элемент, остаётся пустым и не заполняется ниже или вышележащими элементами.",
    ],
    isParagraph: true,
  },
  {
    heading: "sticky - смесь relative и fixed.",
    answer: [
      "Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент.",
      "Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow) ",
    ],
    isParagraph: true,
  },
  {
    heading: "Вложенные слои",
    answer: [
      "Обычно относительное позиционирование само по себе применяется не часто, поскольку есть ряд свойств выполняющих фактически ту же роль, к примеру, тот же margin. Но сочетание разных типов позиционирования для вложенных слоёв является одним из удобных и практичных приёмов вёрстки. Если для родительского элемента задать relative, а для дочернего absolute, то произойдёт смена системы координат и положение дочернего элемента при этом указывается относительно его родителя ",
      "Отсчёт координат ведётся от внутреннего края границы, значения полей не учитываются",
      "Благодаря использованию четырёх свойств left, right, top, bottom для управления положением внутреннего слоя, размеры родительского слоя знать не обязательно. Это расширяет сферу применения позиционирования, поэтому position довольно активно применяется при вёрстке различных элементов.  ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Использование CSS препроцессоров? Опишите, что вам нравится и не нравится в CSS препроцессорах, которыми вы пользовались. ",
    answer: [" Преимущества: ", " - Вложенность. Удобно писать по БЭМу. ", " - Переменные."],
    isParagraph: true,
  },
  {
    heading: "1. Центрирование блочного элемента ",
    answer: [
      "Задать родителю (display: flex) ",
      "  .container { display: flex }",
      "Задать дочернему флекс-элементу (margin: auto).",
      "  .child { margin: auto }  ",
    ],
    isParagraph: true,
  },
  {
    heading: "2. Центрирование блочного элемента",
    answer: [
      "Задать контейнеру-родителю: .container { display: flex;  align-items: center;  justify-content: center; }",
    ],
    isParagraph: true,
  },
  {
    heading: "3. Центрирование блочного элемента по горизонтали",
    answer: [".child { width: 123px; margin: 12px auto }"],
    isParagraph: true,
  },
  {
    heading: "Центрирования инлайновых элементов ",
    answer: ["По горизонтали: h1 {text-align: center}", "По вертикали: h1 {vertical-align: middle} ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: "Выравнивание инлайновых элементов с помощью line-height ",
    answer: [
      "Если известно, что внутренний блок должен занимать не более одной строки текста, то можно воспользоваться свойством line-height и задать его равным высоте внешнего блока. Поскольку контент внутреннего блока не должен переноситься на вторую строку, рекомендуется также добавить правила white-space: nowrap и overflow: hidden. ",
      " - .container { height: 200px; line-height: 200px }",
      " - .child { white-space: nowrap; overflow: hidden }",
    ],
    isParagraph: true,
  },
  {
    heading: "Выравнивание многострочного текста",
    answer: [
      " .container { height: 200px; line-height: 200px }",
      " .child { line-height: normal; display: inline-block; vertical-align: middle } ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "1. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью ''растягивания'' ",
    answer: [
      "Данный способ можно применять, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
      "Для этого нужно: ",
      " - 1. задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное;",
      " - 2. добавить внутреннему блоку правила top: 0 и bottom: 0, в результате чего он растянется на всю высоту внешнего блока;",
      " - 3. установить значение auto для вертикальных отступов внутреннего блока.",
      " .container { position: relative }",
      " .child { height: 100px; position: absolute( или fixed); top: 0; bottom: 0; margin: auto 0 }",
      "Минус данного способа — должна быть известна высота внутреннего блока. ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "2. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью отрицательного margin-top",
    answer: [
      "Этот способ получил широкую известность и применяется очень часто. Как и предыдущий, он применяется, когда высота внешнего блока неизвестна, но известна высота внутреннего.",
      " - 1. Нужно задать внешнему блоку относительное позиционирование, а внутреннему - абсолютное.",
      " - 2. Затем необходимо сдвинуть внутренний блок вниз на половину высоты внешнего блока top: 50% и поднять вверх на половину собственной высоты margin-top: (H .child / 2).",
      "  .container { position: relative } ",
      "  .child { height: 100px; position: absolute; top: 50%; margin-top: -50px }",
    ],
    isParagraph: true,
  },
  {
    heading:
      "3. Центрирование абсолютно позиционированных или фиксированных элементов. Выравнивание с помощью transform",
    answer: [
      "Данный способ похож на предыдущий, но он может быть применен, когда высота внутреннего блока неизвестна.",
      "Можно использовать top: 50%, left: 50% в сочетании с translateX(-50%) translateY(-50%) для динамического горизонтального/вертикального центрирования элемента: ",
      " .container { position:relative }",
      " .child { position: absolute( или fixed);  top: 50%; left: 50%; transform: translateX(-50%) translateY(-50%) }",
    ],
    isParagraph: true,
  },
  {
    heading: "Выравнивание с помощью псевдоэлемента",
    answer: [
      "Это наиболее универсальный способ, который может применяться, когда неизвестны высоты обоих блоков. ",
      "Суть способа в добавлении внутри внешнего блока строчного блока inline-block высотой в 100% и задания ему вертикального выравнивания. В этом случае высота добавленного блока будет равна высоте внешнего блока. Внутренний блок выровняется по вертикали относительно добавленного, а значит, и внешнего блока. ",
      "Чтобы не нарушать семантику, строчный блок рекомендуется добавить с помощью псевдоэлемента before или after. ",
      "  .container:before { display: inline-block; height: 100%; vertical-align: middle }",
      " .child { display: inline-block; vertical-align: middle }",
    ],
    isParagraph: true,
  },
  {
    heading: "Запретить / разрешить прокрутку страницы. ",
    answer: [
      "Чтобы запретить прокрутку страницы, достаточно установить: ",
      " ",
      "            document.body.style.overflow = 'hidden'",
      " ",
      "Чтобы разрешить прокрутку страницы устанавливаем: ",
      " ",
      "            document.body.style.overflow = '' ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Как стилизовать или убрать полосу прокрутки — CSS скроллбар",
    answer: [
      "1. Убрать полосу прокрутки у элемента.",
      "      .element::-webkit-scrollbar { ",
      "            width: 0;",
      "      } ",
      " ",
      "2. Убрать полосу прокрутки для всей страницы:",
      "      ::-webkit-scrollbar { ",
      "            width: 0;",
      "      } ",
      " ",
      "3. Стилизовать прокрутку:",
      "      .element { ",
      "            width: 1280px; ",
      "            display: flex;  ",
      "            overflow-x: scroll;",
      " ",
      "      @media screen and (min-width: 1280px) { ",
      "            overflow-x: hidden; ",
      "            }",
      "      }",
    ],
    isParagraph: true,
  },
  {
    heading: "!important css ",
    answer: [
      "CSS правило !important дает больше значимости, чем любое другое свойство. В CSS !important означает, что “это важно” (this is important), все последующие правила игнорируются и применяется правило !important. Это правило должно быть указано в конце строки, сразу после точки с запятой. ",
      " ",
      "    *  Уникальный модификатор, позволяющий применить значение свойства вопреки обычной специфичности и каскаду. ",
      "    *  Опасный приём для повышения важности стилей. Ломает специфичность и каскад. ",
      " ",
      "Пример: ",
      "      .text { ",
      "            color: green !important;",
      "      } ",
      " ",
      "      .text { ",
      "            color: red;",
      "      } ",
      "По логике каскада текст в блоке с классом text должен быть красного цвета, потому что это правило стоит ниже в коде. Но из-за модификатора !important цвет текста будет зелёным. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Схлопывание внешних отступов ",
    answer: [
      "1. Отступы margin-top и margin-bottom иногда объединяются в один, с размером равным наибольшему из них (или размеру одного, если они равны). Это поведение известно как схлопывание внешних отступов. ",
      " ",
      "2. !!! Отступы плавающих и абсолютно позиционированных элементов никогда не схлопываются. ",
      " ",
      "3. Схлопывание внешних отступов происходит в трёх случаях: ",
      "",
      "    3.1. Соседние элементы. ",
      "Схлопываются отступы соседних элементов (за исключением случая, когда к последнему элементу применено свойство clear). ",
      "",
      "    3.2. Родительский и первый/последний дочерние элементы.",
      "Если отсутствуют границы (border), внутренние отступы (padding), строчное содержимое (inline/inline-block) или промежуток для отделения margin-top родительского элемента, от margin-top одного или нескольких его дочерних элементов/блоков или отсутствуют границы (border), внутренние отступы (padding), строчное содержимое (inline/inline-block), height, min-height или max-height для отделения отступов margin-bottom родительского блока от margin-bottom отступов одного или нескольких его дочерних элементов/блоков, то внешние отступы схлопываются. Схлопнутые отступы заканчиваются за пределами родительского элемента. ",
      "",
      "    3.3. Пустые блоки.",
      "Если отсутствуют границы (border), внутренние отступы (padding), строчное содержимое (inline/inline-block), height или min-height для отделения margin-top верхнего отступа этого блока от его margin-bottom нижнего отступа, то верхние и нижние внешние отступы этого блока схлопываются. ",
      " ",
      "4. На заметку: ",
      "",
      "   *  Более сложное схлопывание отступов (более, чем двух) происходит, когда описанные случаи сочетаются.",
      "   *  Эти правила применяются даже к отступам, равным 0, поэтому отступ первого/последнего дочернего элемента заканчивается за пределами его родителя (согласно правилу выше) независимо от того, равен ли отступ родителя нулю.",
      "   *  При использовании отрицательных отступов, размер схлопнутого отступа вычисляется, как сумма наибольшего положительного и наименьшего отрицательного (наибольшего по модулю) отступа.",
      "   *  Если все отступы отрицательные, размер схлопнутого отступа равен наименьшему (наибольшему по модулю) отступу. Это относится как к вложенным элементам, так и к соседним.",
      "   *  Внешние отступы плавающих и абсолютно позиционируемых элементов никогда не схлопываются.",
    ],
    isParagraph: true,
  },
];

import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksErrorProcessing: ILinkInfo[] = [
  {
    href: "https://habr.com/ru/company/ruvds/blog/431078/",
    title: "Рекомендованно к изучению: 'Руководство по обработке ошибок в JavaScript в Хабре'",
  },
  {
    href: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch",
    title: "Конструкция try...catch",
  },
  {
    href: "https://itchief.ru/javascript/try-catch",
    title: "Обработка ошибок, try...catch в JavaScript",
  },
];

export const arrayErrorProcessing: IObjectHeadingAnswers[] = [
  {
    heading: "Непойманные ошибки",
    answer: [
      "Когда возникает ошибка, выполнение кода прекращается, и эта ошибка выводится в консоль.",
      "В консоль будет выведена непойманная ошибка (uncaught error). Она так называется, потому что мы её не поймали (не обработали). Дальше код выполняться не будет и сообщение, которые мы выводим с помощью console.log() не отобразится.",
    ],
    isParagraph: true,
  },
  {
    heading: "Конструкция try ... catch (try...catch).",
    answer: [
      "Обработка ошибок в JavaScript осуществляется с помощью try...catch.",
      "try...catch – это специальный синтаксис, состоящий из двух основных блоков: try, и затем catch:",
      " --------------------------",
      "try { ",
      " - // блок кода, в котором имеется вероятность возникновения ошибки",
      "} catch(error) { ",
      " // этот блок выполняется только в случае возникновения ошибки в блоке try ",
      "}",
      " --------------------------",
      "Первый блок идёт сразу после ключевого слова try. В этот блок мы помещаем часть кода, в котором есть вероятность возникновения ошибки. ",
      "Второй блок располагается за ключевым словом catch. В него помещаем код, который будет выполнен только в том случае, если в первом блоке возникнет ошибка. В круглых скобках после catch указываем параметр error. В этот параметр будет помещена ошибка, которая возникла в блоке try.",
    ],
    isParagraph: true,
  },
  {
    heading: "Пример try...catch, пойманная ошибка.",
    answer: [
      "const text = '{ name: ''Александр'' }'; ",
      "try { ",
      " -  const person = JSON.parse( text );",
      "} catch( error ) { ",
      " - console.error( error );",
      " - console.log( error.message );",
      " }",
      "console.log( 'Это сообщение мы увидим!' ); ",
      " --------------------------",
      "Здесь в блоке try произойдет ошибка, так как в данном примере мы специально присвоили переменной text некорректную строку JSON: name без кавычек.",
      "В catch эта ошибка будет присвоена параметру error, и в нём мы будем просто выводить эту ошибку в консоль с помощью console.error(). Таким образом она будет выведена также красным цветом, но без слова Uncaught, т.к. эта ошибка была поймана.",
    ],
    isParagraph: true,
  },
  {
    heading: "Ошибка (error) – это объект и у него имеются следующие свойства:",
    answer: [
      "1. message – описание ошибки. Именно сюда попадает та строка, которую можно передать конструктору ошибки в качестве аргумента.;",
      "Например, ниже показано создание экземпляра объекта Error и вывод в консоль переданной конструктором строки через обращение к его свойству message: ",
      "const error = new Error('пожалуйста, улучшите свой код')",
      "console.log(error.message) // пожалуйста, улучшите свой код",
      "2. name – тип ошибки, например: RangeError, ReferenceError, SyntaxError, TypeError, URIError или другой.",
      "3. stack – представляет собой трассировку стека ошибки, которая используется в целях отладки. Stack позволяет узнать о том, что происходило в скрипте на момент возникновения ошибки. Обратившись к нему можно просмотреть стек вызовов (историю ошибки), который показывает последовательность операций, приведшую к неправильной работе программы. В частности, это позволяет понять — в каком именно файле содержится сбойный код, и увидеть, какая последовательность вызовов функций привела к ошибке.",
      "В верхней части стека находится сообщение об ошибке, затем следует указание на тот участок кода, выполнение которого вызвало ошибку, потом описывается то место, откуда был вызван этот сбойный участок. Это продолжается до самого «дальнего» по отношению к ошибке фрагмента кода.",
    ],
    isParagraph: true,
  },
  {
    heading: "Инструкция throw. Генерирование ошибок.",
    answer: [
      "Создание экземпляра объекта Error, то есть, выполнение команды вида new Error(), ни к каким особым последствиям не приводит. Интересные вещи начинают происходить после применения оператора throw (бросать), который генерирует ошибку. Как уже было сказано, если такую ошибку не обработать, выполнение скрипта остановится. При этом нет никакой разницы — был ли оператор throw использован самим программистом, произошла ли ошибка в некоей библиотеке или в среде выполнения языка (в браузере или в Node.js) ",
      "В JavaScript имеется инструкция throw, которая позволяет генерировать ошибку.",
      "// Синтаксис инструкции throw: ",
      " - throw expression; (expression - выражение)",
      "Как правило, в качестве выражения обычно используют встроенный основной класс для ошибок Error или более конкретный, например: RangeError, ReferenceError, SyntaxError, TypeError, URIError или другой. ",
      " // Создаём новый объект Error и выбрасываем его в случае ошибки: ",
      "throw new Error('Какое-то описание ошибки'); ",
      " // Пример генерирования синтаксической ошибки:",
      "throw new SyntaxError('Описание ошибки'); ",
      "// В качестве выражения можно использовать не только объект ошибки, но и строки, числа, логические значения и другие величины.",
      "Например throw 'Значение не является числом', но делать это не рекомендуется. ",
      "При обнаружении оператора throw выполнение кода прекращается, и ошибка выбрасывается в консоль.",
    ],
    isParagraph: true,
  },
  {
    heading: "Генерирование ошибок, обработка ошибок при помощи конструкции try...catch.",
    answer: [
      "При обнаружении оператора throw выполнение кода прекращается, и ошибка выбрасывается в консоль.",
      "Например, создадим функцию, которая будет просто выбрасывать новую ошибку: ",
      "// создаём стрелочную функцию и присваиваем её переменной myFn ",
      "const myFn = () => { ",
      " - throw new Error('Описание ошибки');",
      "} ",
      "// вызываем функцию ",
      "myFn(); ",
      "console.log('Это сообщение мы не увидим в консоли!'); ",
      "Код остановится, console.log() не сработает и Это сообщение мы не увидим в консоли!",
      " --------------------------",

      "Обработаем ошибки!!! Обернём вызов функции в конструкцию try...catch: ",
      "try { ",
      " - myFn();",
      "} catch(error) { ",
      " - console.error(error);",
      "} ",
      "console.log('Это сообщение мы увидим в консоли!'); ",
      "Код не остановится, продолжит работу, так как мы применили конструкцию try...catch. ",
      " console.log() сработает и Это сообщение мы увидим в консоли.",
      " --------------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Запись catch без указания круглых скобок и параметра внутри них",
    answer: ["Эта возможность была добавлена в язык, начиная с версии ECMAScript 2019."],
    isParagraph: true,
  },
  {
    heading: "Блок finally",
    answer: [
      "Иногда случается так, что некий код нужно выполнить независимо от того, произошла ошибка или нет. Для этого можно, в конструкции try...catch, использовать третий, необязательный, блок — finally. Часто его использование эквивалентно некоему коду, который идёт сразу после try...catch, но в некоторых ситуациях он может пригодиться. Вот пример его использования.",
      "const a = 5 ",
      "try { ",
      " -- console.log(b) // переменная b не объявлена - возникает ошибка",
      "} catch (err) { ",
      " -- console.error(err) // в консоль попадает сообщение об ошибке и стек ошибки",
      "} finally { ",
      " -- console.log(a) // этот код будет выполнен в любом случае",
      "} ",
    ],
    isParagraph: true,
  },
  {
    heading: "Описание try...catch",
    answer: [
      "Конструкция try содержит блок try, в котором находится одна или несколько инструкций (Блок ({} ) обязательно должен присутствовать, даже если выполняется всего одна инструкция), и хотя бы один блок catch или finally. Таким образом, есть три основные формы конструкции try: ",
      "1. try {...} catch {...} ",
      "2. try {...} finally {...} ",
      "3. try {...} catch {...} finally {...} ",
      "Блок catch содержит инструкции, которые будут выполнены, если в блоке try произошла ошибка. Если любая инструкция в блоке try выбрасывает исключение (ошибку), то управление сразу же переходит в блок catch. Если в блок try не было выброшено исключение (ошибки), то блок catch не выполняется ",
      "Блок finally выполняется всегда, независимо от того возникли ошибки в try или нет. Он выполняется после try, если ошибок не было, и после catch, если ошибки были. Секция finally не имеет параметров. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В асинхронных механизмах — не рекомендуется использовать коллбэки.",
    answer: [
      "Программируя на JavaScript всегда стоит обращать внимание на участки кода, выполняющиеся асинхронно. Если у вас имеется асинхронная функция и в ней возникает ошибка, скрипт продолжит выполняться. ",
      "В асинхронных механизмах — не рекомендуется использовать коллбэки.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные механизмы — промисы. Рекомендуется всегда использовать блок catch.",
    answer: [
      "Для выполнения асинхронных операций в JavaScript лучше использовать не коллбэки а промисы. Тут, в дополнение к улучшенной читабельности кода, имеются и более совершенные механизмы обработки ошибок. А именно, возиться с объектом ошибки, который может попасть в функцию обратного вызова, при использовании промисов не нужно. Здесь для этой цели предусмотрен специальный блок catch. Он перехватывает все ошибки, произошедшие в промисах, которые находятся до него, или все ошибки, которые произошли в коде после предыдущего блока catch. Обратите внимание на то, что если в промисе произошла ошибка, для обработки которой нет блока catch, это не остановит выполнение скрипта, но сообщение об ошибке будет не особенно удобочитаемым. ",
      "В результате можно порекомендовать всегда, при работе с промисами, использовать блок catch.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные механизмы и try...catch",
    answer: [
      "После того, как в JavaScript появилась конструкция async/await, мы вернулись к классическому способу обработки ошибок — к try...catch...finally. Обрабатывать ошибки при таком подходе оказывается очень легко и удобно. Рассмотрим пример ",
      " const fetchTodos = async function() { ",
      " try { const response = await fetch(''https://jsonplaceholder.typicode.com/todos?_limit=20'');",
      " // console.log(response)",
      " //",
      " if (!response.ok) {",
      " // Если у меня будет ошибка, то я её поймаю",
      " throw new Error(''Ошибка на сервере.'')",
      "  }",
      " //",
      " // Если ошибки нет,то....",
      " const date = await response.json()",
      " return date",
      " } catch (error: any) {",
      " return (error.message)",
      " }",
      " })",
      "При таком подходе ошибки в асинхронном коде обрабатываются так же, как в синхронном. В результате теперь, при необходимости, в одном блоке catch можно обрабатывать более широкий диапазон ошибок. ",
    ],
    isParagraph: true,
  },
];

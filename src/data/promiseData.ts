/* eslint-disable no-template-curly-in-string */
import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

export const linksPromise: ILinkInfo[] = [
  {
    href: "https://medium.com/nuances-of-programming/%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-javascript-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-f47cf28fb130",
    title: "Асинхронный JavaScript ― Цикл обработки событий",
  },
  {
    href: "https://learn.javascript.ru/async-await",
    title: "Async/await",
  },
  {
    href: "https://doka.guide/js/async-in-js/",
    title: "Асинхронность в JS",
  },
  {
    href: "https://doka.guide/tools/http-protocol/",
    title: "Протокол HTTP",
  },
  {
    href: "https://doka.guide/js/async-await/",
    title: "async/await",
  },
  {
    href: "https://habr.com/ru/search/?q=axios&target_type=posts&order=relevance",
    title: "Axios или Fetch?",
  },
  {
    href: "https://axios-http.com/",
    title: "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js.",
  },
  {
    href: "https://www.freecodecamp.org/news/axios-react-how-to-make-get-post-and-delete-api-requests/",
    title: "Axios React — как получать(GET), публиковать(post) и удалять(DELETE) запросы API",
  },
  {
    href: "https://altrim.io/posts/axios-http-client-using-typescript",
    title: "HTTP-клиент Axios с использованием TypeScript - 1",
  },
  {
    href: "https://dev.to/mperon/axios-error-handling-like-a-boss-333d",
    title: "HTTP-клиент Axios с использованием TypeScript - 2",
  },
  {
    href: "https://www.digitalocean.com/community/tutorials/react-axios-react-ru",
    title: "Использование Axios с React",
  },
];

export const arrayPromise: IObjectHeadingAnswers[] = [
  {
    heading: "Синхронный код",
    answer: [
      "Синхронный код — это выполнение кода строка за строкой. Если бы мы запустили синхронную функцию задержки delay(), то движок бы ничем другим заниматься в это время не мог. То есть пока delay() не выполнится до конца, к следующей строке интерпретатор не перейдёт.",
      "А это значит, что пока не пройдёт 5 секунд, и delay() не выполнится, мы вообще ничего сделать не сможем: ни вывести что-то в консоль ещё, ни выполнить другие функции, в особо тяжёлых случаях — даже передвинуть курсор.",
      "Такие операции, которые не дают выполнять ничего кроме них самих, пока они не завершатся, называются блокирующими выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронный код",
    answer: [
      "Асинхронный код - это код, который выполняется не построчно.",
      "Асинхронный код помогает избежать блокирующие выполнение.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные события.",
    answer: [
      "Асинхронными событиями являются те, которые возникают независимо от основного потока выполнения программы, отложенные по времени.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронная функция.",
    answer: ["Асинхронная функция, это функция, которая вместо какого-то значения возвращает промис."],
    isParagraph: true,
  },
  {
    heading: "Цикл событий. (Event loop)",
    answer: [
      "Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.",
      "Вызовы из стека работают по принципу «последний зашёл, первый вышел",
      "Цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно",
      "Цикл событий берёт на себя управление тем, как должны вызываться функции Web API.",
    ],
    isParagraph: true,
  },
  {
    heading: "Очередь задач",
    answer: [
      "Очередь задач - структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым. По принципу «первый зашёл, первый вышел» ",
    ],
    isParagraph: true,
  },
  {
    heading: "Колбэк. Callback",
    answer: [
      "Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события: «выполни эту функцию, когда случится это событие».",
      "В целом, событием может быть что угодно:",
      " - ответ от сервера;",
      " - завершение какой-то длительной вычислительной задачи;",
      " - получение доступа к каким-то API устройства, на котором выполняется код.",
      "Таким образом колбэк — это первый способ обработать какое-либо асинхронное действие. ",
      "Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.",
      "Это, в принципе, логично — ментальная модель достаточно простая: «выполни эту функцию, когда случится это событие». ",
      "Однако у колбэков есть неприятный минус, так называемый ад колбэков (callback hell).",
    ],
    isParagraph: true,
  },
  {
    heading: "Ад колбэков (Callback-hell) ",
    answer: [
      "Это когда у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.",
      "Если одна задача запускает другую, та — третью, и так далее, мы можем получить вот такую «башню» из обратных вызовов. И такая башня может получиться где угодно. Если мы делаем несколько последовательных запросов к серверу, зависящих друг от друга, то это может выглядеть, как нечитабельное нагромаждение кода.",
      "Читать такое сложно, не говоря уже о тестировании.",
      "Решить эту проблему были призваны Промисы (Promise).",
    ],
    isParagraph: true,
  },
  {
    heading: "Промисы (Promise)",
    answer: [
      "Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).",
      "В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.",
      "Промисы придумали, чтобы организовывать асинхронный код последовательно.",
      "Использование промисов, при решении ряда асинхронных запросов, избавляют код от лишней вложенности, делают его плоским и более тестируемым.",
      "Дополнительным плюсом стала возможность обрабатывать ошибки от цепочки промисов в одном месте — последним catch.",
      "Если что-то пошло не так, то программа не упадёт, а управление перейдёт к последней строчке с catch(), причём независимо от того, в каком из запросов ошибка появится.",
      "Также из then() можно вернуть не промис, а обычное значение. Оно обернётся в промис самостоятельно и прокинется в следующий then(): ",
      " request('/api/users/1') ",
      " - .then((user) => user.id)",
      " - .then((userId) => request(`/api/photos/${userId}/`)) ",
      " - .then((photo) => request(`/api/crop/${photo.id}/`)) ",
      " - .then((response) => console.log(response)) ",
      " - .catch((error) => console.error(error)) ",

      "Промисы оказались удобными, и появился даже такой термин как «промисификация» — когда асинхронную функциональность на колбэках превращали в промисы.",
      "Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков...  Для решения этих проблем придумали асинхронные функции.",
      " -----------------------------------------------------",
      "Promise (промис) - это объект, в который мы записываем два колбэка вместо того, чтобы передать их функции (resolve, reject).",
      "Промис - это обещание предоставить результат позже. С помощью промиса можно поставить на ожидание получение результата и, когда его получаем, можем его обрабатывать. Так же промис может вернуть ошибку, если результат вернуть не возможно. Промис может вернуть либо результат, либо ошибку. ",
      "Промис- может быть создан:",
      " - путём создания нового экземляра класса Promise ",
      " - методом fetch(), который всегда возвращает промис. ",
      " - асинхронной функцией async (), которая также всегда возвращает промис.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронные функции. async",
    answer: [
      "Асинхронные функции — функции, которые возвращают промисы.",
      "Асинхронная функция помечается специальным ключевым словом async",
      "Они всегда возвращают Промис. Даже если мы явно этого не указывали, при вызове они всё равно вернут промис.",
      "Однако с асинхронными функциями можно не обращаться с then() — есть более изящное решение: async/await Скопировать ссылку на секцию ''Связка async/await''",
    ],
    isParagraph: true,
  },
  {
    heading: "Связка async/await",
    answer: [
      "Примечание: async/await является частью ECMAScript 2017 и не поддерживается в Internet Explorer и более старых браузерах, поэтому используйте их осторожностью",
      "Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await.",
      "async function loadPosts() { ",
      " - const response = await fetch('/api/posts/') ",
      " - const data = await response.json()",
      " - return data",
      " - }",
      "В примере выше мы используем метод fetch() внутри функции loadPosts(). ",
      "Все асинхронные функции внутри мы вызываем с await — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было. ",
      "------------------------------------------------",
      "Добавленное перед определением функции ключевое слово async делает функцию асинхронной. Возвращаемое значение такой функции автоматически оборачивается в Promise.",
      "Асинхронные функции нужны для выполнения асинхронных операций: работой с API, базами данных, чтения файлов и т.д. ",
      "Асинхронные операции выполняются не сразу: код отправил запрос к API и ждёт, пока сервер пришлёт ответ. Ключевое слово await используется, чтобы дождаться выполнения асинхронной операции",
      "Движок JavaScript при этом не блокируется и может выполнять другой код. Как только ответ получен, выполнение кода продолжается.",
    ],
    isParagraph: true,
  },
  {
    heading: "Главное в ASYNK/AWAIT",
    answer: [
      "1. asynk/await - синтаксическая надстройка над промисами, не более.",
      "2. await синтаксис возможен только внутри asynk (асинхронных) функций. ",
      "3. asynk (асинхронная) функция всегда возвращает Promise. В асинхронной функции мы можем использовать ключевое слово return и возвращать какой-то результат: строку, объект, число, всё, что угодно. И до момента возврата результата функции с помощью ключевого слова return, Promise, который возвращает функция, будет в состоянии ожидания (pending). И если нигде ошибок не возникло и функция дошла до ключевого слова return, то Promise, возвращённый этой функцией, будет исполнен с теми данными, которые мы возвращаем в инструкции с ключевым словом return. Если возвращаем строку (return 'строка'). то промис будет исполнен и исполнен со строкой 'строка', как данными. Или, если возвращаем объект, будет исполнен с объектом и т.д. Если где-то возникла ошибка, то промис будет отклонён с той ошибкой, которая возникла внутри асинхронной функции.",
      "4. asynk (асинхронная) функция ожидает результата инструкции await и не выполняет последующие инструкции. Это очень важно. То есть, если есть инструкция с ключевым словом asynk, дальше функция не будет выполнятся, пока Promise находится в состоянии pending (ожидания). Но при этом, JavaScript может выполнять другие задачи, например, выполнять какие-то действия при нажатии пользователем какой нибудь кнопки в интерфейсе фронт-энд приложения. То есть, это не блокирующее действие. Промис не блокирует выполнение других частей нашего приложения. И только, когда промис будет resolved или rejected, то есть - либо исполнен, либо отклонён, выполнение функции продолжится. Это главное в ASYNK/AWAIT синтаксисе.",
    ],
    isParagraph: true,
  },
  {
    heading: "Плюсы async/await",
    answer: [
      "Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.",
      "Условия и вложенные конструкции становятся чище и проще читаются.",
      "Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch: ",
      "async function loadPosts() {",
      " - try {",
      " - const response = await fetch('/api/posts/')",
      " - const data = await response.json()",
      " - return data",
      " - } catch (e) {",
      " - console.log(e)",
      " - }",
      "}",
      "При этом в отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.",
      "Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.",
    ],
    isParagraph: true,
  },
  {
    heading: "fetch(), пример запроса на пупликацию (method: 'POST')",
    answer: [
      "С помощью функции fetch() можно отправлять сетевые запросы на сервер — как получать, так и отправлять данные. Метод возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.",
      "Браузер предоставляет глобальный API для работы с запросами и ответами HTTP. Раньше для подобной работы использовался XMLHttpRequest, однако fetch() более гибкая и мощная альтернатива, он понятнее и проще в использовании из-за того, что использует Promise. ",
      "Функция fetch() принимает два параметра:",
      " - url — адрес, по которому нужно сделать запрос;",
      " - options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.",
      "По умолчанию вызов fetch() делает GET-запрос по указанному адресу. Базовый вызов для получения данных можно записать таким образом: ",
      " - fetch('http://jsonplaceholder.typicode.com/posts')",
      "Результатом вызова fetch() будет Promise, в котором будет содержаться специальный объект ответа Response. У этого объекта есть два важных для нас поля: ",
      " - ok — принимает состояние true или false и сообщает об успешности запроса;",
      " - json — метод, вызов которого, возвращает результат запроса в виде json.",
      "С помощью второго аргумента options можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Так же в запрос можно добавить заголовки в виде объекта или специального класса Headers.",
      " - const newPost = { title: 'foo', body: 'bar', userId: 1 } ",
      " -----------------------------------------------------------------",
      "fetch('https://jsonplaceholder.typicode.com/posts', { ",
      " - method: 'POST', // Здесь так же могут быть GET, PUT, DELETE",
      " - body: JSON.stringify(newPost), // Тело запроса в JSON-формате",
      " - headers: {",
      " - // Добавляем необходимые заголовки",
      " - 'Content-type': 'application/json; charset=UTF-8',",
      " - },",
      "})",
      " - .then((response) => response.json())",
      " - .then((data) => {",
      " - console.log(data)",
      " - // {title: 'foo', body: 'bar', userId: 1, id: 101}",
      " })",
    ],
    isParagraph: true,
  },
  {
    heading: "fetch(), запрос на получение данных с сервера (method: 'GET')",
    answer: [
      "fetch('https://jsonplaceholder.typicode.com/todos') ",
      ".then(response => {  ",
      "console.log(response) ",
      "return response.json() ",
      "}) ",
      " ----------------------",
      "const fetchTodos() { ",
      " try { ",
      " const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=20');",
      " if (!response.ok) { // Если у меня будет ошибка, то я её поймаю: ",
      "throw new Error('Ошибка на сервере.')",
      "}",
      "// Если ошибки нет,то.... ",
      "const date = await response.json(); ",
      "return date; ",
      "} catch (error: any) { ",
      "return error ",
      " } ",
      "}); ",
      " ----------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios",
    answer: [
      "Axios — это простой HTTP-клиент на основе Promise для браузера и node.js. Axios предоставляет простую в использовании библиотеку в небольшом пакете с очень расширяемым интерфейсом.",
      "Axios может работать в браузере и nodejs с одной и той же кодовой базой). На стороне сервера используется собственный http модуль node.js, а на стороне клиента (браузера) — XMLHttpRequests.",
      "Установка: $ npm install axios",
      " ------------------------------",
      "Функции axios",
      "1. Делает XMLHttpRequests из браузера",
      "2. Делает http- запросы из node.js ",
      "3. Поддерживает promise API ",
      "4. Перехватывает запросы и ответы",
      "5. Преобразует данные запроса и ответа ",
      "6. Отменяет запросы ",
      "7. Автоматические преобразования для данных JSON ",
      "8. Автоматическая сериализация объектов данных multipart/form-dataи x-www-form-urlencodedкодировка тела ",
      "9. Поддержка на стороне клиента для защиты от XSRF",
      " ------------------------------",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "const fetchAlbums = async function() {",
      " try { const response = await axios.get(",
      " `https://jsonplaceholder.typicode.com/albums?_limit=${params.limit}&_page=${params.page}`",
      " );",
      "// console.log(response); ",
      "const totalCount = response.headers['x-total-count']; ",
      "const albums = await response.data; ",
      "const res = { totalCount, albums }; ",
      "return res; ",
      " } catch (error: any) { ",
      " return error",
      " -}",
      "} ",
      ") ",
    ],
    isParagraph: true,
  },
  {
    heading: "Axios, получение данных с сервера.",
    answer: [
      "async function getTodos() {",
      " - const { data } = await axios.get('http://someapi/todos/')",
      " - setTodos(firstTen;",
      " };",
    ],
    isParagraph: true,
  },
];

import { IObjectHeadingAnswers } from "../models/types";

export const arrayInterviews: IObjectHeadingAnswers[] = [
  {
    heading: "Создание промиса ",
    answer: [
      "1. Сдал ли экзамен - passexam ",
      " ",
      "      const passexam = true; ",
      " ",
      "2. Создаём промис ",
      " ",
      "      const promise = new Promise((resolve, reject) => { ",
      "            setTimeout(() => {",
      "                  passexam ? console.log('Ok') : console.log('Not ok');",
      "            }, 100);",
      "      }); ",
      " ",
      "3. Создаём функцию ",
      " ",
      "      function test() { ",
      "            promise ",
      "                  .then((res) => res)",
      "                  .catch((error) => console.log(error));",
      "      } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Преобразовать промис в asynk / await ",
    answer: [
      "1. Сдал ли экзамен - passexam ",
      " ",
      "      const passexam = true; ",
      " ",
      "2. Создаём промис ",
      " ",
      "      const promise = new Promise((resolve, reject) => { ",
      "            setTimeout(() => {",
      "                  passexam ? console.log('Ok') : console.log('Not ok');",
      "            }, 100);",
      "      }); ",
      " ",
      "3. Создаём функцию asynk / await ",
      " ",
      "      const foo = async () => { ",
      "            try {",
      "                  await promise;",
      "            } catch (error) {",
      "                  console.log(error);",
      "            }",
      "      }; ",
    ],
    isParagraph: true,
  },
  {
    heading: "Promise промис и Typescript.",
    answer: [
      "1 - ая функция. ",
      " ",
      "      function someAsynkTask1(): Promise<number> { ",
      "            console.log('task 1');",
      "            return new Promise((res) => {",
      "                  setTimeout(() => res(1), 500);",
      "            });",
      "      } ",
      " ",
      "2 - ая функция. ",
      " ",
      "      function someAsynkTask2(): Promise<number> { ",
      "            console.log('task 2');",
      "            return new Promise((res) => {",
      "                  setTimeout(() => res(2), 500);",
      "            });",
      "      } ",
      " ",
      "3 - я функция main. ",
      " ",
      "      async function main(): Promise<number> { ",
      "            return (await someAsynkTask1()) + (await someAsynkTask2());",
      "      } ",
      " ",
      "4. Вызов фунции main",
      " ",
      "      main(); ",
    ],
    isParagraph: true,
  },
  {
    heading: "Способы перебора массива в JavaScript. ",
    answer: [
      "Перебор настоящих массивов ",
      " ",
      "1. Метод forEach и родственные методы",
      "1.1. forEach предназначен для перебора всех элементов массива: ",
      "            const arr = [1, 2, 3, 4]; ",
      "            arr.forEach((el) => console.log(el * 2)); // 2, 4, 6, 8 ",
      " ",
      "1.2.  every — возвращает true, если для каждого элемента массива колбек возвращает значение приводимое к true.",
      "            const array1 = [12, 5, 8, 130, 44]; ",
      "            const array2 = [12, 54, 18, 130, 44]; ",
      " ",
      "            function isBigEnough<T>(element: T, index: number, array: Array<T>) { ",
      "                  return element >= 10;",
      "            } ",
      "            console.log(array1.every(isBigEnough)); // false ",
      "            console.log(array2.every(isBigEnough)); // true ",
      " ",
      "1.3.  some — возвращает true, если хотя бы для одного элемента массива колбек возвращает значение приводимое к true.",
      "            const array1 = [11, 5, 89, 131, 45]; ",
      "            const array2 = [12, 54, 18, 130, 44]; ",
      "            const array3 = [13, 54, 19, 130, 47]; ",
      " ",
      "            const even = (element: number) => element % 2 === 0; ",
      "            const odd = (element: number) => element % 2 !== 0; ",
      " ",
      "            console.log(array1.some(even)); // false ",
      "            console.log(array2.some(even)); // true ",
      "            console.log(array3.some(even)); // true ",
      " ",
      "            console.log(array1.some(odd)); // true ",
      "            console.log(array2.some(odd)); // false ",
      "            console.log(array3.some(odd)); // true ",
      " ",

      "1.4.  filter — создает новый массив, включающий те элементы исходного массива, для которых колбек возвращает true.",
      "            const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; ",
      "            const resultWords = words.filter((word) => word.length > 6); ",
      "            console.log(resultWords); // ['exuberant', 'destruction', 'present'] ",
      " ",
      "            const numeric = [12, 5, 8, 130, 44]; ",
      "            const resultNumeric = numeric.filter((num) => num > 10); ",
      "            console.log(resultNumeric); // [12, 130, 44] ",
      " ",
      "1.5.  map — создает новый массив, состоящий из значений возращаемых колбеком.",
      "            const array = [2, 4, 6]; ",
      " ",
      "            const newArray1 = array.map((x, index) => { ",
      "                  return x * (index + 1);",
      "            }); ",
      "            console.log(newArray1); // [2, 8, 18] ",
      " ",
      "            const newArray2 = array.map((x, index) => { ",
      "                  return index + 1;",
      "            }); ",
      "            console.log(newArray2); // [1, 2, 3] ",
      " ",
      "1.6.  reduce — сводит массив к единственному значению, применяя колбек по очереди к каждому элементу массива, начиная с первого (может быть полезен для вычисления суммы элементов массива и других итоговых функций).",
      "            const array = [2, 4, 6, 8]; ",
      " ",
      "            const result = array.reduce((acc, el, i) => acc + el, 0); ",
      "            console.log(result); // 20 ",
      " ",
      "1.7.  reduceRight — работает аналогично reduce, но перебирает элементы в обратном порядке",
      " ",
      "2. Цикл for() - для перебора элементов массива, символов строк по цифровым индексам.",
      "            const array = [2, 4, 6, 8]; ",
      "            let newArr: number[] = []; ",
      " ",
      "            function makeArray<T>(arr: Array<T>) { ",
      "                  for (let i = 0; i < array.length; i++) {",
      "                        newArr.push(array[i] + (i + 1));",
      "                  }",
      "                  return newArr;",
      "            } ",
      "            console.log(makeArray(array)); // [3, 6, 9, 12] ",
      " ",
      " 3. Цикл for..of не предоставляет доступа к индексу текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.",
      "            const array = [2, 4, 6, 8]; ",
      "            let newArr: number[] = []; ",
      " ",
      "            function makeArray<T>(arr: Array<T>) { ",
      "                  for (let value of array) {",
      "                        value += 1;",
      "                        newArr.push(value);",
      "                  }",
      "                  return newArr;",
      "            } ",
      "console.log(makeArray(array)); // [3, 5, 7, 9] ",
    ],
    isParagraph: true,
  },
  {
    heading: "Атрибуты загрузки скриптов <script src>, <script async> и <script defer>",
    answer: [
      "Подключаемые скрипты (JavaScript) блокирует загрузку HTML кода. Когда браузер (парсер) доходит до тега <script> он останавливается, чтобы загрузить контент файла и выполнить его код, и только после этого продолжает парсинг HTML. ",
      "Такое поведение может тормозить отображение HTML, когда на странице загружаются много файлов JavaScript. Часто код этих файлов не нужен, чтобы показать HTML страницы. Именно поэтому рекомендуется подключать скрипты в конце страницы. Однако эту рекомендацию не всегда можно соблюсти и для таких случаев есть другие способы не блокировать отрисовку HTML. ",
      "У элемента <script> есть два атрибута, async и defer, которые могут дать нам больше контроля над тем, как и когда файл загружаются и выполняются. ",
      " ",
      "1. SRC - это путь до самого скрипта. ",
      "2. Атрибуты defer и async. С помощью этих атрибутов можно сказать браузеру как и в каком порядке загружать скрипты.",
      "Скрипты с атрибутами defer загружаются и выполняются последовательно, а с async – асинхронно. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async выполняется сразу после загрузки. ",
      " ",
      "2.1. defer ",
      "Cообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.",
      "   *  Скрипты с атрибутом defer никогда не блокируют страницу, будут предотвращать запуск события DOMContentLoaded до тех пор, пока скрипт не загрузится полностью и не завершится его инициализация. ",
      "   *  Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.",
      " ",
      "      <script src='script1.js' defer></script> ",
      "      <script src='script2.js' defer></script> ",
      "Первым всегда выполнится script1.js, который подключён раньше ",
      " ",
      "2.2. Атрибут async ",
      "Означает, что скрипт абсолютно независим: ",
      "   *  Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.",
      "   *  Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:",
      "Скрипт выполняется полностью асинхронно. Это означает, что файл будет выполняться без ожидания загрузки и отображения веб-страницы. При обнаружении <script async src='...'> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится. ",
      " ",
      "      <script src='script1.js' async></script>",
      "      <script src='script2.js' async></script>",
      " ",
      "Первым выполнится тот скрипт, который быстрее загрузится. ",
      " ",
      "3. Подсказки. ",
      "",
      "Динамически вставленный <script> (например, вставленный при помощи document.createElement) по умолчанию загружается браузером асинхронно. ",
      "",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните разницу между <script>, <script async> и <script defer>. ",
    answer: [
      "Элемент <script> (от англ. script — сценарий) предназначен для описания скриптов, может содержать ссылку на программу или её текст на определённом языке. Скрипты могут располагаться во внешнем файле и связываться с любым HTML-документом. Такой подход позволяет использовать одни и те же общие функции на многих веб-страницах и ускоряет их загрузку, т. к. внешний файл кэшируется при первой загрузке, и скрипт вызывается быстрее при последующих вызовах. ",
      "      <script> —  синхронная загрузка скриптов. С большой вероятностью движок выполнит скрипт перед тем, как отрисовать первый кадр интерфейса пользователя. Отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта. ",
      "      <script async> —  асинхронная загрузка скриптов. Скрипт будет извлечен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте async тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.",
      "      <script defer> —  асинхронная загрузка скриптов. Скрипт будет извлечен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут defer обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом <body>. Отложенный скрипт не должен содержать document.write.",
      "Если же мы грузим скрипты асинхронно через async или defer, то велика вероятность, что до загрузки JavaScript браузер успеет отрисовать интерфейс пользователя.",
    ],
    isParagraph: true,
  },
  {
    heading: "Влияет ли размер CSS файла на загрузку страницы?",
    answer: [
      "Если вес файла стилей будет 50 мгБ, то пока он грузится, заблокирует нам рендеринг.",
      "Вес всего, что вы размещаете на странице будет влиять на её загрузку. Однако, есть и вторая сторона вопроса. Разбив файл на множество мелких, подгружая их в каждом нужном разделе, вы увеличиваете количество запросов, необходимых для чтения этих файлов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Какая разница между элементами <span> и <div>? ",
    answer: [
      "     - <span> — это строчный (inline) элемент.",
      "     - <div> — это блочный (block) элемент.",
      " ",
      "Элементы <div> нужно использовать для оформления разделов документа. А элементы <span> — в роли контейнеров для небольших объёмов текста, для изображений и других подобных элементов страниц. ",
      "Надо отметить, что нельзя помещать блочные элементы в строчные. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между строчным, блочным и блочно-строчным элементом?",
    answer: [
      "    *  Строчные элементы (display: inline) ",
      "",
      "Строчными называются такие элементы, которые являются непосредственной частью строки и занимают такое количество пространства, которое необходимо для отображения их содержимого. У них значение свойства display: inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
      "Строчным элементам нельзя установить размеры (width и height), задать верхние и нижние margin отступы. ",
      "Для строчного элемента, размещенного на одной линии, можно использовать padding (внутренние отступы), margin-left и margin-right, border. ",
      " ",
      "    *  Блочные элементы (display: block)",
      "",
      "Блочные элементы в отличие от строчных элементов занимают по умолчанию всю ширину блока-контейнера, в которую они помещены. Высота блочного элемента по умолчанию определяется автоматически и зависит от содержимого, которое в него помещено. Блочный элемент можно представить как прямоугольник, который имеет ширину (width) и высоту (height). Ширину и (или) высоту блочного элемента можно задавать вручную с помощью CSS свойств width и (или) height. Также блочные элементы имеют границы, которые можно оформлять с помощью стилей CSS. Кроме этого блочным элементам можно задавать отступы внешние и внутренние. Внешний отступ (margin) – это отступ от границы до элемента контейнера или до соседних блочных элементов. Внутренний отступ (padding) – это отступ для содержимого блока, который задаётся от границы. ",
      "Блочные элементы могут содержать строчные элементы и другие блочные элементы, для которых их родитель будет являться контейнером. Блочные элементы предназначены для разработки каркаса веб-страницы, разметки больших блоков текста и много другого. ",
      " ",
      "    *  Строчно-блочные элементы (display: inline-block )",
      "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
      "div { display: inline-block } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Дефолтные стили браузера и их нормализация",
    answer: [
      "Каждый браузер имеет дефолтные стили (user agent stylesheet). Эти стили задают оформление, которые HTML элементы имеют по умолчанию. ",
      "Т.е., если в браузере открыть HTML документ без привязанного к нему CSS кода, то он уже будет каким-то образом оформлен. Это базовое оформление задаётся с использованием стилей браузера. ",
      "Но в разных браузерах дефолтные стили могут быть различными. ",
      "Например, в одном в браузере некоторый элемент может иметь одно оформление, а в другом - другое. ",
      "Для того чтобы нормализовать стили, которые отличаются в разных браузерах можно использовать Normalize.css:",
      " ",
      "      https://necolas.github.io/normalize.css/ ",
      " ",
      "Этот файл необходимо скачать, поместить в проект и подключить: ",
      " ",
      "      <!doctype html> ",
      "      <html lang='ru'> ",
      "            <head>",
      "                  <meta charset='utf-8'>",
      "                  <meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'>",
      "                  <!-- Normalize CSS -->",
      "                  <link rel='stylesheet' href='normalize.css'>",
      "                  <title>Normalize CSS</title>",
      "            </head>",
      "",
      "            <body>",
      " ",
      "            </body>",
      "      </html> ",
      " ",
      "После подключения этого файла все элементы в HTML документе будут отображаться более согласовано и в соответствии со современными стандартами. ",
    ],
    isParagraph: true,
  },
  {
    heading:
      "Что происходит после того как пользователь ввел URL в адресную строку браузера и нажал Enter или перешёл по ссылке?",
    answer: [
      "1. Навигация. ",
      "Навигация - это первый шаг загрузки веб-страницы. Она происходит когда пользователь вводит URL в адресной строке или делает клик по ссылке.",
      " ",
      "1.1. DNS-поиск ",
      "Первый шаг - найти IP-адрес, где располагаются ресурсы. Это делается с помощью DNS-поиска, запрос обрабатывается DNS сервером - службой доменных имён.. ",
      "DNS (Domain Name System)-сервер - это сервер, который главным образом используются для сопоставления имени хоста веб-сайта (пр.: www.example.com) с соответствующим ему IP-адресом. Он содержит базу данных публичных IP-адресов и им соответствующих доменных имен. ",
      "Например если вы посетите страницу www.example.com, то DNS-сервер вернет вам ее IP-адрес (93.184.216.34). ",
      " ",
      "1.2. Устанавливается соединение с сервером. ",
      "Следующий шаг - установить с сервером TCP-соединение. Делается это через протокол управления передачей - TCP. ",
      "    *  Сперва клиент посылает запрос на открытие соединения с сервером.",
      "    *  Затем сервер отвечает: подтверждает запрос клиента и посылает свой запрос клиенту на открытие соединения.",
      "    *  В конце клиент посылает на сервер подтверждение запроса.",
      " ",
      "1.3. Осуществляется защита соединения. ",
      "Следующий шаг - шифрует данные, передаваемые через Интернет, чтобы подслушивающие устройства и хакеры не могли увидеть то, что вы передаете, что особенно полезно для частной и конфиденциальной информации, такой как пароли, номера кредитных карт и личная переписка. ",
      " ",
      "2. Фетчинг ресурсов. ",
      "После того как установлена соединение и его защита, браузер может начать фетчинг (получать, загружать) ресурсов сервера. Теперь можно начать отправлять запросы на сервер и получать от него данные.",
      " ",
      "3. Парсинг HTML. ",
      "После того как браузер получил HTML-файл он парсит (разбирает, анализирует) его для создания DOM-дерева. ",
      " ",
      "4. Парсинг CSS ",
      "После того как DOM-дерево построено, браузер парсит CSS-файлы для создания CSSOM (CSS Object Model). ",
      " ",
      "5. Выполнение JavaScript. ",
      "После загрузки скрипта, он будет обработан движком JavaScript. ",
      " ",
      "6. Рендеринг. ",
      "Теперь пришло время рендера (визуализация) страницы. Для рендеринга браузер использует DOM-дерево и CSSOM. ",
    ],
    isParagraphBefore: true,
  },
  {
    heading: "Главное различие img и background-image.",
    answer: [
      "Основное различие: ",
      "    *  Картинки, которые являются частью оформления страницы должны быть вынесены в CSS.  ",
      "    *  Картинки, которые относятся к содержанию страницы и несут смысловую нагрузку вставляем тегом <img>. ",
      "Т.е. фоны - оформление выносим в CSS, a картинки - контент: аватарки, баннеры вставляем тегом <img>:",
      " ",
      "Надлежащее использование IMG ",
      "  1. Используйте IMG плюс атрибут alt, если изображение является частью контента, например, логотипом, диаграммой или человеком (реальным человеком, а не людьми со стоковых фотографий).",
      "  2. Используйте IMG, если вы хотите, чтобы люди распечатывали вашу страницу , и вы хотите, чтобы изображение было включено по умолчанию. ",
      "  3. Используйте IMG (с alt текстом), когда изображение имеет важное семантическое значение, например значок предупреждения . Это гарантирует, что значение изображения может быть передано во всех пользовательских агентах, включая программы чтения с экрана.",
      "  4. Используйте IMG, если вы полагаетесь на масштабирование браузера для отображения изображения пропорционально размеру текста.",
      "  5. Использование imgвместо background-image может значительно улучшить производительность анимации по сравнению с фоном.",
      " ",
      "Когда использовать фоновое изображение CSS ",
      " 1. Используйте фоновые изображения CSS, если изображение не является частью содержимого.",
      " 2. Используйте фоновые изображения CSS при замене изображения текста, например. абзацы/заголовки. ",
      " 3. Используйте, background-imageесли вы хотите, чтобы люди распечатывали вашу страницу , и вы не хотите, чтобы изображение было включено по умолчанию.",
      " 4. Используйте background-image, если вам нужно, чтобы была видна только часть изображени",
      " 5. Используйте background-image, если вам нужно улучшить время загрузки. ",
      " 6. Используйте background-imagewith background-size:cover, чтобы растянуть фоновое изображение на все окно.",
      " ",

      "Нюансы из практики",
      " ",
      "  *  При печати страницы сайта теги img печатаются, а background-ы нет.",
      "  *  Браузеры разработанные для людей с ограниченными возможностями читают альты картинок, потому если изображение несет важный смысл, оно обязательно должно быть оформлено html тегом.",
      "  *  Некоторые старые браузеры не поддерживают свойство background-size и для создания масштабируемого фона в них используется тег, а не свойство фона.",
      "  *  Img с анимацией меньше нагружает браузеры.",
      "  *  Для замены текста изображением лучше использовать background-image (к примеру, если нужно вывести заголовки красивыми картинками).",
      "  *  Используя свойство фона мы можем вывести на странице только часть изображения.",
    ],
    isParagraph: true,
  },
  {
    heading: "Цикл событий. Event loop - событийный цикл: микрозадачи и макрозадачи (***)",
    answer: [
      "1. Цикл событий — это выполнение кода и обновление интерфейса. ",
      "Выполнение кода происходит в стеке вызовов. Call stack - это то место, куда по ходу выполнения кода попадают вызванные функции (по принципу: последний зашёл, первым вышел) после чего выполняются.",
      "Обновление интерфейса пользователя выполняет движок браузера. ",
      "Первой операцией в цикле событий может быть как обновление интерфейса, так и выполнение кода. ",
      "Цикл событий очень последовательный: он полностью выполняет весь код в стеке вызовов и только потом переходит к обновлению интерфейса. Если в стеке вызовов будет слишком много кода, интерфейс будет обновляться с большой задержкой. У пользователя создастся впечатление, что сайт лагает. Если написать бесконечный цикл, то браузер так и будет выполнять код снова и снова, а обновление интерфейса не наступит никогда, поэтому страница просто зависнет и перестанет реагировать на действия пользователя. ",
      "Внутри стека вызовов будет выполняться как код, написанный разработчиком, так и код, встроенный по умолчанию и отвечающий за взаимодействие со страницей. Благодаря встроенному коду работают прокрутка, выделение, анимации и другие штуки, для которых, казалось бы, JavaScript не нужен. Стек вызовов будет выполнять встроенные скрипты даже тогда, когда мы запретим в браузере JavaScript. ",
      " ",
      "2. Задачи, тики и Web API. ",
      "Задача — это JavaScript-код, который выполняется в стеке вызовов. Тик — выполнение задачи в стеке вызовов. Web API — свойства и методы в глобальном объекте Window. ",
      "Методы Web API работают либо синхронно, либо асинхронно: первые выполнятся в текущем тике, а вторые в одном из следующих тиков. ",
      " ",
      "3. Синхронные операции выполняются в текущем тике. Браузер обновит интерфейс только после полного завершения синхронных операций, так что пользователь увидит сразу актуальное состояние интерфейса. ",
      " ",
      "4. Асинхронные операции гарантируют, что задача будет выполняться в следующем тике. Важно просто понимать, что асинхронная задача выполнится когда-то в будущем. Хороший пример асинхронного вызова — это запрос данных с сервера.",
      "Подсистема браузера, которая отвечает за работу с сетью, выполнит запрос в отдельном потоке, который будет работать независимо. Пока запрос будет выполняться фоном, цикл событий может спокойно обновлять интерфейс и выполнять код. После того как данные успешно загрузятся, задание, которое мы описали через функцию обратного вызова, станет готовым для выполнения в одном из следующих тиков нашего основного цикла заданий. ",
      " ",
      "5. Очередь задач ",
      "Задач, готовых к выполнению после асинхронных вызовов, может быть несколько. Поэтому для передачи их в стек вызовов на выполнение существует специальная очередь. ",
      "Задачи попадают в очередь через асинхронное браузерное Web API. Сперва в отдельном потоке браузерного Web API выполняется асинхронная операция, после её завершения в очередь в стек вызовов добавляется задача готовая к выполнению. ",
      "Когда мы запускаем таймер, движок начинает вести обратный отсчёт в отдельном потоке и по готовности задача добавляется в очередь. Можно было бы подумать, что таймер выполнится через одну секунду, но на самом деле это не так. В лучшем случае через одну секунду он добавится в очередь заданий, а код будет выполнен только после того, как до него дойдёт очередь.",
      "Точно такая же история с обработчиками событий. Каждый раз, когда мы регистрируем обработчик событий, мы привязываем к нему задачу, которая будет добавлена в очередь после наступления события. ",
      " ",
      "6. 16,6 миллисекунды на задачу. ",
      "Чтобы сайты были быстрыми и «отзывчивыми», браузеру надо создать иллюзию, что он одновременно выполняет код пользователя и обновляет интерфейс. Но поскольку цикл событий работает строго последовательно, браузеру приходится быстро переключаться между задачами, чтобы пользователь ни о чём не догадался. ",
      "Оптимизировать большие задачи можно двумя путями: либо через разбиение их на подзадачи и выполнение последних в разных тиках, либо через вынесение вычисления в отдельный поток. ",
      " ",
      "7. Микрозадачи.",
      "Микрозадачи — это те задачи, которые хранятся в специальной отдельной очереди.",
      "Задачи попадают в эту очередь при использовании обещаний, асинхронных функций, встроенном вызове queueMicrotask или для Observer API. ",
      " ",
      "8. Очередь микрозадач — это самая приоритетная очередь, с неё начинается выполнение кода, задачи из неё выполняются раньше обычных. Кроме того, у неё есть важная особенность — цикл событий будет выполнять микрозадачи до тех пор, пока очередь не опустеет, сколько бы времени это ни заняло. ",
      " ",
      "9.  Блоки синхронного кода всегда выполняются последовательно сверху вниз. Важно: синхронный код выполняется в том порядке, в котором он был вызван.",
      "    Интерпретатор JavaScript всегда сначала выполняет синхронный код, а затем асинхронный. Нам важно различать синхронный и асинхронный код.",
      "    Помните, что метод resolve не прерывает выполнение функции. Код, стоящий за ним, по-прежнему будет выполняться.",
      " ",
      "Существуют две очереди асинхронных операций: очереди микро- и макротасок. ",
      "    *  Микрозадачами (микро-тасками) называются задачи с более высоким приоритетом. Микрозадачами становятся задачи при использовании ими промисов, асинхронных функций, встроенном вызове queueMicrotask или для Observer API. Например: Promise, fetch(), axios, async-await, ObjectObserver, MutationObserver, process.nextTick, async/await.",
      "    *  Макрозадачами (макро-тасками) называются задачи с более низким приоритетом. Макрозадачи включают в себя синтаксический анализ HTML, генерацию DOM, выполнение JavaScript-кода основного потока и другие события, такие как загрузка страницы, ввод, сетевые события, события таймера и т.д. Например: setTimeout, setInterval, setImmediate, I/O, UI rendering и XHR",
      "Микротаски имеют более высокий приоритет исполнения, у них своя очередь. Поэтому когда event loop прокручивается, ему не важно, сколько в очереди макротасок – он возьмёт микротаску, даже если она в очереди единственная, а макротасок 500.  ",
      "Микротаски выполняются сразу, как только освободился стек. Другими словами: сначала выполнятся все микро-такси, только потом, когда очередь станет пустой, начнут выполняться макро-таски.",
      " ",
      "Микрозадачи и макрозадачи выполняются так: ",
      "",
      "    1. Сначала выполняются все микрозадачи.",
      "    2. Выполняется одна макрозадача. ",
      "    3. Повторно выполняются все (вновь добавленные) микрозадачи. ",
      "    4. Выполняется следующая макрозадача. ",
      "    5. Цикл повторяется / Цикл завершается. ",
      " ",
      "Чтобы добавить в очередь новую макрозадачу: ",
      "   *  Используйте setTimeout(f) с нулевой задержкой.",
      "",
      "Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей. ",
      "Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено). ",
      " ",
      "Для добавления в очередь новой микрозадачи: ",
      "   *  Используйте queueMicrotask(f).",
      "   *  Также обработчики промисов выполняются в рамках очереди микрозадач.",
      "События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой. ",
      "Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения. ",
      " ",
      "Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл, мы можем использовать Web Workers. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронный JavaScript ― Цикл обработки событий ",
    answer: [
      "1. JavaScript — однопоточный язык программирования. Движок JS V-8 единовременно может обрабатывать только одно выражение — в одном потоке. ",
      "С одной стороны, отсутствие многопоточности упрощает написание кода, потому что вам ненужно беспокоиться о проблемах параллельного выполнения. С другой стороны, вы не можете выполнять длительные операции, например сетевой доступ, не блокируя основной поток. ",
      "Представьте себе запрос данных из API. В зависимости от ситуации, серверу потребуется какое-то время на обработку запроса, а пока основной поток занят — страница будет неотзывчива. ",
      "В таких случаях нужна асинхронность. Используя асинхронный JavaScript (например callback, promise, и async/await), вы можете выполнять длительные сетевые запросы, не блокируя основной поток. ",
      " ",
      "2. Контекст выполнения ",
      " ",
      "Контекст выполнения — это среда, где код анализируется и выполняется. Всякий раз, когда в JavaScript выполняется код, это происходит внутри контекста выполнения.  ",
      "Код функции выполняется внутри контекста выполнения функции. ",
      "А глобальный код выполняется в глобальном контексте выполнения. У каждой функции есть свой контекст выполнения. ",
      " ",
      "3. Стек вызовов ",
      " ",
      "Стек вызовов -  это механизм, предназначенный для отслеживания текущего местонахождения интерпретатора в скрипте. Он вызывает несколько функций и определяет, какая из них выполняется на данный момент, какие функции вызываются внутри выполняемой функции и какая будет вызвана следующей. ",
      "Стек вызовов создается, когда внутри функции (или метода) существуют другие функции. В реальных приложениях таких уровней могут быть сотни. Стек вызовов формируется каждый раз, когда мы запускаем код на стороне браузера. ",
      "Стек вызовов имеет структуру LIFO (последний пришел, первый вышел), в котором хранятся все контексты выполнения, созданные в течение выполнения кода. ",
      "В JavaScript есть только один стек вызовов, так как это однопоточный язык. Стек вызовов имеет структуру LIFO, поэтому элементы могут быть добавлены или удалены только сверху стека. ",
      "Стек вызовов ограничен по количеству находимых в нём функций. При перезаполнении вылетает ошибка.",
      " ",
      "4. Как выполняется синхронный код внутри движка JS. Например, этот:",
      " ",
      "      const second = () => { ",
      "            console.log('Hello there!');",
      "      }; ",
      " ",
      "      const first = () => { ",
      "            console.log('Hi there!');",
      "            second();",
      "            console.log('The End');",
      "      }; ",
      " ",
      "      first(); ",
      " ",
      "4.1. Итак, что же здесь происходит?",
      " ",
      "При исполнении этого кода, был создан глобальный контекст выполнения (главная функция main()) и помещён в стек, сверху. Когда в коде встречается вызов first(), он также помещается в стек, сверху. ",
      "Далее, в стек попадает console.log('Hi there!'), также сверху, а после завершения вылетает из стека. Далее мы вызываем функцию second(), с ней происходит то же самое. ",
      "Далее, console.log('Hello there!') попадает в стек и после завершения вылетает из него. Функция second() завершается и то же вылетает из стека. ",
      "console.log(‘The End’) попадает в стек и вылетает после завершения. После этого завершается функция first() и вылетает из стека ",
      "На этом выполнение программы завершено и глобальный контекст выполнения (main()) вылетает из стека. ",
      " ",
      "5. Как работает асинхронный JavaScript?",
      " ",
      "Теперь, когда у вас есть представление о стеке вызовов и синхронном JS, можно переходить к асинхронному JavaScript. ",
      "Допустим, мы обрабатываем изображение и сетевой запрос, синхронным способом. ",
      " ",
      "      const processImage = (image: any) => { ",
      "            console.log('Изображение обработано');",
      "      }; ",
      " ",
      "      const networkRequest = (url: string) => { ",
      "            const someData = 'data';",
      "            return someData;",
      "      }; ",
      " ",
      "      const greeting = () => { ",
      "            console.log('Hello World');",
      "      }; ",
      " ",
      "      processImage('logo.jpg'); ",
      "      networkRequest('www.somerandomurl.com'); ",
      "      greeting(); ",
      " ",
      "На обработку изображения и сетевого запроса потребуется время. Продолжительность выполнения функции processImage() зависит от размера изображения. ",
      "После своего завершения функция processImage() вылетает из стека, после чего мы видим вызов функции networkRequest(), которая отправляется в стек. И всё это требует время на выполнение. ",
      "После завершения networkRequest(), вызывается функция greeting(), она выполняется незамедлительно, так как содержит только отчёт console.log, который выполняется довольно быстро. ",
      "Как видите, мы должны ожидать завершения функции (в нашем случае processImage() или networkRequest()). Эти функции блокируют стек выполнения или основной поток. До их завершения мы не сможем выполнить другие операции. ",
      " ",
      "6. Какое здесь может быть решение?",
      "Чтобы избавить наш код от блокировок можно использовать асинхронные callback’и, промисы с then(), промисы в связке async/await. ",
      " ",
      "6.1. Event loop, web API и callback queue ― НЕ являются частью движка JavaScript. Это всё относится к среде выполнения браузера или среде выполнения Nodejs (если речь идёт о Nodejs). ",
      " ",
      "6.2. Цикл обработки событий ",
      " ",
      "Event loop внутри себя содержит очередь, это очередь задач.",
      "Задача цикла обработки событий ― следить за состоянием стека вызовов и определять пуст он или нет. Если стек пуст, то проверяется очередь заданий, нет ли там вызовов, ожидающих выполнения. ",
      "Задачи из очереди могут попасть в стек только после того, когда этот стек полностью очистится. То есть все функции должны выполниться, стек у нас пустой и только тогда мы можем взять из очереди и выполнить. Это очень важный момент.",
      "Как все задачи попадают в очередь? За очередь отвечает Event loop, а за стек вызовов у нас отвечает движок JavaScript. ",
      "То есть, движок JavaScript предоставляет нам стеком вызовов, а Event loop предоставляет нам очередь задач. ",
      "У каждого браузера есть API. Это API предоставляет нам setTimeout(); setInterval(); обработку слушателей событий; обработку загрузки файлов, изображений; отправку каких нибудь запросов. Это всё не является спецификацией JavaScripta, это всё исключительно браузерные штуки. ",
      " ",
      "6.3. Как работает web API? Рассмотри пример: ",
      " ",
      "      function log(value: string) { ",
      "            console.log(value);",
      "      } ",
      " ",
      "      log('start'); ",
      " ",
      "      setTimeout(() => { ",
      "            log('timeout');",
      "      }, 3000); ",
      " ",
      "      log('end'); ",
      " ",
      "SetTimeout() попадает в стек вызовов, после этого он регистрируетя в web API, и вот на этом этапе запускаетя таймер (наши 3000 мс). После того, как таймер иссяк, мы отправляем наш коллбек () => { log('timeout') } в очередь задач.  После того, как наш стэк очистился, когда настало взять время из очереди, он выполняется.  ",
      "То есть порядок такой: выполнились все синхронные задачи. После истечения таймера задача попадает в очередь, и после того, как все синхронные задачи выполнены, мы берём задачу из этой очереди и выполняем её. ",
      "6.4. Используем промисы",
      "С помощью промисов мы можем запускать какой-то асинхронный код, который не будет блокировать основной поток. Браузерный fetch() для получения каких-то данных работает именно на промисах.  ",
      " ",
      "      function log(value: string) { ",
      "            console.log(value);",
      "      } ",
      " ",
      "      log('1'); ",
      " ",
      "      setTimeout(() => { ",
      "            log('2');",
      "      }, 100); ",
      " ",
      "      Promise.resolve().then(() => { ",
      "            log('3');",
      "      }); ",
      " ",
      "      log('4'); ",
      " ",
      "Порядок будет таким.",
      "// 1 ",
      "// 4 ",
      "// 3 ",
      "// 2 ",
      " ",
      "Как Event loop понимает, какие задачи брать ему быстрее: промисы, таймауты, колбеки, слушателя событий, подгрузку файла и т.д.   ",
      "На самом деле очередь представляет из себя две очереди:  ",
      "    *  это очередь событий или очередь макрозадач,",
      "    *  и очередь микрозадач",
      "У этих очередей есть определённый приоритет и Event loop берёт эти задачи в определённом порядке. ",
      "Промисы всегда попадают в очередь микротасок,  ",
      " ",

      "7. Отсрочка Выполнения Функции. Мы также можем использовать setTimeout, чтобы отложить выполнение функции, пока стек не будет очищен. ",
      " ",
      "      setTimeout(() => { ",
      "            console.log('Скоро, скоро...');",
      "      }, 100); ",
      " ",
      "Если мы не используем setTimeout, то console.log('Скоро, скоро...') будет выполнена незамедлительно, но используя setTimeout с таймером 0 секунд ― мы откладываем выполнение console.log('Скоро, скоро...') до опустошения стека. ",
      " ",

      "setImmediate() ",
      "setImmediate() — это специальный таймер, который выполняется в отдельной фазе цикла событий. Он использует API libuv, чтобы запланировать коллбэки для выполнения после завершения фазы опроса. ",
      "Если фаза опроса становится неактивной, а сценарии были поставлены в очередь с помощью setImmediate(), цикл событий может переходить на фазу проверки, а не ждать. ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Разница между setImmediate() и setTimeout()",
    answer: [
      "setImmediate() и setTimeout() похожи, но ведут себя по-разному в том, когда они вызываются. ",
      "    *  setImmediate() предназначен для выполнения сценария после завершения текущей фазы опроса.",
      "    *  setTimeout() планирует запуск сценария после истечения минимального порога в миллисекундах.",
    ],
    isParagraph: true,
  },
  {
    heading: "Чтобы не было переполнения стека вызовова в случае вызова факториала с очень большим числом. ",
    answer: [
      "Чтобы не было переполнения стека вызовова в случае вызова факториала с очень большим числом, мы можем решить задачу с помощью обычного цикла, перебором. Мы получили бы бесконечность, потому что JavaScript с такими большими числами работать не умеет.",
      " ",
      "      function factorial(n: number) { ",
      "            let result = 1;",
      "            for (let i = n; i > 1; i--) {",
      "                  result *= i;",
      "            }",
      "            return result; ",
      "      } ",
      " ",
      "      console.log(factorial(5)); // 120 ",
      "      console.log(factorial(100)); // 9.332621544394418e+157 ",
      "      console.log(factorial(10000000)); // Infinity ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое HTML?",
    answer: [
      "HTML — язык гипертекстовой разметки документов для просмотра веб-страниц в браузере. Он нужен, чтобы размещать на веб-странице элементы: текст, картинки, таблицы и видео. Веб-браузеры получают HTML документ от сервера по протоколам.",
      "Когда вы заходите на сайт, браузер подгружает HTML-файл с информацией о структуре и контенте веб-страницы. HTML как бы выстраивает визуальный фундамент сайта, но не «запускает» сайт самостоятельно. ",
      "Это строительный каркас приложения, всё будет видно, можно будет прочитать веб-страницу. Далее можно стилизовать при помощи CSS, добавить динамику при помощи Javascript.  ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните значение тегов <html>, <head> и <body> в HTML ",
    answer: [
      "Тег <html></html> является основой основ. Именно внутри него располагается вся информация. Благодаря этому тегу браузер понимает, где начинается контент, который необходимо обработать как HTML. ",
      "Важной частью тега html является наличие атрибута lang. В нём указывается язык, на котором отображается веб-страница. ",
      " ",
      "Значение тега HTML <head>: ",
      "",
      "Тег head в HTML используется для хранения метаданных или информации, относящейся к документу. Он содержит некоторые из наиболее важных тегов, таких как <title> , <meta> и <link>. ",
      " ",
      "Значение тега HTML <body> ",
      "Тег HTML body является последним дочерним элементом тега <html>. Он используется для размещения основного содержимого HTML-документа. Он содержит все, начиная с заголовка, абзацев и заканчивая уникальными контейнерами div , расположенными внутри тега <body> . ",
    ],
    isParagraph: true,
  },
  {
    heading: "Подключение JavaScript к странице, тег <script>",
    answer: [
      "1. Тег <script> используется для встраивания скриптов на страницу, которые могут изменять её содержимое и поведение. Этот тег позволяет загружать скрипты из внешних файлов или встраивать их прямо в HTML-код страницы. ",
      "Тег <script> используется для подключения файла js, или поместить внутри себя код js. Обычно, помещается в теге <head> или в конце тега <body>. Последним подключается index.js потому, что в него могут импортироваться предыдущие скрипты.",
      " ",
      "Добавление JavaScript на страницу выполняется с помощью тега <script>. ",
      "2. Первый способ – это вставка кода непосредственно на страницу. Выполняется это между открывающим и закрывающим тегом <script>. ",
      "",
      "      <script> ",
      "            alert('Привет, мир!');",
      "      </script> ",
      " ",
      "3. Второй способ заключается в использовании отдельного файла с расширением js. В данный файл необходимо поместить код JavaScript, а затем подключить его к странице с помощью <script>. Путь к файлу задаётся с помощью атрибута src.",
      "",
      "      <script src='main.js'></script> ",
      "",
      "С помощью этого способа можно подключить JavaScript к большому количеству HTML страниц. Это позволяет при изменении кода не править его на каждой странице. ",
      " ",
      "3.1. <script> можно поместить внутрь любого элемента, но рекомендуется непосредственно в <head> или <body>:",
      " ",
      "      <!doctype html> ",
      "      <html lang='ru'> ",
      "            <head>",
      "                  <meta charset='utf-8'>",
      "                  <meta name='viewport' content='width=device-width, initial-scale=1'>",
      "                  <title>Знакомство с JavaScript. Подключение к странице</title>",
      "                  <!-- Скрипт в <head> -->",
      "                  <script src='main-head.js'></script>",
      "            </head>",
      "            <body>",
      "                  ...",
      "                  <!-- Скрипт перед закрывающим тегом <body> -->",
      "                  <script src='main.js'></script>",
      "            </body>",
      "      </html> ",
      " ",
      "!!! Если подключить скрипт с помощью атрибута src и дополнительно ещё указать некоторый код между открывающим и закрывающим тегом script, то код, который вы указали непосредственно, будет проигнорирован, т.е. он не выполнится.",
      "",
      "Будет выполнен только скрипт common.js ",
      "      <script src='common.js'> ",
      "            alert('Это предупреждение никогда не отобразится!');",
      "      </script> ",
      " ",
      "4. async – атрибут для <script>, который используется для того, чтобы указать браузеру на то, что этот скрипт необходимо загрузить асинхронно, т.е. не останавливая основной поток чтения страницы. После загрузка скрипта, браузер сразу же его выполнит.",
      "",
      "      <script src='/path/to/app.js' async></script> ",
      " ",
      "5. defer – это ещё один атрибут для <script>, похожий на async. Он также указывает, что скрипт необходимо загрузить в фоне. Но в отличие от async, он будет выполнен после загрузки страницы, а точнее DOM. Кроме этого, стоит отметить, что скрипты, заданные с атрибутом async, выполняются перед вызовом события DOMContentLoaded.",
      "",
      "      <script src='/path/to/app.js' defer></script>",
      " ",
      "Ещё одно отличие defer от async в том, что defer сохраняет очередность их выполнения: ",
      "",
      "      <script src='/path/to/script-1.js' defer></script>",
      "      <script src='/path/to/script-2.js' defer></script>",
      " ",
      "Т.е. вне зависимости от того какой скрипт загрузится быстрее, они всё равно будут выполнены браузером в том порядке, в котором они расположены в коде. В данном примере, сначала выполнится «script-1.js», а затем «script-2.js» даже если второй загрузится быстрее, чем первый. ",
      "Если для <script> одновременно указать два атрибута, т.е. сразу async и defer, то будет работать только async. ",
      "",
      " <script src='path_to/script.js' async defer></script>",
      " ",
      "Атрибуты async и defer можно использовать только для скриптов, подключаемых на страницу с использованием src. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое CSS? Чем отличается HTML или CSS?",
    answer: [
      "Каскадная таблица стилей (CSS) — это набор команд и инструментов, который позволяет создавать привлекательные веб-страницы. CSS делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. ",
      "HTML и CSS – два основных языка, обычно используемых для веб-разработки. Разница между HTML и CSS заключается в том, что HTML – это язык разметки, который используется для создания структуры веб-страницы, а CSS – это язык стилей, который используется для того, чтобы сделать веб-страницы более презентабельными. ",
      "Но главное то, что CSS позволяет делать сайты намного быстрее. CSS может работать с таблицами, шрифтами, изображениями и демонстрирует гораздо большие возможности, чем обычный html. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое селекторы в CSS ",
    answer: [
      "Селектор (от англ. select — выбирать) — это шаблон, который позволяет обратиться к элементу или группе элементов веб-страницы, чтобы применить к ним стили CSS. Его указывают перед блоком со свойствами: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "В примере выше селектор указывает на тег <a> (гиперссылка). Так мы говорим браузеру отключить подчёркивание у всех ссылок на странице, устанавливая для свойства text-decoration значение none. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Виды селекторов CSS",
    answer: [
      "1. Универсальный селектор * ",
      "Он применяет стили ко всем элементам страницы и обозначается символом * (звёздочка). С его помощью удобно сбрасывать отступы и задавать значение box‑sizing для всех блочных элементов: ",
      "      * { ",
      "            margin: 0;",
      "            box-sizing: border-box;",
      "      } ",
      " ",
      "2. Селектор по тегу (элементу)",
      "Этот селектор CSS применяет стили ко всем элементам с одинаковым тегом. Например, для всех <div>, <h2>, <p> и так далее. ",
      "Мы уже познакомились с ним, когда убирали подчёркивание у ссылок: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "3. Селектор по идентификатору (id)",
      "Селектор по идентификатору обозначается символом # (решётка) и применяет стили к элементу, для которого задан атрибут id с соответствующим значением. При этом у элемента может быть только один id, и этот id должен быть уникальным в пределах веб-страницы. ",
      "      <p id='intro'>Сегодня мы расскажем вам об Emmet.</p>  ",
      "      <p id='article_content'>В этой статье вы узнаете:</p> ",
      " ",
      "CSS-код: ",
      "      #intro { ",
      "            color: red;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "      #article_content { ",
      "            font-family: sans-serif;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "4. Селектор по классу (class)",
      "CSS-селектор по классу выбирает элементы, для которых назначен атрибут class с соответствующим значением. При этом один элемент может принадлежать нескольким классам — в таком случае их перечисляют через пробел: ",
      "      <p class='plain_text article'>Сегодня мы расскажем вам про Emmet.</p>  ",
      " ",
      "Абзац входит в классы plain_text и article. Значит, к нему применяются стили обоих классов: ",
      "      .plain_text{ ",
      "            font-size: 20px;",
      "      } ",
      " ",
      "      .article{ ",
      "            font-family: 'Montserrat'; ",
      "      } ",
      " ",
      "5. Группа селекторов",
      "CSS-селекторы можно сгруппировать, чтобы применить стили к нескольким группам и/или классам элементов. Для этого достаточно перечислить их через запятую: ",
      "      .plain_text, p, h1, figure, div { ",
      "            margin-top: 0;",
      "            margin-left: 0;",
      "      } ",
      " ",
      "6. Выбор элементов по отношению и расположению",
      "Есть группа селекторов, которые позволяют выбрать элемент по его отношению к другим элементами (родитель — потомок) и по расположению в DOM (Document Object Model). ",
      " ",
      "6.1. Выбрать всех потомков. ",
      "Чтобы обратиться ко всем потомкам В элемента A, независимо от уровня их вложенности, используют конструкцию A B (селекторы разделяют пробелом): ",
      "      figure img { ",
      "            margin-bottom: 20px;",
      "      } ",
      "В примере выше мы устанавливаем всем изображениям внутри элемента figure значение нижних отступов 20 пикселей. ",
      " ",
      "6.2. Выбрать потомков первого уровня",
      "Если нужно применить CSS-стили к потомкам B элемента A только на первом уровне вложенности, то вместо пробела пишут символ >:",
      "      .container > img { ",
      "            margin-bottom: 40px;",
      "      } ",
      "Здесь мы задали изображениям внутри контейнера с классом .container значение нижних отступов 40 пикселей. ",
      " ",
      "6.3. Выбрать все следующие элементы ",
      "Селектор A ~ B выбирает все элементы B, которые идут после A. Обратите внимание: «идут после», а не вложены в него. Например, так мы задали цвет фона #f2f3f5 всем карточкам, которые идут после блока из класса .about_us: ",
      "      .about_us > .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      " ",
      "6.4. Выбрать первый следующий элемент",
      "Селектор A + B выбирает только первый элемент B, который следует за A: ",
      "      .about_us + .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      "В этом примере цвет фона #f2f3f5 установится только для той карточки, которая идёт сразу после .about_us. ",
      " ",
      "7. CSS-селекторы по атрибуту",
      "Ещё один полезный инструмент — селекторы по атрибуту. Они позволяют выбрать элемент по имени атрибута, его значению или части значения. Кратко расскажем обо всех. ",
      " ",
      "7.1. [attr] ",
      "Применяет стили к элементам, для которых задан этот атрибут: ",
      "[title] { ",
      " font-weight: bold;",
      "} ",
      " ",
      "8. Псевдоклассы и псевдоэлементы",
      "Псевдокласс выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM. ",
      "Вот несколько примеров таких состояний: ",
      "    *  на кнопку наведён курсор мыши;",
      "    *  пользователь перешёл или не перешёл по ссылке;",
      "    *  курсор установлен на поле ввода.",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?",
    answer: [
      "Позиционированием называется положение элемента в системе координат. Различают четыре типа позиционирования: нормальное, абсолютное, фиксированное и относительное. В зависимости от типа, который устанавливается через свойство position, изменяется и система координат.",
      "Благодаря комбинации свойств position, left, top, right и bottom элемент можно накладывать один на другой, выводить в точке с определёнными координатами, фиксировать в указанном месте, определить положение одного элемента относительно другого и др. Подобно другим свойствам CSS управление позиционированием доступно через скрипты. Таким образом, можно динамически изменять положение элементов без перезагрузки страницы, создавая анимацию и различные эффекты.",
      " ",
      " - static - Статическое позиционирование — это режим позиционирования, применяемый по умолчанию, при использовании которого элементы выводятся в том порядке, в котором они описаны в документе. Свойства top, right, bottom, left и z-index не применяются.",
      " - relative - Относительное позиционирование — это когда элемент смещается относительно своего положения, задаваемого по умолчанию на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов.",
      " - absolute - Абсолютное позиционирование - элемент выдёргивается из потока (не существует в потоке) и выстраивается относительно ближайшего элемента-предка с position: relative. Если его нет, то относительно body (страницы). Абсолютно спозиционированные элементы могут иметь margin и padding и не схлопываются с margin и padding других элементов. Никак не влияют на другие элементы.",
      " - fixed - Фиксированное позиционирование — это когда настраивают положение элемента, ориентируясь на края окна браузера. Элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. С помощью top, bottom и т.д. его можно прибить соответственно сверху, снизу и т.п.. Остаётся на позиции относительно окна документа и не меняет положение при скроле.",
      " - sticky - смесь relative и fixed. Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент. Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow)",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
];

import { IObjectHeadingAnswers } from "../models/types";

export const arrayInterviews: IObjectHeadingAnswers[] = [
  {
    heading: "Создание промиса ",
    answer: [
      "1. Сдал ли экзамен - passexam ",
      " ",
      "      const passexam = true; ",
      " ",
      "2. Создаём промис ",
      " ",
      "      const promise = new Promise((resolve, reject) => { ",
      "            setTimeout(() => {",
      "                  passexam ? console.log('Ok') : console.log('Not ok');",
      "            }, 100);",
      "      }); ",
      " ",
      "3. Создаём функцию ",
      " ",
      "      function test() { ",
      "            promise ",
      "                  .then((res) => res)",
      "                  .catch((error) => console.log(error));",
      "      } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Преобразовать промис в asynk / await ",
    answer: [
      "1. Сдал ли экзамен - passexam ",
      " ",
      "      const passexam = true; ",
      " ",
      "2. Создаём промис ",
      " ",
      "      const promise = new Promise((resolve, reject) => { ",
      "            setTimeout(() => {",
      "                  passexam ? console.log('Ok') : console.log('Not ok');",
      "            }, 100);",
      "      }); ",
      " ",
      "3. Создаём функцию asynk / await ",
      " ",
      "      const foo = async () => { ",
      "            try {",
      "                  await promise;",
      "            } catch (error) {",
      "                  console.log(error);",
      "            }",
      "      }; ",
    ],
    isParagraph: true,
  },
  {
    heading: "Promise промис и Typescript.",
    answer: [
      "1 - ая функция. ",
      " ",
      "      function someAsynkTask1(): Promise<number> { ",
      "            console.log('task 1');",
      "            return new Promise((res) => {",
      "                  setTimeout(() => res(1), 500);",
      "            });",
      "      } ",
      " ",
      "2 - ая функция. ",
      " ",
      "      function someAsynkTask2(): Promise<number> { ",
      "            console.log('task 2');",
      "            return new Promise((res) => {",
      "                  setTimeout(() => res(2), 500);",
      "            });",
      "      } ",
      " ",
      "3 - я функция main. ",
      " ",
      "      async function main(): Promise<number> { ",
      "            return (await someAsynkTask1()) + (await someAsynkTask2());",
      "      } ",
      " ",
      "4. Вызов фунции main",
      " ",
      "      main(); ",
    ],
    isParagraph: true,
  },
  {
    heading: "Способы перебора массива в JavaScript. ",
    answer: [
      "I. Перебор настоящих массивов ",
      " ",
      " 1. Метод forEach и родственные методы",
      " forEach предназначен для перебора всех элементов массива, но кроме него ES5 предлагает еще несколько полезных методов для перебора всех или некоторых элементов плюс выполнения при этом каких-либо действий с ними:",
      "    *  every — возвращает true, если для каждого элемента массива колбек возвращает значение приводимое к true.",
      "    *  some — возвращает true, если хотя бы для одного элемента массива колбек возвращает значение приводимое к true.",
      "    *  filter — создает новый массив, включающий те элементы исходного массива, для которых колбек возвращает true.",
      "    *  map — создает новый массив, состоящий из значений возращаемых колбеком.",
      "    *  reduce — сводит массив к единственному значению, применяя колбек по очереди к каждому элементу массива, начиная с первого (может быть полезен для вычисления суммы элементов массива и других итоговых функций).",
      "    *  reduceRight — работает аналогично reduce, но перебирает элементы в обратном порядке",
      " ",
      " 2. Цикл for() - для перебора элементов массива, символов строк по цифровым индексам.",
      " 3. Цикл for..of не предоставляет доступа к индексу текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.",
    ],
    isParagraph: true,
  },
  {
    heading: "Атрибуты загрузки скриптов <script async> и <script defer>",
    answer: [
      "Подключаемые скрипты (JavaScript) блокирует загрузку HTML кода. Когда браузер (парсер) доходит до тега <script> он останавливается, чтобы загрузить контент файла и выполнить его код, и только после этого продолжает парсинг HTML. ",
      "Такое поведение может тормозить отображение HTML, когда на странице загружаются много файлов JavaScript. Часто код этих файлов не нужен, чтобы показать HTML страницы. Именно поэтому рекомендуется подключать скрипты в конце страницы. Однако эту рекомендацию не всегда можно соблюсти и для таких случаев есть другие способы не блокировать отрисовку HTML. ",
      "У элемента <script> есть два атрибута, async и defer, которые могут дать нам больше контроля над тем, как и когда файл загружаются и выполняются. ",
      " ",
      "1. SRC - это путь до самого скрипта. ",
      "2. Атрибуты defer и async. С помощью этих атрибутов можно сказать браузеру как и в каком порядке загружать скрипты.",
      "Скрипты с атрибутами defer загружаются и выполняются последовательно, а с async – асинхронно. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async выполняется сразу после загрузки. ",
      " ",
      "2.1. defer ",
      "Cообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.",
      "   *  Скрипты с атрибутом defer никогда не блокируют страницу, будут предотвращать запуск события DOMContentLoaded до тех пор, пока скрипт не загрузится полностью и не завершится его инициализация. ",
      "   *  Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.",
      " ",
      "      <script src='script1.js' defer></script> ",
      "      <script src='script2.js' defer></script> ",
      "Первым всегда выполнится script1.js, который подключён раньше ",
      " ",
      "2.2. Атрибут async ",
      "Означает, что скрипт абсолютно независим: ",
      "   *  Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.",
      "   *  Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:",
      "Скрипт выполняется полностью асинхронно. Это означает, что файл будет выполняться без ожидания загрузки и отображения веб-страницы. При обнаружении <script async src='...'> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится. ",
      " ",
      "      <script src='script1.js' async></script>",
      "      <script src='script2.js' async></script>",
      " ",
      "Первым выполнится тот скрипт, который быстрее загрузится. ",
      " ",
      "3. Подсказки. ",
      "",
      "Динамически вставленный <script> (например, вставленный при помощи document.createElement) по умолчанию загружается браузером асинхронно. ",
      "",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните разницу между <script>, <script async> и <script defer>. ",
    answer: [
      "      <script> — отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта. ",
      "      <script async> — скрипт будет извлечен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте async тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.",
      "      <script defer> — скрипт будет извлечен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут defer обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом <body>. Отложенный скрипт не должен содержать document.write.",
    ],
    isParagraph: true,
  },
  {
    heading: "Влияет ли размер CSS файла на загрузку страницы?",
    answer: [
      "Если вес файла стилей будет 50 мгБ, то пока он грузится, заблокирует нам рендеринг.",
      "Вес всего, что вы размещаете на странице будет влиять на её загрузку. Однако, есть и вторая сторона вопроса. Разбив файл на множество мелких, подгружая их в каждом нужном разделе, вы увеличиваете количество запросов, необходимых для чтения этих файлов. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое специфичность селекторов CSS? ",
    answer: [
      "Специфичность CSS-селекторов - это алгоритм, основанный на правилах соответствия селекторов CSS, который определяет, какие стили будут примены к данному элементу. ",
      "Специфичность селекторов по возрастанию: ",
      "     - тег и псевдоэлемент имеют специфичность 0001 ",
      "     - класс, псевдокласс, атрибут - 0010",
      "     - id имеет специфичность 0100 ",
      " ",
      "1. Специфичность CSS важна только тогда, когда несколько селекторов влияют на один и тот же элемент. Браузеру нужен способ выяснить, какой стиль применять к соответствующему элементу, когда существуют противоречивые значения свойств. ",
      "2. Когда два или более совпадающих селектора имеют одно и то же значение (вес) специфичности, браузер выбирает «самый последний» совпадающий селектор, который появляется ближе к нижней части списка совпадающих селекторов. Следующий пункт объясняет, что такое «список подходящих селекторов».",
      "3. Браузер формирует «список подходящих селекторов», комбинируя все стили на веб-странице и отфильтровывая те, которые не соответствуют элементу «currently-being-styled». Первые селекторы в таблице стилей находятся вверху списка, а последние селекторы — внизу.",
      "4. Свойство style для элемента имеет большее значение специфичности, чем селекторы в таблицах стилей, за исключением случаев, когда есть !important в селекторе таблиц стилей.",
      "5. Использование !important (что в некоторых случаях считается плохой практикой) изменяет специфичность селектора. Когда два селектора имеют одинаковую специфичность, выигрывает селектор с !important. И когда они оба имеют !important, «самый последний» селектор выигрывает.",
    ],
    isParagraph: true,
  },
  {
    heading: "Какая разница между элементами <span> и <div>? ",
    answer: [
      "     - <span> — это строчный (inline) элемент.",
      "     - <div> — это блочный (block) элемент.",
      " ",
      "Элементы <div> нужно использовать для оформления разделов документа. А элементы <span> — в роли контейнеров для небольших объёмов текста, для изображений и других подобных элементов страниц. ",
      "Надо отметить, что нельзя помещать блочные элементы в строчные. ",
    ],
    isParagraph: true,
  },
  {
    heading: "В чём разница между строчным, блочным и блочно-строчным элементом?",
    answer: [
      "    *  Блочные элементы (display: block)",
      " ",
      "Блочные элементы в отличие от строчных элементов занимают по умолчанию всю ширину блока-контейнера, в которую они помещены. По этому признаку можно легко определить, к какому способу отображения относится элемент. Высота блочного элемента по умолчанию определяется автоматически и зависит от содержимого, которое в него помещено. Блочный элемент можно представить как прямоугольник, который имеет ширину (width) и высоту (height). Ширину и (или) высоту блочного элемента можно задавать вручную с помощью CSS свойств width и (или) height. Также блочные элементы имеют границы, которые можно оформлять с помощью стилей CSS. Кроме этого блочным элементам можно задавать отступы внешние и внутренние. Внешний отступ (margin) – это отступ от границы до элемента контейнера или до соседних блочных элементов. Внутренний отступ (padding) – это отступ для содержимого блока, который задаётся от границы. ",
      "Блочные элементы могут содержать строчные элементы и другие блочные элементы, для которых их родитель будет являться контейнером. Блочные элементы предназначены для разработки каркаса веб-страницы, разметки больших блоков текста и много другого. ",
      " ",
      "    *  Строчные элементы (display: inline) ",
      " ",
      "Строчными называются такие элементы, которые являются непосредственной частью строкии занимают такое количество пространства, которое необходимо для отображения их содержимого. У них значение свойства display: inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
      "Строчным элементам нельзя установить размеры (width и height), задать верхние и нижние margin отступы. ",
      "Для строчного элемента, размещенного на одной линии, можно использовать padding, margin-left и margin-right, border. ",
      " ",
      "    *  Строчно-блочные элементы (display: inline-block )",
      "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
      "div { display: inline-block } ",
    ],
    isParagraph: true,
  },
  {
    heading: "Дефолтные стили браузера и их нормализация",
    answer: [
      "Каждый браузер имеет дефолтные стили (user agent stylesheet). Эти стили задают оформление, которые HTML элементы имеют по умолчанию. ",
      "Т.е., если в браузере открыть HTML документ без привязанного к нему CSS кода, то он уже будет каким-то образом оформлен. Это базовое оформление задаётся с использованием стилей браузера. ",
      "Но в разных браузерах дефолтные стили могут быть различными. ",
      "Например, в одном в браузере некоторый элемент может иметь одно оформление, а в другом - другое. ",
      "Для того чтобы нормализовать стили, которые отличаются в разных браузерах можно использовать Normalize.css:",
      " ",
      "      https://necolas.github.io/normalize.css/ ",
      " ",
      "Этот файл необходимо скачать, поместить в проект и подключить: ",
      " ",
      "      <!doctype html> ",
      "      <html lang='ru'> ",
      "            <head>",
      "                  <meta charset='utf-8'>",
      "                  <meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'>",
      "                  <!-- Normalize CSS -->",
      "                  <link rel='stylesheet' href='normalize.css'>",
      "                  <title>Normalize CSS</title>",
      "            </head>",
      "",
      "            <body>",
      " ",
      "            </body>",
      "      </html> ",
      " ",
      "После подключения этого файла все элементы в HTML документе будут отображаться более согласовано и в соответствии со современными стандартами. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что происходит после того как пользователь ввел URL в адресную строку браузера и нажал Enter?",
    answer: [
      "На высоком уровне, когда мы вводим какой-то URL в браузере, нажимаем Enter, у нас отправляется на сервер GET-запрос и в ответ на этот GET-запрос сервер разрешает какую-то HTML- страницу. Соответственно у нас рендерится дом-дерево, так же у нас рендерятся стили. Потом навешиваются всякие слушатели событий, подключается JS и мы можем взаимодействовать со страницей.   ",
      "На более низком уровне, когда мы вводим какой-то URL в браузере, запрос обрабатывается DNS сервером ",
      "Поскольку адреса серверов в интернете имеют цифровой вид (IP-адрес), то для перевода букв в цифры существует служба доменных имён (DNS). Браузер отсылает запрос с адресной строкой DNS-серверу. Там происходит перевод адреса в цифровой вид (IP-адрес). DNS-сервер ищет соответствующий адрес в своих базах, после чего пересылает запрос на просмотр страницы по найденному адресу, или ответ браузеру что такой адрес не найден. ",
      "Если адрес верен, то найденный сервер связывается с вашим браузером и передает ему содержание страницы. И после этого уже загружаются станицы.",
      "Работает это всё, по большей части, на HTTP, HTTPs. ",
    ],
    isParagraphBefore: true,
  },
  {
    heading: "Главное различие img и background-image.",
    answer: [
      "Различие состоит в том, что картинки несущие смысловую нагрузку или же каким-либо образом относящиеся к содержанию страницы следует вставлять тегом img (картинки в тексте, баннеры, картинки слайдера, аватарки и тд). Все остальное (просто элементы оформления: различного рода разделители, маркеры, фоны и тд.) следует вставлять в дизайн используя background-image.",
      "  *  В первую очередь таким образом мы очищаем код страницы, что значительно улучшает его читабельность, упрощает понимание документа поисковым роботам, ускоряет загрузку страницы за счет все того же уменьшения документа, в общем крайне положительно сказывается на SEO оптимизации страницы. ",
      "  *  Используя img для вывода картинок несущих на себе смысловую нагрузку мы даем возможность поисковикам прочитать альты этих картинок и лучше понять что они из себя представляют, есть возможность получения дополнительного трафика на сайт из сервисов поиска по картинкам, получаем лучшую уникализацию контента (поисковики любят текст разбавленный картинками, поскольку это обычно улучшает поведенческие факторы посетителей ресурса).",
      "  *  Различные рекламные сервисы, счетчики и CMS для вывода своего содержимого и аватарок посетителей используют картинки, что абсолютно нормально и логично, поскольку данные элементы по логике вещей относятся не к оформлению страницы, а к ее содержимому. ",
      " ",
      "Нюансы из практики",
      " ",
      "  *  При печати страницы сайта теги img печатаются, а background-ы нет.",
      "  *  Браузеры разработанные для людей с ограниченными возможностями читают альты картинок, потому если изображение несет важный смысл, оно обязательно должно быть оформлено html тегом.",
      "  *  Некоторые старые браузеры не поддерживают свойство background-size и для создания масштабируемого фона в них используется тег, а не свойство фона.",
      "  *  Img с анимацией меньше нагружает браузеры.",
      "  *  Для замены текста изображением лучше использовать background-image (к примеру, если нужно вывести заголовки красивыми картинками).",
      "  *  Используя свойство фона мы можем вывести на странице только часть изображения.",
    ],
    isParagraph: true,
  },
  {
    heading: "Асинхронный JavaScript ― Цикл обработки событий ",
    answer: [
      "1. JavaScript — однопоточный язык программирования. Движок JS V-8 единовременно может обрабатывать только одно выражение — в одном потоке. ",
      "С одной стороны, отсутствие многопоточности упрощает написание кода, потому что вам ненужно беспокоиться о проблемах параллельного выполнения. С другой стороны, вы не можете выполнять длительные операции, например сетевой доступ, не блокируя основной поток. ",
      "Представьте себе запрос данных из API. В зависимости от ситуации, серверу потребуется какое-то время на обработку запроса, а пока основной поток занят — страница будет неотзывчива. ",
      "В таких случаях нужна асинхронность. Используя асинхронный JavaScript (например callback, promise, и async/await), вы можете выполнять длительные сетевые запросы, не блокируя основной поток. ",
      " ",
      "2. Контекст выполнения ",
      " ",
      "Контекст выполнения — это среда, где код анализируется и выполняется. Всякий раз, когда в JavaScript выполняется код, это происходит внутри контекста выполнения.  ",
      "Код функции выполняется внутри контекста выполнения функции. ",
      "А глобальный код выполняется в глобальном контексте выполнения. У каждой функции есть свой контекст выполнения. ",
      " ",
      "3. Стек вызовов ",
      " ",
      "Стек вызовов -  это механизм, предназначенный для отслеживания текущего местонахождения интерпретатора в скрипте. Он вызывает несколько функций и определяет, какая из них выполняется на данный момент, какие функции вызываются внутри выполняемой функции и какая будет вызвана следующей. ",
      "Стек вызовов создается, когда внутри функции (или метода) существуют другие функции. В реальных приложениях таких уровней могут быть сотни. Стек вызовов формируется каждый раз, когда мы запускаем код на стороне браузера. ",
      "Стек вызовов имеет структуру LIFO (последний пришел, первый вышел), в котором хранятся все контексты выполнения, созданные в течение выполнения кода. ",
      "В JavaScript есть только один стек вызовов, так как это однопоточный язык. Стек вызовов имеет структуру LIFO, поэтому элементы могут быть добавлены или удалены только сверху стека. ",
      "Стек вызовов ограничен по количеству находимых в нём функций. При перезаполнении вылетает ошибка.",
      " ",
      "4. Как выполняется синхронный код внутри движка JS. Например, этот:",
      " ",
      "      const second = () => { ",
      "            console.log('Hello there!');",
      "      }; ",
      " ",
      "      const first = () => { ",
      "            console.log('Hi there!');",
      "            second();",
      "            console.log('The End');",
      "      }; ",
      " ",
      "      first(); ",
      " ",
      "4.1. Итак, что же здесь происходит?",
      " ",
      "При исполнении этого кода, был создан глобальный контекст выполнения (главная функция main()) и помещён в стек, сверху. Когда в коде встречается вызов first(), он также помещается в стек, сверху. ",
      "Далее, в стек попадает console.log('Hi there!'), также сверху, а после завершения вылетает из стека. Далее мы вызываем функцию second(), с ней происходит то же самое. ",
      "Далее, console.log('Hello there!') попадает в стек и после завершения вылетает из него. Функция second() завершается и то же вылетает из стека. ",
      "console.log(‘The End’) попадает в стек и вылетает после завершения. После этого завершается функция first() и вылетает из стека ",
      "На этом выполнение программы завершено и глобальный контекст выполнения (main()) вылетает из стека. ",
      " ",
      "5. Как работает асинхронный JavaScript?",
      " ",
      "Теперь, когда у вас есть представление о стеке вызовов и синхронном JS, можно переходить к асинхронному JavaScript. ",
      "Допустим, мы обрабатываем изображение и сетевой запрос, синхронным способом. ",
      " ",
      "      const processImage = (image: any) => { ",
      "            console.log('Изображение обработано');",
      "      }; ",
      " ",
      "      const networkRequest = (url: string) => { ",
      "            const someData = 'data';",
      "            return someData;",
      "      }; ",
      " ",
      "      const greeting = () => { ",
      "            console.log('Hello World');",
      "      }; ",
      " ",
      "      processImage('logo.jpg'); ",
      "      networkRequest('www.somerandomurl.com'); ",
      "      greeting(); ",
      " ",
      "На обработку изображения и сетевого запроса потребуется время. Продолжительность выполнения функции processImage() зависит от размера изображения. ",
      "После своего завершения функция processImage() вылетает из стека, после чего мы видим вызов функции networkRequest(), которая отправляется в стек. И всё это требует время на выполнение. ",
      "После завершения networkRequest(), вызывается функция greeting(), она выполняется незамедлительно, так как содержит только отчёт console.log, который выполняется довольно быстро. ",
      "Как видите, мы должны ожидать завершения функции (в нашем случае processImage() или networkRequest()). Эти функции блокируют стек выполнения или основной поток. До их завершения мы не сможем выполнить другие операции. ",
      " ",
      "6. Какое здесь может быть решение?",
      "Чтобы избавить наш код от блокировок можно использовать асинхронные callback’и, промисы с then(), промисы в связке async/await. ",
      " ",
      "6.1. Event loop, web API и callback queue ― НЕ являются частью движка JavaScript. Это всё относится к среде выполнения браузера или среде выполнения Nodejs (если речь идёт о Nodejs). ",
      " ",
      "6.2. Цикл обработки событий ",
      " ",
      "Event loop внутри себя содержит очередь, это очередь задач.",
      "Задача цикла обработки событий ― следить за состоянием стека вызовов и определять пуст он или нет. Если стек пуст, то проверяется очередь заданий, нет ли там вызовов, ожидающих выполнения. ",
      "Задачи из очереди могут попасть в стек только после того, когда этот стек полностью очистится. То есть все функции должны выполниться, стек у нас пустой и только тогда мы можем взять из очереди и выполнить. Это очень важный момент.",
      "Как все задачи попадают в очередь? За очередь отвечает Event loop, а за стек вызовов у нас отвечает движок JavaScript. ",
      "То есть, движок JavaScript предоставляет нам стеком вызовов, а Event loop предоставляет нам очередь задач. ",
      "У каждого браузера есть API. Это API предоставляет нам setTimeout(); setInterval(); обработку слушателей событий; обработку загрузки файлов, изображений; отправку каких нибудь запросов. Это всё не является спецификацией JavaScripta, это всё исключительно браузерные штуки. ",
      " ",
      "6.3. Как работает web API? Рассмотри пример: ",
      " ",
      "      function log(value: string) { ",
      "            console.log(value);",
      "      } ",
      " ",
      "      log('start'); ",
      " ",
      "      setTimeout(() => { ",
      "            log('timeout');",
      "      }, 3000); ",
      " ",
      "      log('end'); ",
      " ",
      "SetTimeout() попадает в стек вызовов, после этого он регистрируетя в web API, и вот на этом этапе запускаетя таймер (наши 3000 мс). После того, как таймер иссяк, мы отправляем наш коллбек () => { log('timeout') } в очередь задач.  После того, как наш стэк очистился, когда настало взять время из очереди, он выполняется.  ",
      "То есть порядок такой: выполнились все синхронные задачи. После истечения таймера задача попадает в очередь, и после того, как все синхронные задачи выполнены, мы берём задачу из этой очереди и выполняем её. ",
      "6.4. Используем промисы",
      "С помощью промисов мы можем запускать какой-то асинхронный код, который не будет блокировать основной поток. Браузерный fetch() для получения каких-то данных работает именно на промисах.  ",
      " ",
      "      function log(value: string) { ",
      "            console.log(value);",
      "      } ",
      " ",
      "      log('1'); ",
      " ",
      "      setTimeout(() => { ",
      "            log('2');",
      "      }, 100); ",
      " ",
      "      Promise.resolve().then(() => { ",
      "            log('3');",
      "      }); ",
      " ",
      "      log('4'); ",
      " ",
      "Порядок будет таким.",
      "// 1 ",
      "// 4 ",
      "// 3 ",
      "// 2 ",
      " ",
      "Как Event loop понимает, какие задачи брать ему быстрее: промисы, таймауты, колбеки, слушателя событий, подгрузку файла и т.д.   ",
      "На самом деле очередь представляет из себя две очереди:  ",
      "    *  это очередь событий или очередь макрозадач,",
      "    *  и очередь микрозадач",
      "У этих очередей есть определённый приоритет и Event loop берёт эти задачи в определённом порядке. ",
      "Промисы всегда попадают в очередь микротасок,  ",
      " ",

      "7. Отсрочка Выполнения Функции. Мы также можем использовать setTimeout, чтобы отложить выполнение функции, пока стек не будет очищен. ",
      " ",
      "      setTimeout(() => { ",
      "            console.log('Скоро, скоро...');",
      "      }, 100); ",
      " ",
      "Если мы не используем setTimeout, то console.log('Скоро, скоро...') будет выполнена незамедлительно, но используя setTimeout с таймером 0 секунд ― мы откладываем выполнение console.log('Скоро, скоро...') до опустошения стека. ",
      " ",

      "setImmediate() ",
      "setImmediate() — это специальный таймер, который выполняется в отдельной фазе цикла событий. Он использует API libuv, чтобы запланировать коллбэки для выполнения после завершения фазы опроса. ",
      "Если фаза опроса становится неактивной, а сценарии были поставлены в очередь с помощью setImmediate(), цикл событий может переходить на фазу проверки, а не ждать. ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: "Разница между setImmediate() и setTimeout()",
    answer: [
      "setImmediate() и setTimeout() похожи, но ведут себя по-разному в том, когда они вызываются. ",
      "    *  setImmediate() предназначен для выполнения сценария после завершения текущей фазы опроса.",
      "    *  setTimeout() планирует запуск сценария после истечения минимального порога в миллисекундах.",
    ],
    isParagraph: true,
  },
  {
    heading: "Чтобы не было переполнения стека вызовова в случае вызова факториала с очень большим числом. ",
    answer: [
      "Чтобы не было переполнения стека вызовова в случае вызова факториала с очень большим числом, мы можем решить задачу с помощью обычного цикла, перебором. Мы получили бы бесконечность, потому что JavaScript с такими большими числами работать не умеет.",
      " ",
      "      function factorial(n: number) { ",
      "            let result = 1;",
      "            for (let i = n; i > 1; i--) {",
      "                  result *= i;",
      "            }",
      "            return result; ",
      "      } ",
      " ",
      "      console.log(factorial(5)); // 120 ",
      "      console.log(factorial(100)); // 9.332621544394418e+157 ",
      "      console.log(factorial(10000000)); // Infinity ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое HTML?",
    answer: [
      "HTML — это язык гипертекстовой разметки текста. Он нужен, чтобы размещать на веб-странице элементы: текст, картинки, таблицы и видео. ",
      "Когда вы заходите на сайт, браузер подгружает HTML-файл с информацией о структуре и контенте веб-страницы. HTML как бы выстраивает визуальный фундамент сайта, но не «запускает» сайт самостоятельно. ",
      "Это строительный каркас приложения, всё будет видно, можно будет прочитать веб-страницу. Далее можно стилизовать при помощи CSS, добавить динамику при помощи Javascript.  ",
    ],
    isParagraph: true,
  },
  {
    heading: "Объясните значение тегов < html>, <head> и <body> в HTML ",
    answer: [
      "Тег< html></html> является основой основ. Именно внутри него располагается вся информация. Благодаря этому тегу браузер понимает, где начинается контент, который необходимо обработать как HTML. ",
      "Важной частью тега html является наличие атрибута lang. В нём указывается язык, на котором отображается веб-страница. ",
      " ",
      "Значение тега HTML <head>: ",
      "",
      "Тег head в HTML используется для хранения метаданных или информации, относящейся к документу. Он содержит некоторые из наиболее важных тегов, таких как <title> , <meta> и <link>. ",
      " ",
      "Значение тега HTML <body> ",
      "Тег HTML body является последним дочерним элементом тега <html>. Он используется для размещения основного содержимого HTML-документа. Он содержит все, начиная с заголовка, абзацев и заканчивая уникальными контейнерами div , расположенными внутри тега <body> . ",
    ],
    isParagraph: true,
  },
  {
    heading: "Подключение JavaScript к странице, тег <script>",
    answer: [
      "1. Тег <script> используется для встраивания скриптов на страницу, которые могут изменять её содержимое и поведение. Этот тег позволяет загружать скрипты из внешних файлов или встраивать их прямо в HTML-код страницы. ",
      "Тег <script> используется для подключения файла js, или поместить внутри себя код js. Обычно, помещается в теге <head> или в конце тега <body>. Последним подключается index.js потому, что в него могут импортироваться предыдущие скрипты.",
      " ",
      "Добавление JavaScript на страницу выполняется с помощью тега <script>. ",
      "2. Первый способ – это вставка кода непосредственно на страницу. Выполняется это между открывающим и закрывающим тегом <script>. ",
      "",
      "      <script> ",
      "            alert('Привет, мир!');",
      "      </script> ",
      " ",
      "3. Второй способ заключается в использовании отдельного файла с расширением js. В данный файл необходимо поместить код JavaScript, а затем подключить его к странице с помощью <script>. Путь к файлу задаётся с помощью атрибута src.",
      "",
      "      <script src='main.js'></script> ",
      "",
      "С помощью этого способа можно подключить JavaScript к большому количеству HTML страниц. Это позволяет при изменении кода не править его на каждой странице. ",
      " ",
      "3.1. <script> можно поместить внутрь любого элемента, но рекомендуется непосредственно в <head> или <body>:",
      " ",
      "      <!doctype html> ",
      "      <html lang='ru'> ",
      "            <head>",
      "                  <meta charset='utf-8'>",
      "                  <meta name='viewport' content='width=device-width, initial-scale=1'>",
      "                  <title>Знакомство с JavaScript. Подключение к странице</title>",
      "                  <!-- Скрипт в <head> -->",
      "                  <script src='main-head.js'></script>",
      "            </head>",
      "            <body>",
      "                  ...",
      "                  <!-- Скрипт перед закрывающим тегом <body> -->",
      "                  <script src='main.js'></script>",
      "            </body>",
      "      </html> ",
      " ",
      "!!! Если подключить скрипт с помощью атрибута src и дополнительно ещё указать некоторый код между открывающим и закрывающим тегом script, то код, который вы указали непосредственно, будет проигнорирован, т.е. он не выполнится.",
      "",
      "Будет выполнен только скрипт common.js ",
      "      <script src='common.js'> ",
      "            alert('Это предупреждение никогда не отобразится!');",
      "      </script> ",
      " ",
      "4. async – атрибут для <script>, который используется для того, чтобы указать браузеру на то, что этот скрипт необходимо загрузить асинхронно, т.е. не останавливая основной поток чтения страницы. После загрузка скрипта, браузер сразу же его выполнит.",
      "",
      "      <script src='/path/to/app.js' async></script> ",
      " ",
      "5. defer – это ещё один атрибут для <script>, похожий на async. Он также указывает, что скрипт необходимо загрузить в фоне. Но в отличие от async, он будет выполнен после загрузки страницы, а точнее DOM. Кроме этого, стоит отметить, что скрипты, заданные с атрибутом async, выполняются перед вызовом события DOMContentLoaded.",
      "",
      "      <script src='/path/to/app.js' defer></script>",
      " ",
      "Ещё одно отличие defer от async в том, что defer сохраняет очередность их выполнения: ",
      "",
      "      <script src='/path/to/script-1.js' defer></script>",
      "      <script src='/path/to/script-2.js' defer></script>",
      " ",
      "Т.е. вне зависимости от того какой скрипт загрузится быстрее, они всё равно будут выполнены браузером в том порядке, в котором они расположены в коде. В данном примере, сначала выполнится «script-1.js», а затем «script-2.js» даже если второй загрузится быстрее, чем первый. ",
      "Если для <script> одновременно указать два атрибута, т.е. сразу async и defer, то будет работать только async. ",
      "",
      " <script src='path_to/script.js' async defer></script>",
      " ",
      "Атрибуты async и defer можно использовать только для скриптов, подключаемых на страницу с использованием src. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое CSS? Чем отличается HTML или CSS?",
    answer: [
      "Каскадная таблица стилей (CSS) — это набор команд и инструментов, который позволяет создавать привлекательные веб-страницы. CSS делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. ",
      "HTML и CSS – два основных языка, обычно используемых для веб-разработки. Разница между HTML и CSS заключается в том, что HTML – это язык разметки, который используется для создания структуры веб-страницы, а CSS – это язык стилей, который используется для того, чтобы сделать веб-страницы более презентабельными. ",
      "Но главное то, что CSS позволяет делать сайты намного быстрее. CSS может работать с таблицами, шрифтами, изображениями и демонстрирует гораздо большие возможности, чем обычный html. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Что такое селекторы в CSS ",
    answer: [
      "Селектор (от англ. select — выбирать) — это шаблон, который позволяет обратиться к элементу или группе элементов веб-страницы, чтобы применить к ним стили CSS. Его указывают перед блоком со свойствами: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "В примере выше селектор указывает на тег <a> (гиперссылка). Так мы говорим браузеру отключить подчёркивание у всех ссылок на странице, устанавливая для свойства text-decoration значение none. ",
    ],
    isParagraph: true,
  },
  {
    heading: "Виды селекторов CSS",
    answer: [
      "1. Универсальный селектор * ",
      "Он применяет стили ко всем элементам страницы и обозначается символом * (звёздочка). С его помощью удобно сбрасывать отступы и задавать значение box‑sizing для всех блочных элементов: ",
      "      * { ",
      "            margin: 0;",
      "            box-sizing: border-box;",
      "      } ",
      " ",
      "2. Селектор по тегу (элементу)",
      "Этот селектор CSS применяет стили ко всем элементам с одинаковым тегом. Например, для всех <div>, <h2>, <p> и так далее. ",
      "Мы уже познакомились с ним, когда убирали подчёркивание у ссылок: ",
      "      a { ",
      "              text-decoration: none;",
      "      }",
      " ",
      "3. Селектор по идентификатору (id)",
      "Селектор по идентификатору обозначается символом # (решётка) и применяет стили к элементу, для которого задан атрибут id с соответствующим значением. При этом у элемента может быть только один id, и этот id должен быть уникальным в пределах веб-страницы. ",
      "      <p id='intro'>Сегодня мы расскажем вам об Emmet.</p>  ",
      "      <p id='article_content'>В этой статье вы узнаете:</p> ",
      " ",
      "CSS-код: ",
      "      #intro { ",
      "            color: red;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "      #article_content { ",
      "            font-family: sans-serif;",
      "            font-weight: bold;",
      "      } ",
      " ",
      "4. Селектор по классу (class)",
      "CSS-селектор по классу выбирает элементы, для которых назначен атрибут class с соответствующим значением. При этом один элемент может принадлежать нескольким классам — в таком случае их перечисляют через пробел: ",
      "      <p class='plain_text article'>Сегодня мы расскажем вам про Emmet.</p>  ",
      " ",
      "Абзац входит в классы plain_text и article. Значит, к нему применяются стили обоих классов: ",
      "      .plain_text{ ",
      "            font-size: 20px;",
      "      } ",
      " ",
      "      .article{ ",
      "            font-family: 'Montserrat'; ",
      "      } ",
      " ",
      "5. Группа селекторов",
      "CSS-селекторы можно сгруппировать, чтобы применить стили к нескольким группам и/или классам элементов. Для этого достаточно перечислить их через запятую: ",
      "      .plain_text, p, h1, figure, div { ",
      "            margin-top: 0;",
      "            margin-left: 0;",
      "      } ",
      " ",
      "6. Выбор элементов по отношению и расположению",
      "Есть группа селекторов, которые позволяют выбрать элемент по его отношению к другим элементами (родитель — потомок) и по расположению в DOM (Document Object Model). ",
      " ",
      "6.1. Выбрать всех потомков. ",
      "Чтобы обратиться ко всем потомкам В элемента A, независимо от уровня их вложенности, используют конструкцию A B (селекторы разделяют пробелом): ",
      "      figure img { ",
      "            margin-bottom: 20px;",
      "      } ",
      "В примере выше мы устанавливаем всем изображениям внутри элемента figure значение нижних отступов 20 пикселей. ",
      " ",
      "6.2. Выбрать потомков первого уровня",
      "Если нужно применить CSS-стили к потомкам B элемента A только на первом уровне вложенности, то вместо пробела пишут символ >:",
      "      .container > img { ",
      "            margin-bottom: 40px;",
      "      } ",
      "Здесь мы задали изображениям внутри контейнера с классом .container значение нижних отступов 40 пикселей. ",
      " ",
      "6.3. Выбрать все следующие элементы ",
      "Селектор A ~ B выбирает все элементы B, которые идут после A. Обратите внимание: «идут после», а не вложены в него. Например, так мы задали цвет фона #f2f3f5 всем карточкам, которые идут после блока из класса .about_us: ",
      "      .about_us > .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      " ",
      "6.4. Выбрать первый следующий элемент",
      "Селектор A + B выбирает только первый элемент B, который следует за A: ",
      "      .about_us + .card { ",
      "            background-color: #f2f3f5;",
      "      } ",
      "В этом примере цвет фона #f2f3f5 установится только для той карточки, которая идёт сразу после .about_us. ",
      " ",
      "7. CSS-селекторы по атрибуту",
      "Ещё один полезный инструмент — селекторы по атрибуту. Они позволяют выбрать элемент по имени атрибута, его значению или части значения. Кратко расскажем обо всех. ",
      " ",
      "7.1. [attr] ",
      "Применяет стили к элементам, для которых задан этот атрибут: ",
      "[title] { ",
      " font-weight: bold;",
      "} ",
      " ",
      "8. Псевдоклассы и псевдоэлементы",
      "Псевдокласс выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM. ",
      "Вот несколько примеров таких состояний: ",
      "    *  на кнопку наведён курсор мыши;",
      "    *  пользователь перешёл или не перешёл по ссылке;",
      "    *  курсор установлен на поле ввода.",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
  {
    heading: " ",
    answer: [
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
      " ",
    ],
    isParagraph: true,
  },
];

import React from "react";
import Page from "../components/general/Page/Page";
import PageLink from "../components/general/PageLink/PageLink";
import { ILinkInfo, IObjectHeadingAnswers } from "../models/types";

const CSS = () => {
  const links: ILinkInfo[] = [
    {
      href: "https://webstool.ru/jquery.maskedinput.html",
      title: "jQuery.Maskedinput js - маска для телефона",
    },
    {
      href: "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors",
      title: "Селекторы CSS",
    },
    {
      href: "https://htmlacademy.ru/blog/css/selectors",
      title: "Селекторы CSS по htmlacademy",
    },
    {
      href: "https://habr.com/ru/company/ruvds/blog/485640/",
      title: "Какими способами можно визуально скрыть элемент?",
    },
    {
      href: "http://htmlbook.ru/samlayout/blochnaya-verstka/strochnye-elementy",
      title: "Строчные элементы в HTML (Языке Гипертекстовой Разметки),",
    },
    {
      href: "https://developer.mozilla.org/ru/docs/Web/HTML/Inline_elements",
      title: "Строчные элементы по 'developer.mozilla'",
    },
    {
      href: "https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements",
      title: "Блочные элементы по 'developer.mozilla'",
    },
    {
      href: "http://htmlbook.ru/css/display",
      title: "Свойство display.",
    },
    {
      href: "http://htmlbook.ru/samlayout/blochnaya-verstka/pozitsionirovanie-elementov",
      title: "Позиционирование элементов",
    },
    {
      href: "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements",
      title: "Псевдоэлемент в CSS",
    },
    {
      href: "https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-classes",
      title: "Псевдокласс в CSS",
    },
    {
      href: " ",
      title: " ",
    },
    {
      href: " ",
      title: " ",
    },
    {
      href: " ",
      title: " ",
    },
  ];

  const ArrayHeadingAnswers: IObjectHeadingAnswers[] = [
    {
      heading: "CSS, фреймворки CSS.",
      answer: [
        "Каскадная таблица стилей (CSS) формально является набором команд и инструментов для работы с внешним видом веб-страницы. Она делает интерфейс более восприимчивым и приятным – огромное количество сайтов работает на основе связки HTML и CSS. Как и в случае с языками программирования, существует множество готовых библиотек CSS, созданных профессионалами для удобства работы со стилями.",
        "CSS-фреймворк — фреймворк, созданный для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки (проблемы совместимости различных версий браузеров и т. д.). Готовые к использованию классы являются их основными строительными блоками. Они позволяют применять к элементам HTML заранее определенные правила, а также включают в себя готовые компоненты (меню, кнопки, карточки). Данные фреймворки подразумевают использование различных подходов для корректного отображения сайтов на устройствах любого размера. Многие разработчики предпочитают использование CSS-фреймворков, вместо прописывания всех стилей вручную. Это обусловлено следующими причинами:",
        " - Более быстрая разработка ",
        " - Поддержка кроссбраузерности",
        " - Поддержка различных устройств и размеров экранов",
        " - Единообразие кода при работе в команде позволяет снизить число разногласий при разработке. ",
        " - Как и библиотеки скриптовых языков программирования, CSS-библиотеки, обычно имеющие вид внешнего CSS-файла, добавляются в заголовок веб-страницы.",
      ],
      isParagraph: true,
    },
    {
      heading: "Рассмотрим самые популярные CSS-фреймворки.",
      answer: [
        "Bootstrap",
        "https://getbootstrap.com/",
        "Material Design for Bootstrap",
        "https://mdbootstrap.com/docs/standard/",
        "Materialize",
        "https://materializecss.com/",
        "Bulma",
        "https://bulma.io/",
        "Pure",
        "https://purecss.io/",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
      ],
      isParagraph: true,
    },
    {
      heading: "Какими CSS-фреймворками вы пользовались? Что бы вы хотели в них изменить/улучшить?",
      answer: [
        "Использовал Bootstrap, Materialize и др. CSS-фреймворки накладывают ограничения и добавляют работы по переопределению дефолтных свойств элементов. Если нет чётких требования использования фреймворков, стараюсь их избегать.",
      ],
      isParagraph: true,
    },
    {
      heading: "Какая разница между селекторами идентификаторов и классов в CSS?",
      answer: [
        "Идентификаторы (id) уникальны. У элемента может быть только один идентификатор. На странице может присутствовать лишь один элемент с конкретным идентификатором.",
        "Имена классов (class) не являются уникальными. Один и тот же класс можно назначать множеству элементов. Элементу может быть назначено несколько классов.",
        "Если некий стиль нужно применить к нескольким элементам страницы — эту задачу нужно решать с использованием классов.",
      ],
      isParagraph: true,
    },
    {
      heading: "Псевдоэлементы ::after, ::before и другие",
      answer: [
        "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент ::first-line может быть использован для изменения шрифта первой строки абзаца.",
      ],
      isParagraph: true,
    },
    {
      heading: "Псевдоклассы :hover, :visited, :checked и другие",
      answer: [
        "Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое позволяет стилизовать элемент: ",
        " - на основе отношений в DOM-дереве,",
        " - истории посещений (например, :visited),",
        " - состоянии содержимого (вроде :checked у некоторых элементов формы)",
        " - или позиции курсора мыши (например, :hover определяет, находится ли курсор мыши над элементом)... ",
        " - Например, :hover может быть использован для изменения цвета кнопки при наведении курсора на неё.",
      ],
      isParagraph: true,
    },
    {
      heading: "Как задать элементу определенные стили при наведении, при нажатии, при фокусе?",
      answer: [
        "при наведении - с помощью псевдокласса hover ",
        "при нажатии - с помощью псевдокласса active ",
        "при фокусе - с помощью псевдокласса focus ",
      ],
      isParagraph: true,
    },
    {
      heading:
        "У вас есть список покупок. Каждому второму элементу списка необходимо задать синий фон. Как это можно сделать используя псевдоселекторы ",
      answer: ["С помощью псевдокласса tr:nth-child(even) или tr:nth-child(2n) (чётные строки HTML)", " "],
      isParagraph: true,
    },
    {
      heading: "Как пользоваться медиазапросами @media в CSS?",
      answer: [
        "В медиазапросах используется правило @media, с помощью которого можно применять CSS-стили к различным типам содержимого. Медиазапросы могут использоваться и для настройки элементов страниц с учётом характеристик среды, в которой просматривают страницы.",
        "/* Изменить фоновый цвет любого элемента div на ''red'' в том случае, если ширина окна браузера составляет 600px или меньше */ ",
        "@media only screen and ( max-width: 600px ) {div { background-color: red }} ",
        "Медиа-запросы @media позволяют задавать различные стили элементам, компонентам вэб-приложения для определенного размера экрана, типа устройства, где данное вэб-приложение просматривается или используется. Все медиа-запросы начинаются с @media, а далее следует условие. ",
        "С помощью медиа-запросов можно задать стили для следующих типов устройств: ",
        " - all — все типы (значение используется по умолчанию)",
        " - braille — устройства, основанные на системе Брайля, которые предназначены для чтения слепыми людьми",
        " - embossed — принтеры, использующие для печати систему Брайля ",
        " - handheld — смартфоны и аналогичные им аппараты",
        " - print — принтеры и другие печатающие устройства",
        " - projection — проекторы",
        " - screen — экран монитора",
        " - speech — речевые синтезаторы, а также программы для воспроизведения текста вслух",
        " - tty — устройства с фиксированным размером символов",
        " - tv — телевизоры.",
      ],
      isParagraph: true,
    },
    {
      heading: "Специфичность CSS-селекторов и как она работает?",
      answer: [
        "Если одному и тому же элементу определенно сразу несколько CSS-правил с разными селекторами, то браузер применит тот стиль, который определён по специфичности CSS-селекторов.",
        "Специфичность CSS-селекторов - это алгоритм, основанный на правилах соответствия селекторов CSS, который определяет, какие стили будут примены к данному элементу.",
        "Специфичность селекторов по возрастанию:",
        " - тег и псевдоэлемент имеют специфичность 0001 ",
        " - класс, псевдокласс, атрибут - 0010 ",
        " - id имеет специфичность 0100 ",
        " - инлайновый стиль (style=''...'') указанный в HTML-коде имеет приоритет 1000 ",
        " ",
        " ",
      ],
      isParagraph: true,
    },
    {
      heading: "reset - «сброс», Normalize - «нормализация». В чем разница между ними?",
      answer: [
        "Сброс (reset) сбрасывает все дефолтно-браузерные стили HTML-элементов.",
        "Normalize приводит стили к единому виду во всех браузерах.",
        "Цели normalize.css: ",
        " - сохранять полезные настройки браузера, а не стирать их;",
        " - нормализовать стили для широкого круга HTML-элементов;",
        " - корректировать ошибки и несоответствия браузера;",
        " - совершенствовать юзабилити незаметными улучшениями;",
        " - объяснять код, используя комментарии и детальную документацию.",
        " Из-за кроссбраузерности следует выбирать Normalize, но я пользуюсь reset",
      ],
      isParagraph: true,
    },
    {
      heading: "Как вы решаете стилевые проблемы, связанные с особенностями браузеров?",
      answer: [" - Использую normalize или reset CSS", " - Использую автопрефиксы (autoprefixer)"],
      isParagraph: true,
    },
    {
      heading: "floats, как они работают",
      answer: [
        "При применении этого свойства происходит следующее:",
        " 1. Элемент позиционируется как обычно, а затем вынимается из потока документа и сдвигается влево (для left) или вправо (для right) до того как коснётся либо границы родителя, либо другого элемента с float. ",
        " 2. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться. ",
        " 3. Другие непозиционированные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из потока.  ",
        " 4. Строки (inline-элементы), напротив, «знают» о float и обтекают элемент по сторонам.",
      ],
      isParagraph: true,
    },
    {
      heading: "свойство z-index",
      answer: [
        "Позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы. Их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative (абсолютное, фиксированное или относительное).",
        " - Элементы с большим z-index перекрывают элементы с меньшим. ",
        " - При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML написан ниже.",
        " - Если свойства z-index и позиционирование не заданы явно, то порядок наложения равен порядку следования элементов в HTML.",
      ],
      isParagraph: true,
    },
    {
      heading: "Эффективый CSS, на что обратить внимание?",
      answer: [
        "Для написания эффективного CSS должна быть система. Я использую модификацию БЭМ и препроцессор SASS. Код можно переиспользовать.",
      ],
      isParagraph: true,
    },
    {
      heading: "Какими способами можно визуально скрыть элемент?",
      answer: [
        "Элементы, невидимые на странице, могут пребывать в различных состояниях:",
        " - Некий элемент совершенно невидим и, более того, удалён из потока документа.",
        " - Глазами элемент не увидеть, но он присутствует в документе и доступен для ассистивных технологий наподобие средств для чтения с экрана.",
        " - Элемент видим, но скрыт от средств для чтения с экрана.",
      ],
      isParagraph: true,
    },
    {
      heading: "1. HTML5-атрибут hidden ",
      answer: [
        "Hidden — это логический HTML-атрибут, скрывающий элементы, которым он назначен. Когда браузер загружает страницу, он не выведет элементы с атрибутом hidden, за исключением тех случаев, когда видимость элементов будет включена вручную средствами CSS.",
        "<img hidden src=''landscape.jpg'' /> ",
        "Вот CSS-код, который здесь использован:  ",
        " - 1. img[ hidden ] { display: none }",
        " - 2. @media ( min-width: 400px ) { img[ hidden ] { display: block }}",
        "Если рассмотреть 'атрибут hidden' с точки зрения доступности контента, то окажется, что этот атрибут полностью скрывает элемент. В результате с этим элементом не смогут работать средства для чтения с экрана. Не используйте этот атрибут в тех случаях, когда некие элементы страниц нужно делать невидимыми для человека, но не для программ для чтения с экрана. ",
      ],
      isParagraph: true,
    },
    {
      heading: "2. CSS-свойство display",
      answer: [
        " - 1. img { display: none } ",
        " - 2.  @media ( min-width: 400px ) {img { display: block }} ",
        "При использовании свойства 'display: none' элемент становится невидимым и, кроме того, недоступным для средств чтения с экрана. ",
      ],
      isParagraph: true,
    },
    {
      heading: "3. CSS-свойство opacity",
      answer: [
        " - 1. img { opacity: 0 }  ",
        "Элемент, скрытый с помощью opacity: 0, остаётся доступным для средств чтения с экрана. Такой элемент может получить фокус при работе со страницей с помощью клавиатуры. ",
      ],
      isParagraph: true,
    },
    {
      heading: "4. CSS-свойство visibility",
      answer: [
        " - 1. article { visibility: hidden }",
        " - 2. img {  visibility: visible } ",
        "При применении свойства visibility: hidden элемент оказывается скрытым. Он, кроме того, удаляется из дерева доступности и, в результате, его не замечают средства для чтения с экрана. ",
      ],
      isParagraph: true,
    },
    {
      heading: "5.Скрытие элементов и позиционирование",
      answer: [
        " - .container { position: absolute; top: -100%; (left: -100%); (right: -100%); }",
        " - .container:focus { position: absolute; top: 0; (left: 0); (right: 0); }",
        "Элемент, выведенный за пределы области просмотра, доступен для средств чтения с экрана, добраться до него можно и с помощью клавиатуры. Он лишь оказывается невидимым при обычной работе со страницей.",
      ],
      isParagraph: true,
    },
    {
      heading: "6. Размеры компонента",
      answer: ["width: 0px; height: 0px;"],
      isParagraph: true,
    },
    {
      heading: "7. CSS-свойство clip-path",
      answer: [
        "Если к элементу применяется CSS-свойство clip-path — оно позволяет описать область, определяющую то, какая часть элемента должна быть скрытой, а какая — видимой.",
        " -  img { clip-path: circle(0 at 50% 50%) }",
        "Элемент, к которому применено свойство clip-path, скрыт лишь визуально. До него можно добраться с помощью клавиатуры, он доступен для программ чтения с экрана.",
      ],
      isParagraph: true,
    },
    {
      heading: "8. Манипуляции с цветом текста и с размером шрифта",
      answer: [
        "Хотя скрытие текста путём изменения его цвета или размеров шрифта распространено не так широко, как ранее рассмотренные методики скрытия элементов, в некоторых случаях это может пригодиться.",
      ],
      isParagraph: true,
    },
    {
      heading: "9. Настройка прозрачности цвета",
      answer: [
        "Если использовать для текста прозрачный цвет, то этот текст окажется невидимым. Это может оказаться полезным при создании кнопок, на которых используются только значки.",
      ],
      isParagraph: true,
    },
    {
      heading: "10. Настройка размера шрифта",
      answer: ["Кроме того, если установить размер шрифта в значение 0, это тоже позволит скрыть текст."],
      isParagraph: true,
    },
    {
      heading: "Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?",
      answer: ["Использовал сетку Bootstrap, CSS grid, флекс. Предпочитаю флекс."],
      isParagraph: true,
    },
    {
      heading: "Что такое блочный контекст форматирования?",
      answer: [
        "Блочный контекст форматирования — это отображение и взаимодействие компонентов веб-страницы в привычном для блоков порядке.",
        "Блочный контекст форматирования могут создать: ",
        " - блочные HTML-элементы",
        " - float-элементы, флекс-элементы, грид-элементы",
        " - позиционированные элементы",
        " - «строчные блоки» (элементы с display: inline-block)",
        " - ячейки, анонимные ячейки, заголовки таблицы ",
      ],
      isParagraph: true,
    },
    {
      heading: "Строчная модель. Строчные элементы в HTML (Языке Гипертекстовой Разметки)",
      answer: [
        "Строчные элементы, это те, которые занимают только то пространство, которое ограничено тегами, определяющими строчный элемент (необходимое для отображения их содержимого) и не нарушая потока содержимого (не требующее новой строки после каждого элемента).",
        "Строчный элемент не начинается с новой строки, в ширину занимает столько места, сколько это необходимо для его отображения.",
      ],
      isParagraph: true,
    },
    {
      heading: "В чём разница между строчным, блочным и блочно-строчным элементом?",
      answer: [
        "Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства display установлено как inline. Элементы, для которых это значение задано по умолчанию, — <span>, <a>, <q>, <code> и др., в основном они используются для изменения вида текста или его смыслового выделения.",
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. Он занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство display задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов.",
        "Строчно-блочных элементы сочетают преимущества строчных и блочных элементов. В HTML нет тега, который относится к строчно-блочным элементам, его можно определить, задав элементу свойство display со значением inline-block. ",
        "div { display: inline-block } ",
      ],
      isParagraph: true,
    },
    {
      heading: "Строчный элемент - 'inline' ",
      answer: [
        " - Размер зависит от контента.",
        " - Ширину и высоту задавать нельзя.",
        " - Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит - от line-height.",
        " - Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.",
        " ------------------------------------",
        "Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено.",
        "Эффект схлопывания отступов не действует. ",
        "Свойства, связанные с размерами (width, height) не применимы.",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько строчных элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.",
        "Можно выравнивать по вертикали с помощью свойства vertical-align.",
      ],
      isParagraph: true,
    },
    {
      heading: "Блочный элемент - 'block' ",
      answer: [
        "Блочным называется элемент, который отображается на веб-странице в виде прямоугольника. ",
        "Такой элемент занимает всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.",
        "К блочным элементам относятся контейнеры div, h1, form и др ",
        "Блочная модель отвечает за определение того, сколько места займет блочный элемент, схлопнутся или нет border или margin, размеры блока. ",
        "Размеры блочного элемента складываются из width, height, padding, border, and margin. ",
        "Если высота (height) блока не задана, то высота блока равна: высота контента этого блока + padding'и.",
        "Если ширина блока не задана, то блоки, для которых не задано float, будут иметь ширину: ширина родителя - padding'и родителя.",
        " ------------------------------------",
        " - Начинается с новой строки родительского элемента и занимает всю строку. ",
        " - Можно задавать ширину и высоту. ",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон.",
        " ------------------------------------",
        "Блоки располагаются по вертикали друг под другом.",
        "На прилегающих сторонах элементов действует эффект схлопывания отступов. ",
        "Запрещено вставлять блочный элемент внутрь строчного. Например, <a><h1>Заголовок</h1></a> не пройдёт валидацию, правильно вложить теги наоборот — <h1><a>Заголовок</a></h1>. ",
        "По ширине блочные элементы занимают всё допустимое пространство. ",
        "Если задана ширина контента (свойство width), то ширина блока складывается из значений width, полей, границ, отступов слева и справа.",
        "Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.",
        "Если задана высота контента (свойство height), то высота блока складывается из значения height, полей, границ, отступов сверху и снизу. При превышении указанной высоты контент отображается поверх блока. ",
        "На блочные элементы не действуют свойства, предназначенные для строчных элементов, вроде vertical-align. ",
        "Текст по умолчанию выравнивается по левому краю.",
      ],
      isParagraph: true,
    },
    {
      heading: "Блочно-строчный элемент - 'inline-block' ",
      answer: [
        " - Размер зависит от контента.",
        " - Можно задавать ширину и высоту.",
        " - Можно выровнять с помощью vertical-align.",
        " - Margins и paddings работают со всех сторон. ",
        " ------------------------------------",
        "Внутрь строчно-блочных элементов допустимо помещать текст, строчные или блочные элементы. ",
        "Высота элемента вычисляется браузером автоматически, исходя из содержимого блока. ",
        "Ширина равна содержимому плюс значения отступов, полей и границ.",
        "Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости. ",
        "Можно выравнивать по вертикали с помощью свойства vertical-align. ",
        "Разрешено задавать ширину и высоту. ",
        "Эффект схлопывания отступов не действует. ",
        " ------------------------------------",
        "Пример использования:",
        "http://htmlbook.ru/samlayout/blochnaya-verstka/strochno-blochnye-elementy",
      ],
      isParagraph: true,
    },
    {
      heading: "Что делает * { box-sizing: border-box; }? В чём его преимущества?",
      answer: [
        "Свойство box-sizing определяет как вычисляется общая ширина и высота элемента. По умолчанию все элементы имеют box-sizing: content-box. - `content-box`. Если мы задаём элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а финальная ширина элемента, в этом случае, увеличится на сумму отступов и толщину бордера. ",
        "Значение свойства `border-box` говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. ",
      ],
      isParagraph: true,
    },
    {
      heading: "Свойство display определяет тип отображения элемента, как элемент должен быть показан в документе.",
      answer: [
        "1. none - элемент не показывается. ",
        "2. block - блочные элементы располагаются вертикально один над другим. Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно. Это значение`display`многие элементы имеют по умолчанию:`div` , заголовок`h1,`параграф`p.` ",
        "3. Inline-элементы располагаются на одной строке, последовательно. Ширина и высота элемента определяются по содержимому. Поменять их нельзя.",
        "4. Inline-block - элемент продолжает находиться в строке (`inline`), но при этом может иметь важные свойства блока, ему можно указать ширину и высоту явно. ",
        "5. Flex - это свойство, при котором элемент растягивается или сжимается для заполнения собой свободного пространства. ",
        "6. Inline-flex - похоже на флекс, только элементы будут растягиваться или сжиматься инлайново (в строку) для заполнения собой свободного пространства. ",
        "7. Table - Для таблицы целиком`table`, для строки –`table-row`, для ячейки –`table-cell`и т.д. ",
      ],
      isParagraph: true,
    },
    {
      heading: "Пользовались ли вы Flexbox или Grid?",
      answer: ["Да. Использую flexbox. У grid всё ещё не такая широкая поддержка браузеров."],
      isParagraph: true,
    },
    {
      heading: "Позиционирование элементов, типы позиционирования.",
      answer: [
        "Позиционированием называется положение элемента в системе координат. Различают четыре типа позиционирования: нормальное, абсолютное, фиксированное и относительное. В зависимости от типа, который устанавливается через свойство position, изменяется и система координат.",
        "Благодаря комбинации свойств position, left, top, right и bottom элемент можно накладывать один на другой, выводить в точке с определёнными координатами, фиксировать в указанном месте, определить положение одного элемента относительно другого и др. Подобно другим свойствам CSS управление позиционированием доступно через скрипты. Таким образом, можно динамически изменять положение элементов без перезагрузки страницы, создавая анимацию и различные эффекты.",
        "1. Нормальное позиционирование.",
        "Если для элемента свойство position не задано или его значение static, элемент выводится в потоке документа как обычно. Иными словами, элементы отображаются на странице в том порядке, как они идут в исходном коде HTML. Свойства left, top, right, bottom если определены, игнорируются.",
        "2. Абсолютное позиционирование",
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью» ",
        "3. Фиксированное положение",
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю",
        "4. Относительное позиционирование",
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. ",
      ],
      isParagraph: true,
    },
    {
      heading: "Абсолютное позиционирование",
      answer: [
        "При абсолютном позиционировании элемент не существует в потоке документа и его положение задаётся относительно краёв браузера. Задать этот тип можно через значение absolute свойства position. Координаты указываются относительно краёв окна браузера, называемого «видимой областью»",
        "Для режима характерны следующие особенности. ",
        " - Ширина слоя, если она не задана явно, равна ширине контента плюс значения полей, границ и отступов.",
        " - Слой не меняет своё исходное положение, если у него нет свойств right, left, top и bottom.",
        " - Свойства left и top имеют более высокий приоритет по сравнению с right и bottom. Если left и right противоречат друг другу, то значение right игнорируется. То же самое касается и bottom",
        " - Если left задать отрицательное значение, то слой уйдёт за левый край браузера, полосы прокрутки при этом не возникнет. Это один из способов спрятать элемент от просмотра. То же относится и к свойству top, только слой уйдёт за верхний край.",
        " - Если left задать значение больше ширины видимой области или указать right с отрицательным значением, появится горизонтальная полоса прокрутки. Подобное правило работает и с top, только речь пойдёт о вертикальной полосе прокрутки.",
        " - Одновременно указанные свойства left и right формируют ширину слоя, но только если width не указано. Стоит добавить свойство width и значение right будет проигнорировано. Аналогично произойдёт и с высотой слоя, только уже участвуют свойства top, bottom и height.",
        " - Элемент с абсолютным позиционированием перемещается вместе с документом при его прокрутке.",
        "Свойство position со значением absolute можно использовать для создания эффекта фреймов. Кроме абсолютного позиционирования для элементов необходимо назначить свойство overflow со значением auto. Тогда при превышении контентом высоты видимой области появится полоса прокрутки. Высота и ширина «фреймов» формируется автоматически путём одновременного использования свойств left, right для ширины и top, bottom для высоты ",
        " - В браузере IE6 для абсолютно позиционированных элементов нельзя одновременно задать свойства left, right и top, bottom.",
        "Абсолютное позиционирование также применяется для создания различных эффектов, например, всплывающей подсказки к фотографиям. В отличие от атрибута title тега <img> который также выводит текст подсказки, через стили можно управлять видом текста выводимого с помощью скрипта. ",
      ],
      isParagraph: true,
    },
    {
      heading: "Фиксированное положение",
      answer: [
        "Фиксированное положение слоя задаётся значением fixed свойства position и по своему действию похоже на абсолютное позиционирование. Но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Ещё одна разница от absolute заключается в том, что при выходе фиксированного слоя за пределы видимой области справа или снизу от неё, не возникает полос прокрутки. Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, любых элементов, которые должны быть закреплены на странице и всегда видны посетителю",
      ],
      isParagraph: true,
    },
    {
      heading: "Относительное позиционирование",
      answer: [
        "Если задать значение relative свойства position, то положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. Положительное значение left определяет сдвиг вправо от левой границы элемента, отрицательное — сдвиг влево. Положительное значение top задаёт сдвиг элемента вниз  (рис. 3.46), отрицательное — сдвиг вверх. ",
        "Свойства bottom и right производят обратный эффект. При положительном значении right сдвигает элемент влево от его правого края, при отрицательном — сдвигает вправо (рис. 3.47). При положительном значении bottom элемент поднимается вверх, при отрицательном опускается вниз.",
        "Для относительного позиционирования характерны следующие особенности ",
        " - Этот тип позиционирования не применим к элементам таблицы вроде ячеек, строк, колонок и др.",
        " - При смещении элемента относительно исходного положения, место, которое занимал элемент, остаётся пустым и не заполняется ниже или вышележащими элементами.",
      ],
      isParagraph: true,
    },
    {
      heading: "sticky - смесь relative и fixed.",
      answer: [
        "Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент.",
        "Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow) ",
      ],
      isParagraph: true,
    },
    {
      heading: "Вложенные слои",
      answer: [
        "Обычно относительное позиционирование само по себе применяется не часто, поскольку есть ряд свойств выполняющих фактически ту же роль, к примеру, тот же margin. Но сочетание разных типов позиционирования для вложенных слоёв является одним из удобных и практичных приёмов вёрстки. Если для родительского элемента задать relative, а для дочернего absolute, то произойдёт смена системы координат и положение дочернего элемента при этом указывается относительно его родителя ",
        "Отсчёт координат ведётся от внутреннего края границы, значения полей не учитываются",
        "Благодаря использованию четырёх свойств left, right, top, bottom для управления положением внутреннего слоя, размеры родительского слоя знать не обязательно. Это расширяет сферу применения позиционирования, поэтому position довольно активно применяется при вёрстке различных элементов.  ",
      ],
      isParagraph: true,
    },
    {
      heading: "В чём разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?",
      answer: [
        " - static - значение по умолчанию, позволяет элементу находиться в обычном его состоянии. Свойства top, right, bottom, left и z-index не применяются.",
        " - relative - элемент позиционируется в соответствии с потоком документа, а затем смещается относительно себя на основе значений top, right, bottom и left. Смещение не влияет на положение любых других элементов.",
        " - absolute - элемент выдёргивается из потока и выстраивается относительно ближайшего элемента-предка с position: relative. Если его нет, то относительно body (страницы). Абсолютно спозиционированные элементы могут иметь margin и padding и не схлопываются с margin и padding других элементов. Никак не влияют на другие элементы.",
        " - fixed - элемент выбивается из обычного потока документа, и для элемента в макете страницы не создаётся пространство. С помощью top, bottom и т.д. его можно прибить соответственно сверху, снизу и т.п.. Остаётся на позиции относительно окна документа и не меняет положение при скроле.",
        " - sticky - смесь relative и fixed. Элемент ведёт себя как относительно спозиционированный, пока не достигнет заданной позиции, после которой ведёт себя как fixed элемент. Элемент позиционируется в соответствии с нормальным потоком документа, а затем смещается относительно его ближайшего прокручивающего предка и содержащего блока (ближайший родительский уровень блока). Липкий элемент «прилипает» к его ближайшему предшественнику, имеющему «механизм прокрутки» (созданный при помощи overflow)",
      ],
      isParagraph: true,
    },
    {
      heading:
        "Использование CSS препроцессоров? Опишите, что вам нравится и не нравится в CSS препроцессорах, которыми вы пользовались. ",
      answer: [" Преимущества: ", " - Вложенность. Удобно писать по БЭМу. ", " - Переменные."],
      isParagraph: true,
    },
    {
      heading: "1. Центрирование блочного элемента ",
      answer: [
        "Задать родителю (display: flex) ",
        "  .container { display: flex }",
        "Задать дочернему флекс-элементу (margin: auto).",
        "  .child { margin: auto }  ",
      ],
      isParagraph: true,
    },
    {
      heading: "2. Центрирование блочного элемента",
      answer: [
        "Задать контейнеру-родителю: .container { display: flex;  align-items: center;  justify-content: center; }",
      ],
      isParagraph: true,
    },
    {
      heading: "3. Центрирование блочного элемента по горизонтали",
      answer: [".child { width: 123px; margin: 12px auto }"],
      isParagraph: true,
    },
    {
      heading: "Центрирования инлайновых элементов ",
      answer: ["По горизонтали: h1 {text-align: center}", "По вертикали: h1 {vertical-align: middle} ", " ", " ", " "],
      isParagraph: true,
    },
    {
      heading: "Выравнивание инлайновых элементов с помощью line-height ",
      answer: [
        "Если известно, что внутренний блок должен занимать не более одной строки текста, то можно воспользоваться свойством line-height и задать его равным высоте внешнего блока. Поскольку контент внутреннего блока не должен переноситься на вторую строку, рекомендуется также добавить правила white-space: nowrap и overflow: hidden. ",
        " - .container { height: 200px; line-height: 200px }",
        " - .child { white-space: nowrap; overflow: hidden }",
      ],
      isParagraph: true,
    },
    {
      heading: "Выравнивание многострочного текста",
      answer: [
        " .container { height: 200px; line-height: 200px }",
        ".child { line-height: normal; display: inline-block; vertical-align: middle } ",
      ],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " ", " ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
    {
      heading: " ",
      answer: [" ", " "],
      isParagraph: true,
    },
  ];

  return (
    <div>
      <PageLink links={links} title="CSS ссылки" />
      <Page title="Вопросы по CSS" ArrayHeadingAnswers={ArrayHeadingAnswers} />
    </div>
  );
};

export default CSS;
